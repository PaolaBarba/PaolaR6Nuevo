% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ConfMatrix.R
\name{ConfMatrix}
\alias{ConfMatrix}
\title{Confusion matrix}
\description{
The ConfMatrix class works with confusion matrices, thus providing
the possibility of calculating several indices with their
corresponding variances and confidence intervals. A confusion matrix
is constructed by comparing a sample of a set of common positions in
the product and the ground truth. Appropriate sampling methods must
be applied to generate the confusion matrix. It is considered that
the classes of the ground truth correspond to the columns
and that the classes of the product to be valued correspond
to the rows. First, an object of this class of object must be created
(instantiated) and then the methods that offer the index calculations
will be invoked. Mnemonic method names are proposed and are therefore
long, for example methods that provide averages start with "AV" and
those that provide combinations start with "Comb". Methods related
to a specific class end with the ending "_i".
}
\note{
Error Messages: List of possible errors:
\itemize{
 \item \code{Error type 1}: Non-square matrix.
 \item \code{Error type 2}: Single element matrix.
 \item \code{Error type 3}: Negative values.
 \item \code{Error type 4}: Sum of elements 0.
 \item \code{Error type 5}: Sum of rows 0.
 \item \code{Error type 6}: Sum of columns 0.
 \item \code{Error type 7}: It is not a matrix.
}
}
\examples{

## ------------------------------------------------
## Method `ConfMatrix$new`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
cm<-ConfMatrix$new (A,ID="5",Date="27-10-2023",
Source="Congalton and Green, 2008")


## ------------------------------------------------
## Method `ConfMatrix$OverallAcc`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A)
p$OverallAcc()


## ------------------------------------------------
## Method `ConfMatrix$UserAcc`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$UserAcc()


## ------------------------------------------------
## Method `ConfMatrix$UserAcc_i`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$UserAcc_i(2)


## ------------------------------------------------
## Method `ConfMatrix$AvUserAcc`
## ------------------------------------------------

A<-matrix(c(352,43,89,203),nrow=2,ncol=2)
p<-ConfMatrix$new(A,Source="Tung and LeDrew 1988")
p$AvUserAcc()


## ------------------------------------------------
## Method `ConfMatrix$CombUserAcc`
## ------------------------------------------------

A<-matrix(c(352,43,89,203),nrow=2,ncol=2)
p<-ConfMatrix$new(A,Source="Tung and LeDrew 1988")
p$CombUserAcc()


## ------------------------------------------------
## Method `ConfMatrix$ProdAcc`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$ProdAcc()


## ------------------------------------------------
## Method `ConfMatrix$ProdAcc_i`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$ProdAcc_i(1)


## ------------------------------------------------
## Method `ConfMatrix$AvProdAcc`
## ------------------------------------------------

A<-matrix(c(352,43,89,203),nrow=2,ncol=2)
p<-ConfMatrix$new(A,Source="Tung and LeDrew 1988")
p$AvProdAcc()


## ------------------------------------------------
## Method `ConfMatrix$CombProdAcc`
## ------------------------------------------------

A<-matrix(c(352,43,89,203),nrow=2,ncol=2)
p<-ConfMatrix$new(A,Source="Tung and LeDrew 1988")
p$CombProdAcc()


## ------------------------------------------------
## Method `ConfMatrix$CombUserProdAcc`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$CombUserProdAcc()


## ------------------------------------------------
## Method `ConfMatrix$AvUserProdAcc`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AvUserProdAcc()


## ------------------------------------------------
## Method `ConfMatrix$AvUserProdAcc_i`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AvUserProdAcc_i(2)


## ------------------------------------------------
## Method `ConfMatrix$UserKappa_i`
## ------------------------------------------------

A <- matrix(c(73,13,5,1,0,21,32,13,3,0,16,39,35,
29,13,3,5,7,28,48,1,0,2,3,17), nrow=5,ncol=5)
p <- ConfMatrix$new(A,Source="Næsset 1996")
p$UserKappa_i(2)


## ------------------------------------------------
## Method `ConfMatrix$ModKappaUser_i`
## ------------------------------------------------

A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Liu et al. 2007")
p$ModKappaUser_i(2)


## ------------------------------------------------
## Method `ConfMatrix$ProdKappa_i`
## ------------------------------------------------

A <- matrix(c(73,13,5,1,0,21,32,13,3,0,16,39,35,
29,13,3,5,7,28,48,1,0,2,3,17), nrow=5,ncol=5)
p <- ConfMatrix$new(A,Source="Næsset 1996")
p$ProdKappa_i(2)


## ------------------------------------------------
## Method `ConfMatrix$ModKappaProd_i`
## ------------------------------------------------

A<-matrix(c(317,61,2,35,23,120,4,29,0,0,60,0,0,0,0,8),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Foody 1992")
p$ModKappaProd_i(2)


## ------------------------------------------------
## Method `ConfMatrix$Kappa`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$Kappa()


## ------------------------------------------------
## Method `ConfMatrix$ModKappa`
## ------------------------------------------------

A <- matrix(c(317,61,2,35,23,120,4,29,0,0,60,0,0,0,0,8),
nrow=4,ncol=4)
p <- ConfMatrix$new(A,Source="Foody 1992")
p$ModKappa()


## ------------------------------------------------
## Method `ConfMatrix$EntUser_i`
## ------------------------------------------------

A<-matrix(c(35,4,12,2,14,11,9,5,11,3,38,12,1,0,4,2),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Finn 1993")
p$EntUser_i(1,v=2)


## ------------------------------------------------
## Method `ConfMatrix$NormEntUser`
## ------------------------------------------------

A<-matrix(c(35,4,12,2,14,11,9,5,11,3,38,12,1,0,4,2),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Finn 1993")
p$NormEntUser(v=2)


## ------------------------------------------------
## Method `ConfMatrix$EntProd_i`
## ------------------------------------------------

A<-matrix(c(35,4,12,2,14,11,9,5,11,3,38,12,1,0,4,2),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Finn 1993")
p$EntProd_i(3,v=2)


## ------------------------------------------------
## Method `ConfMatrix$NormEntProd`
## ------------------------------------------------

A<-matrix(c(35,4,12,2,14,11,9,5,11,3,38,12,1,0,4,2),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Finn 1993")
p$NormEntProd(v=2)


## ------------------------------------------------
## Method `ConfMatrix$Ent`
## ------------------------------------------------

A<-matrix(c(35,4,12,2,14,11,9,5,11,3,38,12,1,0,4,2),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Finn 1993")
p$Ent(v=2)


## ------------------------------------------------
## Method `ConfMatrix$AvNormEnt`
## ------------------------------------------------

A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Liu et al. 2007")
p$AvNormEnt(v=2)


## ------------------------------------------------
## Method `ConfMatrix$GeomAvNormEnt`
## ------------------------------------------------

A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Liu et al. 2007")
p$GeomAvNormEnt(v=2)


## ------------------------------------------------
## Method `ConfMatrix$AvMaxNormEnt`
## ------------------------------------------------

A<-matrix(c(8,0,0,0,0,16,0,0,0,0,8,0,0,0,0,16),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Liu et al. 2007")
p$AvMaxNormEnt(v=2)


## ------------------------------------------------
## Method `ConfMatrix$Sucess`
## ------------------------------------------------

A<-matrix(c(0.3,0.02,0.01,0.12,0.19,0.03,0.02,0.01,0.3),
nrow=3,ncol=3)
p<-ConfMatrix$new(A,Source="Labatut and Cherifi 2011")
p$Sucess()


## ------------------------------------------------
## Method `ConfMatrix$Sucess_i`
## ------------------------------------------------

A<-matrix(c(0.3,0.02,0.01,0.12,0.19,0.03,0.02,0.01,0.3),
nrow=3,ncol=3)
p<-ConfMatrix$new(A,Source="Labatut and Cherifi 2011")
p$Sucess_i(2)


## ------------------------------------------------
## Method `ConfMatrix$AvHellAcc`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AvHellAcc()


## ------------------------------------------------
## Method `ConfMatrix$AvHellAcc_i`
## ------------------------------------------------

A <- matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,39,
7,1,1,0,6,25,1,1,0,0,1,6), nrow=5,ncol=5)
p<-ConfMatrix$new(A,Source="Rosenfield and Fitzpatrick 1986")
p$AvHellAcc_i(2)


## ------------------------------------------------
## Method `ConfMatrix$AvShortAcc`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AvShortAcc()


## ------------------------------------------------
## Method `ConfMatrix$ShortAcc_i`
## ------------------------------------------------

A <- matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,
39,7,1,1,0,6,25,1,1,0,0,1,6), nrow=5,ncol=5)
p<-ConfMatrix$new(A,Source="Rosenfield and Fitzpatrick-Lins 1986")
p$ShortAcc_i(2)


## ------------------------------------------------
## Method `ConfMatrix$Tau`
## ------------------------------------------------

A<-matrix(c(238051,7,132,0,0,24,9,2,189,1,4086,188,0,4,16,45,1,0,939,5082,
51817,0,34,500,1867,325,17,0,0,5,11148,1618,78,0,0,0,0,48,4,834,2853,340,
32,0,197,5,151,119,135,726,6774,75,1,553,0,105,601,110,174,155,8257,8,0,
29,36,280,0,0,6,5,2993,0,115,2,0,4,124,595,0,0,4374),nrow=9,ncol=9)
p<-ConfMatrix$new(A,Source="Muñoz 2016")
p$Tau()


## ------------------------------------------------
## Method `ConfMatrix$GroundTruth`
## ------------------------------------------------

A<-matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,39,7,1,1,0,
6,25,1,1,0,0,1,6),nrow=5,ncol=5)
p<-ConfMatrix$new(A,Source="Türk 1979")
p$GroundTruth()


## ------------------------------------------------
## Method `ConfMatrix$GroundTruth_i`
## ------------------------------------------------

A<-matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,39,7,1,1,0,
6,25,1,1,0,0,1,6),nrow=5,ncol=5)
p<-ConfMatrix$new(A,Source="Türk 1979")
p$GroundTruth_i(3)


## ------------------------------------------------
## Method `ConfMatrix$UserProdAcc`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$UserProdAcc()


## ------------------------------------------------
## Method `ConfMatrix$DetailKappa`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$DetailKappa()


## ------------------------------------------------
## Method `ConfMatrix$DetailCondKappa`
## ------------------------------------------------

A<-matrix(c(0.2361,0.0694,0.1389,0.0556,0.1667,0.0417,0.1111,0,0.1806),
ncol=3,nrow=3)
p<-ConfMatrix$new(A,Source="Czaplewski 1994")
p$DetailCondKappa ()


## ------------------------------------------------
## Method `ConfMatrix$QES`
## ------------------------------------------------

A<-matrix(c(3,2,1,1,3,3,2,0,1),
nrow=3,ncol=3)
p<-ConfMatrix$new(A,Source="Pontius Jr. and Santacruz 2023")
p$QES()


## ------------------------------------------------
## Method `ConfMatrix$DetailWTau`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
WV <-matrix(c(0.4, 0.1, 0.4, 0.1), ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$DetailWTau(WV)


## ------------------------------------------------
## Method `ConfMatrix$DetailWKappa`
## ------------------------------------------------

A <- matrix(c(1,1,0,0,0,5,55,27,23,0,3,30,68,74,4,0,8,8,39,
26,0,0,2,4,26),nrow=5)
WM <- matrix(c(1,0.75,0.5,0.25,0,0.75,1,0.75,0.5,0.25,0.5,0.75,
1,0.75,0.5,0.25,0.5,0.75,1,0.75,0,0.25,0.5,0.75,1),nrow=5)
p<-ConfMatrix$new(A, Source="Næsset 1996")
p$DetailWKappa(WM)


## ------------------------------------------------
## Method `ConfMatrix$UserProdAcc_W`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
WM<- t(matrix(c(1,0,0.67,1,0,1,0,0,1,0,1,1,0.91,0,0.61,1),
nrow = 4, ncol=4))
p$UserProdAcc_W(WM)


## ------------------------------------------------
## Method `ConfMatrix$MTypify`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A, Source="Congalton and Green 2008")
p$MTypify(RaR=5)

## ------------------------------------------------
## Method `ConfMatrix$AllParameters`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AllParameters()


## ------------------------------------------------
## Method `ConfMatrix$MBootStrap`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A, Source="Congalton and Green 2008")
p$MBootStrap(2)


## ------------------------------------------------
## Method `ConfMatrix$MNormalize`
## ------------------------------------------------

A<-matrix(c(238051,7,132,0,0,24,9,2,189,1,4086,188,0,4,16,45,1,0,939,5082,
51817,0,34,500,1867,325,17,0,0,5,11148,1618,78,0,0,0,0,48,4,834,2853,340,
32,0,197,5,151,119,135,726,6774,75,1,553,0,105,601,110,174,155,8257,8,0,
29,36,280,0,0,6,5,2993,0,115,2,0,4,124,595,0,0,4374),nrow=9,ncol=9)
p<-ConfMatrix$new(A,Source="Muñoz 2016")
p$MNormalize()


## ------------------------------------------------
## Method `ConfMatrix$MPseudoZeroes`
## ------------------------------------------------

A<-matrix(c(238051,7,132,0,0,24,9,2,189,1,4086,188,0,4,16,45,1,0,939,5082,
51817,0,34,500,1867,325,17,0,0,5,11148,1618,78,0,0,0,0,48,4,834,2853,340,
32,0,197,5,151,119,135,726,6774,75,1,553,0,105,601,110,174,155,8257,8,0,
29,36,280,0,0,6,5,2993,0,115,2,0,4,124,595,0,0,4374),nrow=9,ncol=9)
p<-ConfMatrix$new(A,Source="Muñoz 2016")
p$MPseudoZeroes()


## ------------------------------------------------
## Method `ConfMatrix$StHell`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
r<-ConfMatrix$new(A,Source="Congalton and Green 2008")
B<-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),
nrow=4,ncol=4)
f<-ConfMatrix$new(B,Source="Congalton and Green 2008")
r$StHell(f)


## ------------------------------------------------
## Method `ConfMatrix$Kappa.test`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
B<-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),nrow=4,ncol=4)
f<-ConfMatrix$new(B,Source="Congalton and Green 2008")
p$Kappa.test(f)


## ------------------------------------------------
## Method `ConfMatrix$OverallAcc.test`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
B<-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),nrow=4,ncol=4)
f<-ConfMatrix$new(B,Source="Congalton and Green 2008")
p$OverallAcc.test(f)


## ------------------------------------------------
## Method `ConfMatrix$Tau.test`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
B<-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),
nrow=4,ncol=4)
f<-ConfMatrix$new(B,Source="Congalton and Green 2008")
p$Tau.test(f)


## ------------------------------------------------
## Method `ConfMatrix$TSCM.test`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
B<-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),
nrow=4,ncol=4)
f<-ConfMatrix$new(B,Source="Congalton and Green 2008")
p$TSCM.test(f)


## ------------------------------------------------
## Method `ConfMatrix$QIndep.test`
## ------------------------------------------------

A<-matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,39,
7,1,1,0,6,25,1,1,0,0,1,6),nrow=5,ncol=5)
p<-ConfMatrix$new(A,Source= "Türk 1979")
p$QIndep.test()


## ------------------------------------------------
## Method `ConfMatrix$plot.global`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$plot.global()


## ------------------------------------------------
## Method `ConfMatrix$plot.class`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$plot.class()


## ------------------------------------------------
## Method `ConfMatrix$print`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,ClassName=c("Deciduous","conifer",
"agriculture","shrub"),Source="Congalton and Green 2008")
p$print()

}
\references{
\insertRef{congalton2008}{ConfMatrix}

\insertRef{liu2007}{ConfMatrix}

\insertRef{koukoulas2001}{ConfMatrix}

\insertRef{turk2002}{ConfMatrix}

\insertRef{hellden1980}{ConfMatrix}

\insertRef{rosenfield1986}{ConfMatrix}

\insertRef{short1982}{ConfMatrix}

\insertRef{finn1993}{ConfMatrix}

\insertRef{tung1988}{ConfMatrix}

\insertRef{cohen1960}{ConfMatrix}

\insertRef{strehl2002}{ConfMatrix}

\insertRef{ghosh2002}{ConfMatrix}

\insertRef{strehl2002relationship}{ConfMatrix}

\insertRef{book}{ConfMatrix}

\insertRef{pontius2014}{ConfMatrix}

\insertRef{ariza2011}{ConfMatrix}

\insertRef{fienberg1970}{ConfMatrix}

\insertRef{munoz2016}{ConfMatrix}

\insertRef{foody1992}{ConfMatrix}

\insertRef{garcia2018}{ConfMatrix}

\insertRef{ma1995Tau}{ConfMatrix}

\insertRef{alba2020}{ConfMatrix}

\insertRef{turk1979gt}{ConfMatrix}

\insertRef{goodman1968analysis}{ConfMatrix}

\insertRef{diffeR}{ConfMatrix}

\insertRef{condkappa}{ConfMatrix}

\insertRef{labatut2011}{ConfMatrix}

\insertRef{naesset1996}{ConfMatrix}

\insertRef{fleiss1969}{ConfMatrix}
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{Values}}{\verb{
Matrix of integer values. An matrix must be added.
}}

\item{\code{ID}}{\verb{
Identifier. It is a character string with a maximum length of 50
characters. By default,} \eqn{CM_i} \verb{will be taken as identification.
Where} \eqn{i \in (1,999)} \verb{will be the number of ConfMatrix instances already defined.
}}

\item{\code{Date}}{\verb{
Date provided by the user in format DDMMYYYY, "DD-MM-YYYY", "DD/MM/YYYY".
By default the date provided by the system will be taken.

}}

\item{\code{ClassName}}{\verb{
Name of the classes. It is given by a character strings vector whose
elements are the name of the classes. Each element of the vector is
a string of maximum 20 characters. By default for the column elements
they will be} \eqn{Ref_{i}} \verb{and for the elements of row}
\eqn{C_{i}} \verb{, with} \eqn{i} \verb{being the
corresponding row or column number.
}}

\item{\code{Source}}{\verb{
Indicates where the matrix comes from (article, project, etc.).
It is suggested to enter a reference or a DOI. A character
string with a maximum length of 80 characters can be entered.
By default, is NULL.
}}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-ConfMatrix-new}{\code{ConfMatrix$new()}}
\item \href{#method-ConfMatrix-OverallAcc}{\code{ConfMatrix$OverallAcc()}}
\item \href{#method-ConfMatrix-UserAcc}{\code{ConfMatrix$UserAcc()}}
\item \href{#method-ConfMatrix-UserAcc_i}{\code{ConfMatrix$UserAcc_i()}}
\item \href{#method-ConfMatrix-AvUserAcc}{\code{ConfMatrix$AvUserAcc()}}
\item \href{#method-ConfMatrix-CombUserAcc}{\code{ConfMatrix$CombUserAcc()}}
\item \href{#method-ConfMatrix-ProdAcc}{\code{ConfMatrix$ProdAcc()}}
\item \href{#method-ConfMatrix-ProdAcc_i}{\code{ConfMatrix$ProdAcc_i()}}
\item \href{#method-ConfMatrix-AvProdAcc}{\code{ConfMatrix$AvProdAcc()}}
\item \href{#method-ConfMatrix-CombProdAcc}{\code{ConfMatrix$CombProdAcc()}}
\item \href{#method-ConfMatrix-CombUserProdAcc}{\code{ConfMatrix$CombUserProdAcc()}}
\item \href{#method-ConfMatrix-AvUserProdAcc}{\code{ConfMatrix$AvUserProdAcc()}}
\item \href{#method-ConfMatrix-AvUserProdAcc_i}{\code{ConfMatrix$AvUserProdAcc_i()}}
\item \href{#method-ConfMatrix-UserKappa_i}{\code{ConfMatrix$UserKappa_i()}}
\item \href{#method-ConfMatrix-ModKappaUser_i}{\code{ConfMatrix$ModKappaUser_i()}}
\item \href{#method-ConfMatrix-ProdKappa_i}{\code{ConfMatrix$ProdKappa_i()}}
\item \href{#method-ConfMatrix-ModKappaProd_i}{\code{ConfMatrix$ModKappaProd_i()}}
\item \href{#method-ConfMatrix-Kappa}{\code{ConfMatrix$Kappa()}}
\item \href{#method-ConfMatrix-ModKappa}{\code{ConfMatrix$ModKappa()}}
\item \href{#method-ConfMatrix-EntUser_i}{\code{ConfMatrix$EntUser_i()}}
\item \href{#method-ConfMatrix-NormEntUser}{\code{ConfMatrix$NormEntUser()}}
\item \href{#method-ConfMatrix-EntProd_i}{\code{ConfMatrix$EntProd_i()}}
\item \href{#method-ConfMatrix-NormEntProd}{\code{ConfMatrix$NormEntProd()}}
\item \href{#method-ConfMatrix-Ent}{\code{ConfMatrix$Ent()}}
\item \href{#method-ConfMatrix-AvNormEnt}{\code{ConfMatrix$AvNormEnt()}}
\item \href{#method-ConfMatrix-GeomAvNormEnt}{\code{ConfMatrix$GeomAvNormEnt()}}
\item \href{#method-ConfMatrix-AvMaxNormEnt}{\code{ConfMatrix$AvMaxNormEnt()}}
\item \href{#method-ConfMatrix-Sucess}{\code{ConfMatrix$Sucess()}}
\item \href{#method-ConfMatrix-Sucess_i}{\code{ConfMatrix$Sucess_i()}}
\item \href{#method-ConfMatrix-AvHellAcc}{\code{ConfMatrix$AvHellAcc()}}
\item \href{#method-ConfMatrix-AvHellAcc_i}{\code{ConfMatrix$AvHellAcc_i()}}
\item \href{#method-ConfMatrix-AvShortAcc}{\code{ConfMatrix$AvShortAcc()}}
\item \href{#method-ConfMatrix-ShortAcc_i}{\code{ConfMatrix$ShortAcc_i()}}
\item \href{#method-ConfMatrix-Tau}{\code{ConfMatrix$Tau()}}
\item \href{#method-ConfMatrix-GroundTruth}{\code{ConfMatrix$GroundTruth()}}
\item \href{#method-ConfMatrix-GroundTruth_i}{\code{ConfMatrix$GroundTruth_i()}}
\item \href{#method-ConfMatrix-UserProdAcc}{\code{ConfMatrix$UserProdAcc()}}
\item \href{#method-ConfMatrix-DetailKappa}{\code{ConfMatrix$DetailKappa()}}
\item \href{#method-ConfMatrix-DetailCondKappa}{\code{ConfMatrix$DetailCondKappa()}}
\item \href{#method-ConfMatrix-QES}{\code{ConfMatrix$QES()}}
\item \href{#method-ConfMatrix-DetailWTau}{\code{ConfMatrix$DetailWTau()}}
\item \href{#method-ConfMatrix-DetailWKappa}{\code{ConfMatrix$DetailWKappa()}}
\item \href{#method-ConfMatrix-UserProdAcc_W}{\code{ConfMatrix$UserProdAcc_W()}}
\item \href{#method-ConfMatrix-MTypify}{\code{ConfMatrix$MTypify()}}
\item \href{#method-ConfMatrix-AllParameters}{\code{ConfMatrix$AllParameters()}}
\item \href{#method-ConfMatrix-MBootStrap}{\code{ConfMatrix$MBootStrap()}}
\item \href{#method-ConfMatrix-MNormalize}{\code{ConfMatrix$MNormalize()}}
\item \href{#method-ConfMatrix-MPseudoZeroes}{\code{ConfMatrix$MPseudoZeroes()}}
\item \href{#method-ConfMatrix-StHell}{\code{ConfMatrix$StHell()}}
\item \href{#method-ConfMatrix-Kappa.test}{\code{ConfMatrix$Kappa.test()}}
\item \href{#method-ConfMatrix-OverallAcc.test}{\code{ConfMatrix$OverallAcc.test()}}
\item \href{#method-ConfMatrix-Tau.test}{\code{ConfMatrix$Tau.test()}}
\item \href{#method-ConfMatrix-TSCM.test}{\code{ConfMatrix$TSCM.test()}}
\item \href{#method-ConfMatrix-QIndep.test}{\code{ConfMatrix$QIndep.test()}}
\item \href{#method-ConfMatrix-plot.global}{\code{ConfMatrix$plot.global()}}
\item \href{#method-ConfMatrix-plot.class}{\code{ConfMatrix$plot.class()}}
\item \href{#method-ConfMatrix-print}{\code{ConfMatrix$print()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-new"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-new}{}}}
\subsection{Method \code{new()}}{
Public method to create an instance of the ConfMatrix class.
When creating it, values must be given to the matrix. The values
of the matrix must be organized in such a way that the columns
represent the classes in the reference and the rows represent
the classes in the product being evaluated. The creation of a
ConfMatrix instance includes a series of checks on the data. If
checks are not met, the system generates coded error messages.
The optional possibility of adding metadata to the matrix is offered.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$new(Values, ID = NULL, Date = NULL, ClassName = NULL, Source = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{Values}}{\verb{
Matrix of integer values. A matrix must be added.
}}

\item{\code{ID}}{\verb{
Identifier. It is a character string with a maximum length of 50
characters. By default,} \eqn{CM_i} \verb{will be taken as identification.
Where} \eqn{i \in (1,999)} \verb{will be the number of ConfMatrix instances already defined.
}}

\item{\code{Date}}{\verb{
Date provided by the user in format DDMMYYYY, "DD-MM-YYYY", "DD/MM/YYYY".
By default the date provided by the system will be taken.

}}

\item{\code{ClassName}}{\verb{
Name of the classes. It is given by a character strings vector whose
elements are the name of the classes. Each element of the vector is
a string of maximum 20 characters. By default for the column elements
they will be} \eqn{Ref_i} \verb{and for the elements of row} \eqn{C_i}\verb{, with} \eqn{i} \verb{being the
corresponding row or column number.
}}

\item{\code{Source}}{\verb{
Indicates where the matrix comes from (article, project, etc.).
It is suggested to enter a reference or a DOI. A character
string with a maximum length of 80 characters can be entered.
By default, is NULL.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Object of the ConfMatrix class, or an error message.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
cm<-ConfMatrix$new (A,ID="5",Date="27-10-2023",
Source="Congalton and Green, 2008")

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-OverallAcc"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-OverallAcc}{}}}
\subsection{Method \code{OverallAcc()}}{
Public method to calculate the global index called
Overall Accuracy. The Overall Accuracy is calculated by dividing
the sum of the entries that form the major diagonal (i.e., the
number of correct classifications) by the total number of cases.
The method also offers the variance and confidence interval.
The reference \insertCite{congalton2008}{ConfMatrix}
is followed for the computations.


The mathematical expression is:

\deqn{
OverallAcc = \dfrac{\sum_{i=1}^{M} x_{ii}}{\sum_{i, j=1}^{M} x_{ij}}
}

\deqn{
\sigma^2_{OverallAcc}=\dfrac{OverallAcc \cdot (1-OverallAcc)}{N_{OverallAcc}}
}
Where:
\enumerate{
  \item \eqn{OverallAcc}: overall accuracy.
  \item \eqn{x_{ii}}: diagonal element of the matrix.
  \item \eqn{x_{ij}}: element of the matrix.
  \item \eqn{N_{OverallAcc}}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$OverallAcc(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing the overall accuracy,
its variance, and its confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A)
p$OverallAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-UserAcc"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-UserAcc}{}}}
\subsection{Method \code{UserAcc()}}{
Public method for deriving the index called user’s
accuracy for all the classes in a ConfMatrix object instance.
The user's accuracy for the class i of a thematic product is
calculated by dividing the value in the diagonal of class i by
the sum of all values in the row of the class i (row marginal).
The method also offers the variance and confidence interval.
The reference \insertCite{congalton2008}{ConfMatrix} is followed
for the computations.


The mathematical expression is:
\deqn{
UserAcc=\dfrac{x_{ii}}{\sum_{j=1}^M x_{ij}}
}
 \deqn{
\sigma^2_{UserAcc}=\dfrac{UserAcc \cdot (1-UserAcc)}{N_{UserAcc}}
}
where:

\enumerate{
  \item \eqn{UserAcc}: user accuracy.
  \item \eqn{x_{ii}}: diagonal element of the matrix.
  \item \eqn{x_{ij}}: element of the matrix.
  \item \eqn{N_{UserAcc}}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$UserAcc(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of vectors, containing the user’s accuracy real values for
all classes, their variances and confidence intervals for each class,
respectively.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$UserAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-UserAcc_i"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-UserAcc_i}{}}}
\subsection{Method \code{UserAcc_i()}}{
Public method for deriving the index called
user’s accuracy for a specific class i in a ConfMatrix object
instance. The user’s accuracy for the class i of a thematic
product is calculated by dividing the value in the diagonal of
class i by the sum of all values in the row of the class i
(row marginal). The method also offers the variance and confidence
interval. The reference \insertCite{congalton2008}{ConfMatrix}
is followed for the computations.


\deqn{
UserAcc_{i}=\dfrac{x_{ii}}{\sum_{j=1}^M x_{ij}}
}
\deqn{
\sigma^2_{UserAcc_i}=\dfrac{UserAcc_i \cdot (1-UserAcc_i)}{N_{UserAcc_i}}
}


where:

\enumerate{
  \item \eqn{UserAcc_i}: user accuracy index for class i.
  \item \eqn{x_{ii}}: diagonal element of the matrix.
  \item \eqn{x_{ij}}: element of the matrix.
  \item \eqn{N_{UserAcc_i}}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$UserAcc_i(i, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{\verb{
Class to evaluate, where} \eqn{i \in \mathbb{Z}-\{0\}}.}

\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing the user’s accuracy
for class i, its variance, and its confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$UserAcc_i(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-AvUserAcc"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-AvUserAcc}{}}}
\subsection{Method \code{AvUserAcc()}}{
Public method that provides the arithmetic average,
without weighing, of all user’s accuracies of a ConfMatrix object
instance. The method also offers the variance and confidence
interval. The reference \insertCite{tung1988}{ConfMatrix} is
followed for the calculations.


\deqn{
AvUserAcc=\dfrac{1}{M} \sum^M_{i=1} \dfrac{x_{ii}}
{ x_{i+}}
}
\deqn{
\sigma^2_{AvUserAcc}=\dfrac{AvUserAcc \cdot (1-AvUserAcc)}{N_{AvUserAcc}}
}
where:

\enumerate{
  \item \eqn{AvUserAcc}: average accuracy from user's perspective.
  \item \eqn{x_{i+}}: sum of all elements in rows i.
  \item \eqn{x_{ii}}: diagonal element of the matrix.
  \item \eqn{M}: number of classes.
  \item \eqn{N_{AvUserAcc}}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$AvUserAcc(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing the average
user’s accuracy, its variance, and its confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(352,43,89,203),nrow=2,ncol=2)
p<-ConfMatrix$new(A,Source="Tung and LeDrew 1988")
p$AvUserAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-CombUserAcc"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-CombUserAcc}{}}}
\subsection{Method \code{CombUserAcc()}}{
Public method that provides the combined user accuracy
that is the average of the overall accuracy and the average user's
accuracy. The method also offers the
variance and confidence interval. The reference
\insertCite{tung1988}{ConfMatrix} is followed for the calculations.


\deqn{
CombUserAcc=\dfrac{OverallAcc+AvUserAcc}{2}
}
\deqn{
\sigma^2_{CombUserAcc}=\dfrac{CombUserAcc \cdot (1-CombUserAcc)}{N_{CombUserAcc}}
}

where:

\enumerate{
  \item \eqn{CombUserAcc}: combined accuracy from user's perspective.
  \item \eqn{OverallAcc}: overall accuracy.
  \item \eqn{AvUserAcc}: average accuracy from user's perspective.
  \item \eqn{N_{CombUserAcc}}: number of cases involved in the calculation of
  the index.
  }
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$CombUserAcc(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing the combined
accuracy from the user's perspective,
its variation and confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(352,43,89,203),nrow=2,ncol=2)
p<-ConfMatrix$new(A,Source="Tung and LeDrew 1988")
p$CombUserAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-ProdAcc"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-ProdAcc}{}}}
\subsection{Method \code{ProdAcc()}}{
Public method for deriving the index called
producer’s accuracy for all the classes in a ConfMatrix
object instance. The producer’s accuracy for the class i
of a thematic product is calculated by dividing the value
in the diagonal of class i by the sum of all values in the
row of the class i (column marginal). The method also
offers the variance and confidence interval. The reference
\insertCite{congalton2008}{ConfMatrix} if followed for the
computations.


\deqn{
ProdAcc=\dfrac{x_{ii}}{\sum_{j=1}^M x_{ij}}
}
\deqn{
\sigma^2_{ProdAcc}=\dfrac{ProdAcc \cdot (1-ProdAcc)}{N_{ProdAcc}}
}
where:

\enumerate{
  \item \eqn{ProdAcc}: producer accuracy.
  \item \eqn{x_{ii}}: diagonal element of the matrix.
  \item \eqn{x_{ij}}: element of the matrix.
  \item \eqn{N_{ProdAcc}}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$ProdAcc(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of vectors each one containing the producer’s
accuracy real values for all classes, their variances and
confidence intervals for each class, respectively.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$ProdAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-ProdAcc_i"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-ProdAcc_i}{}}}
\subsection{Method \code{ProdAcc_i()}}{
Public method for deriving the index called
producer’s accuracy for a specific class i in a ConfMatrix
object instance. The user’s accuracy for the class i of a
thematic product is calculated by dividing the value in the
diagonal of class i by the sum of all values in the column
of the class i (column marginal). The method also offers
the variance and confidence interval. The reference
\insertCite{congalton2008}{ConfMatrix} is followed for the
calculations.


\deqn{
ProdAcc_{i}=\dfrac{x_{jj}}{\sum_{j=1}^M x_{ij}}
}
\deqn{
\sigma^2_{ProdAcc_i}=\dfrac{ProdAcc_i \cdot (1-ProdAcc_i)}{N_{ProdAcc_i}}
}

where:

\enumerate{
  \item \eqn{ProdAcc_i}: producer accuracy index for class i.
  \item \eqn{x_{jj}}: diagonal element of the matrix.
  \item \eqn{x_{ij}}: element of the matrix.
  \item \eqn{N_{ProdAcc_i}}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$ProdAcc_i(i, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{\verb{
Producer class to evaluate, where} \eqn{i \in \mathbb{Z}-\{0\}.
}}

\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing the producer’s
accuracy for class i, its variance, and its confidence
interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$ProdAcc_i(1)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-AvProdAcc"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-AvProdAcc}{}}}
\subsection{Method \code{AvProdAcc()}}{
Public method that provides the arithmetic
average of all producer’s accuracies of a ConfMatrix object
instance. The method also offers the variance and confidence
interval. The reference \insertCite{tung1988}{ConfMatrix}
is followed for the calculations.


\deqn{
AvProdAcc=\dfrac{1}{M} \sum^M_{i=1} \dfrac{x_{ii}}
{ x_{+j}}
}
\deqn{
\sigma^2_{AvProdAcc}=\dfrac{AvProdAcc \cdot (1-AvProdAcc)}{N_{AvProdAcc}}
}
where:

\enumerate{
  \item \eqn{AvProdAcc}: average accuracy from producer's perspective.
  \item \eqn{x_{+j}}: sum of all elements in column j.
  \item \eqn{x_{ii}}: diagonal element of the matrix.
  \item \eqn{M}: number of classes.
  \item \eqn{N_{AvProdAcc}}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$AvProdAcc(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing the average producer’s
accuracy, its variance, and its confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(352,43,89,203),nrow=2,ncol=2)
p<-ConfMatrix$new(A,Source="Tung and LeDrew 1988")
p$AvProdAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-CombProdAcc"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-CombProdAcc}{}}}
\subsection{Method \code{CombProdAcc()}}{
Public method that provides the combined producer's
accuracy that is the average of the overall accuracy and the average
producer accuracy. The method also offers the
variance and confidence interval. The reference
\insertCite{tung1988}{ConfMatrix} is followed for the calculations.


\deqn{
CombProdAcc=\dfrac{OverallAcc+AvProdAcc}{2}
}
\deqn{
\sigma^2_{CombProdAcc}=\dfrac{CombProdAcc \cdot (1-CombProdAcc)}{N_{CombProdAcc}}
}
where:

\enumerate{
  \item \eqn{CombProdAcc}: combined accuracy from producer's
  perspective.
  \item \eqn{OverallAcc}: overall accuracy.
  \item \eqn{AvProdAcc}: average accuracy from producer's perspective.
  \item \eqn{N_{CombProdAcc}}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$CombProdAcc(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing the combined accuracy
from producer's perspective, its variance and confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(352,43,89,203),nrow=2,ncol=2)
p<-ConfMatrix$new(A,Source="Tung and LeDrew 1988")
p$CombProdAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-CombUserProdAcc"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-CombUserProdAcc}{}}}
\subsection{Method \code{CombUserProdAcc()}}{
Public method that provides the combined accuracy
which is the average of the overall accuracy and the Hellden's
average accuracy, which refers to the average user's and producer's
accuracies. The method also offers the
variance and confidence interval. The reference
\insertCite{liu2007}{ConfMatrix} is followed for the calculations.


\deqn{
CombUserProdAcc=\dfrac{OverallAcc+AvHellAcc}{2}
}
 \deqn{
\sigma^2_{CombUserProdAcc}=\dfrac{CombUserProdAcc \cdot
(1-CombUserProdAcc)}{N_{CombUserProdAcc}}
}
where:

\enumerate{
  \item \eqn{CombUserProdAcc}: combined accuracy from both user's
  and producer's perspectives.
  \item \eqn{OverallAcc}: overall accuracy.
  \item \eqn{AvHellAcc}: average of Hellden's mean accuracy index.
  \item \eqn{N_{CombUserProdAcc}}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$CombUserProdAcc(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing the combined accuracy from both user's
and producer's perspectives, its variance and confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$CombUserProdAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-AvUserProdAcc"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-AvUserProdAcc}{}}}
\subsection{Method \code{AvUserProdAcc()}}{
Public method that provides the arithmetic
average of all user’s and producer’s accuracy indexes of
a ConfMatrix object instance. The method also offers the
variance and confidence interval. The reference
\insertCite{liu2007}{ConfMatrix} is followed for the
calculations.


\deqn{
AvUserProdAcc=\dfrac{AvUserAcc+AvProdAcc}{2}
}
 \deqn{
\sigma^2_{AvUserProdAcc}=\dfrac{AvUserProdAcc \cdot (1-AvUserProdAcc)}{N_{AvUserProdAcc}}
}

where:

\enumerate{
  \item \eqn{AvUserProdAcc}: average of average of user's and
  producer's perspective.
  \item \eqn{AvUserAcc}: average accuracy from user's perspective.
  \item \eqn{AvProdAcc}: average accuracy from producer's perspective.
  \item \eqn{N_{AvUserProdAcc}}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$AvUserProdAcc(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing the average mean
precision values from the user's and producer's perspective,
their variance and confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AvUserProdAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-AvUserProdAcc_i"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-AvUserProdAcc_i}{}}}
\subsection{Method \code{AvUserProdAcc_i()}}{
Public method that provides the average of
user’s and producer’s accuracies for a specific class i
The method also offers the variance and confidence
interval. The reference \insertCite{liu2007}{ConfMatrix}
is followed for the calculations.


The mathematical expression is:
 \deqn{
AvUserProdAcc_i=\dfrac{UserAcc_i+ProdAcc_i}{2}
}
\deqn{
\sigma^2_{AvUserProdAcc_i}=\dfrac{AvUserProdAcc_i
\cdot (1-AvUserProdAcc_i)}{N_{AvUserProdAcc_i}}
}
where:

\enumerate{
  \item \eqn{AvUserProdAcc_i}: average of user's and producer's
  accuracies.
  \item \eqn{UserAcc_i}: user accuracy index for class i.
  \item \eqn{ProdAcc_i}: producer accuracy index for class i.
  \item \eqn{N_{AvUserProdAcc_i}}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$AvUserProdAcc_i(i, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{\verb{
Class to evaluate, where} \eqn{i \in \mathbb{Z}-\{0\}}.}

\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing the average of
user’s and producer’s accuracies, its variance and
confidence interval for class i.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AvUserProdAcc_i(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-UserKappa_i"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-UserKappa_i}{}}}
\subsection{Method \code{UserKappa_i()}}{
Public method that evaluates the kappa coefficient
from the user's perspective, for a specific class i. The method
also offers the variance and confidence interval. The reference
\insertCite{rosenfield1986}{ConfMatrix} is followed
for the calculations.


\deqn{
UserKappa_i=\dfrac{UserAcc_i-\dfrac{ x_{i + }}
{\sum^M_{i,j=1} x_{ij}}}{1-\dfrac{ x_{i + }}
{\sum^M_{i,j=1} x_{ij}}}
}
 \deqn{
\sigma^2_{UserKappa_i}=\dfrac{UserAcc_i \cdot (1-UserAcc_i)}
{ \left(1-\dfrac{ x_{i + }}
{\sum^M_{i,j=1} x_{ij}}\right)^2 \cdot N_{UserKappa_i}}
}
where:

\enumerate{
  \item \eqn{UserKappa_i}: coefficient kappa (user's).
  \item \eqn{UserAcc_i}: user accuracy index for class i.
  \item \eqn{x_{i+}}: sum of all elements in rows i.
  \item \eqn{N_{UserKappa_i}}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$UserKappa_i(i, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{\verb{
Class to evaluate, where} \eqn{i \in \mathbb{Z}-\{0\}}.}

\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing the kappa coefficient
(user’s), its variance and its confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A <- matrix(c(73,13,5,1,0,21,32,13,3,0,16,39,35,
29,13,3,5,7,28,48,1,0,2,3,17), nrow=5,ncol=5)
p <- ConfMatrix$new(A,Source="Næsset 1996")
p$UserKappa_i(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-ModKappaUser_i"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-ModKappaUser_i}{}}}
\subsection{Method \code{ModKappaUser_i()}}{
Public method, derived from the general modified
kappa coefficient, which provides the modified coefficient kappa
for the user and for a specific class i. Equitable probabilities
of belonging to each class are assumed. The method also offers
the variance and confidence interval. The references
\insertCite{stehman1997,foody1992}{ConfMatrix} are followed
for the calculations.


\deqn{
ModKappaUser_i=\dfrac{UserAcc_i-\dfrac{1}{M}}
{1-\dfrac{1}{M}}
}
\deqn{
\sigma^2_{ModKappaUser_i}=\dfrac{UserAcc_i
\cdot (1- UserAcc_i)}{ \left(1- \dfrac{1}{M} \right)^2 \cdot N_{ModKappaUser_i}}
}
where:

\enumerate{
  \item \eqn{ModKappaUser_i}: modified coefficient kappa (user's).
  \item \eqn{UserAcc_i}: user accuracy index for class i.
  \item \eqn{M}: number of classes.
  \item \eqn{N_{ModKappaUser_i}}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$ModKappaUser_i(i, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{\verb{
Class to evaluate, where} \eqn{i \in \mathbb{Z}-\{0\}}.}

\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing the modified
coefficient kappa (user's), its variance and
confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Liu et al. 2007")
p$ModKappaUser_i(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-ProdKappa_i"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-ProdKappa_i}{}}}
\subsection{Method \code{ProdKappa_i()}}{
Public method that evaluates the kappa coefficient from
the producer's perspective, for a specific class i. The method
also offers the variance and confidence interval. The reference
\insertCite{rosenfield1986}{ConfMatrix} is followed
for the calculations.


\deqn{
ProdKappa_i=\dfrac{ProdAcc_i-\dfrac{ x_{ + i }}
{\sum^M_{i,j=1} x_{ij}}}{1-\dfrac{ x_{+ i }}
{\sum^M_{i,j=1} x_{ij}}}
}
 \deqn{
\sigma^2_{ProdKappa_i}=\dfrac{ProdAcc_i \cdot (1- ProdAcc_i)}
{\left(1-\dfrac{ x_{+ i }}
{\sum^M_{i,j=1} x_{ij}} \right)^2 \cdot N_{ProdAcc_i}}
}
where:

\enumerate{
  \item \eqn{ProdKappa_i}: coefficient kappa (producer's).
  \item \eqn{ProdAcc_i}: producer accuracy index for class i.
  \item \eqn{x_{+i}}: sum of all elements in column i.
  \item \eqn{N_{ProdAcc_i}}: number of cases involved in the calculation of the
  index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$ProdKappa_i(i, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{\verb{
Class to evaluate, where} \eqn{i \in \mathbb{Z}-\{0\}}.}

\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing the coefficient kappa
(producer’s), its variance and its confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A <- matrix(c(73,13,5,1,0,21,32,13,3,0,16,39,35,
29,13,3,5,7,28,48,1,0,2,3,17), nrow=5,ncol=5)
p <- ConfMatrix$new(A,Source="Næsset 1996")
p$ProdKappa_i(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-ModKappaProd_i"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-ModKappaProd_i}{}}}
\subsection{Method \code{ModKappaProd_i()}}{
Public method, derived from the general modified
kappa coefficient, which provides the modified coefficient kappa
for the producer and for a specific class i. Equitable probabilities
of belonging to each class are assumed. The method also
offers the variance and confidence interval. The references
\insertCite{stehman1997,foody1992}{ConfMatrix} are
followed for the calculations.


\deqn{
ModKappaProd_i=\dfrac{ProdAcc_i-\dfrac{1}{M}}
{1-\dfrac{1}{M}}
}
\deqn{
\sigma^2_{ModKappaProd_i}=\dfrac{ProdAcc_i
\cdot (1- ProdAcc_i)}{ \left( 1-\dfrac{1}{M} \right)^2 \cdot N_{ModKappaProd_i}}
}
where:

\enumerate{
  \item \eqn{ModKappaProd_i}: modified coefficient kappa (producer's).
  \item \eqn{ProdAcc_i}: producer accuracy index for class i.
  \item \eqn{M}: number of classes.
  \item \eqn{N_{ModKappaProd_i}}: number of cases involved in the calculation
  of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$ModKappaProd_i(i, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{\verb{
Class to evaluate, where} \eqn{i \in \mathbb{Z}-\{0\}}.}

\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing the modified coefficient
kappa (producer's), its variance and confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(317,61,2,35,23,120,4,29,0,0,60,0,0,0,0,8),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Foody 1992")
p$ModKappaProd_i(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-Kappa"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-Kappa}{}}}
\subsection{Method \code{Kappa()}}{
Public method that provides kappa coefficient,
which measures the relationship between agreement beyond chance
and expected disagreement. The method also offers the
variance and confidence interval.
The reference \insertCite{cohen1960}{ConfMatrix} is followed
for the calculations.


\deqn{
Kappa=\dfrac{OverallAcc-ExpAcc}{1-ExpAcc}
}
\deqn{
ExpAcc= \dfrac{x_{+ i}x_{i +}}{ ( \sum_{i,j=1}^M x_{ij} )^{2} }
}
\deqn{
\sigma^2_{Kappa}=\dfrac{OverallAcc-ExpAcc}{(1-ExpAcc)^2 \cdot N_{Kappa}}
}



where:

\enumerate{
  \item \eqn{Kappa}: Kappa coefficient.
  \item \eqn{OverallAcc}: overall accuracy.
  \item \eqn{ExpAcc}: expected accuracy of agreement if agreement
  were purely random.
  \item \eqn{x_{+i}}: sum of all elements in column i.
  \item \eqn{x_{i+}}: sum of all elements in row i.
  \item \eqn{N_{Kappa}}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$Kappa(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing with kappa
coefficient, its variance and confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$Kappa()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-ModKappa"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-ModKappa}{}}}
\subsection{Method \code{ModKappa()}}{
Public method that provides the overall modified
kappa coefficient. The method also offers the
variance and confidence interval. The references
\insertCite{stehman1997,foody1992}{ConfMatrix} are followed for
the calculations.


\deqn{
ModKappa=\dfrac{OverallAcc-\dfrac{1}{M}}{1-\dfrac{1}{M}}
}
\deqn{
\sigma^2_{ModKappa}=\dfrac{OverallAcc \cdot (1- OverallAcc)}
{ \left(1-\dfrac{1}{M} \right)^2 \cdot N_{ModKappa}}
}
where:

\enumerate{
  \item \eqn{ModKappa}: modified coefficient kappa.
  \item \eqn{OverallAcc}: overall accuracy.
  \item \eqn{M}: number of classes.
  \item \eqn{N_{ModKappa}}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$ModKappa(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing modified coefficient
kappa, its variance and its confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A <- matrix(c(317,61,2,35,23,120,4,29,0,0,60,0,0,0,0,8),
nrow=4,ncol=4)
p <- ConfMatrix$new(A,Source="Foody 1992")
p$ModKappa()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-EntUser_i"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-EntUser_i}{}}}
\subsection{Method \code{EntUser_i()}}{
Public method that calculates relative change of
entropy for a given class i of the product. The method also
offers the variance and confidence interval.
The reference \insertCite{finn1993}{ConfMatrix} is followed for
the calculations.


\deqn{
EntUser_i= \dfrac{Ent_i(A)-Ent_i(A|b_i)}{Ent_i(A)}
}
 \deqn{
Ent_i(A)=-\sum^M_{j=1} \left( \left(\dfrac{ x_{+j}}
{\sum^M_{i,j=1} x_{ij} }\right) \cdot \log \left(\dfrac{ x_{+j}}
{\sum^M_{i,j=1} x_{ij} }\right) \right)
}
\deqn{
Ent_i(A|b_i)=-\sum^M_{j=1} \left( \left(\dfrac{ x_{ij}}
{ x_{i+} }\right) \cdot \log \left(\dfrac{x_{ij}}
{ x_{i+}}\right) \right)
}
\deqn{
\sigma^2_{EntUser_i}= \dfrac{EntUser_i \cdot (1-EntUser_i)}{N_{EntUser_i}}
}

where:

\enumerate{
  \item \eqn{EntUser_i}: relative change of entropy given a
  class on the product.
  \item \eqn{Ent_i(A)}: entropy of the class \emph{i} of
  the product with respect to the class \emph{i} of the product. A is a matrix.
  \item \eqn{x_{i+}}: sum of all elements in rows i.
  \item \eqn{x_{+j}}: sum of all elements in column j.
  \item \eqn{Ent_i(A|b_i)}: Producer entropy knowing that the
  location corresponding to the reference map B is in class \eqn{b_i}.
  B is a matrix.
  \item \eqn{N_{EntUser_i}}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$EntUser_i(i, a = NULL, v = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{\verb{
Class to evaluate, where} \eqn{i \in \mathbb{Z}-\{0\}}.}

\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}

\item{\code{v}}{\verb{
Base of the logarithm, where} \eqn{v \in \mathbb{R}^{+}-\{1\}}. \verb{ By default v=10.
This value is used for the entropy units, v=10(units Hartleys), v=2(units bits),
v=e(units nats).
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing the relative change of entropy
for given class i, its variance, its confidence interval, producer
entropy, and producer entropy knowing that the
location corresponding to the reference map B is in class \eqn{b_i}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(35,4,12,2,14,11,9,5,11,3,38,12,1,0,4,2),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Finn 1993")
p$EntUser_i(1,v=2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-NormEntUser"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-NormEntUser}{}}}
\subsection{Method \code{NormEntUser()}}{
Public method that calculates normalized entropy
of the product. The method also offers the variance and
confidence interval. The reference
\insertCite{finn1993}{ConfMatrix} is followed for the calculations.


\deqn{
NormEntUser=\dfrac{Ent}{Ent_i(B)}
}
\deqn{
Ent_i(B)=-\sum^M_{i=1} \left( \left(  \dfrac {x_{i+}}
{\sum^M_{i,j=1} x_{ij} }\right) \cdot \log \left( \dfrac{ x_{i+}}
{\sum^M_{i,j=1} x_{ij} }\right) \right)
}
\deqn{
\sigma^2_{NormEntUser}=\dfrac{NormEntUser \cdot (1-NormEntUser)}{N_{NormEntUser}}
}
where:

\enumerate{
  \item \eqn{NormEntUser}: normalized entropy of the product.
  \item \eqn{Ent}: product entropy.
  \item \eqn{Ent_i(B)}: entropy of class \emph{i} of the
  reference with respect to the class on the reference. B is a matrix.
  \item \eqn{x_{i+}}: sum of all elements in row i.
  \item \eqn{N_{NormEntUser}}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$NormEntUser(a = NULL, v = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}

\item{\code{v}}{\verb{
Base of the logarithm, where} \eqn{v \in \mathbb{R}^{+}-\{1\}}.
\verb{By default v=10. This value is used
for the entropy units, v=10(units Hartleys), v=2(units bits),
v=e(units nats).}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing with normalized entropy
of the product class i, conditioned to reference data, its variance
and confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(35,4,12,2,14,11,9,5,11,3,38,12,1,0,4,2),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Finn 1993")
p$NormEntUser(v=2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-EntProd_i"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-EntProd_i}{}}}
\subsection{Method \code{EntProd_i()}}{
Public method that calculates relative change of
entropy for a given a class i of the reference. The method also offers the
variance and confidence interval. The reference
\insertCite{stehman1997}{ConfMatrix} is followed for
the calculations.


\deqn{
EntProd_i= \dfrac{Ent_i(B)-Ent_i(B|a_j)}{Ent_i(B)}
}

 \deqn{
Ent_i(B)=-\sum^M_{i=1} \left( \left(\dfrac{ x_{i+}}
{\sum^M_{i,j=1} x_{ij} }\right) \cdot \log \left(\dfrac{ x_{i+}}
{\sum^M_{i,j=1} x_{ij} }\right) \right)
}
\deqn{
Ent_i(B|a_j)=-\sum^M_{i=1}\left( \left(\dfrac{ x_{ij}}
{ x_{+j} }\right) \cdot \log \left(\dfrac{x_{ij}}
{ x_{+j}}\right) \right)
}
\deqn{
\sigma^2_{EntProd_i}= \dfrac{EntProd_i \cdot (1-EntProd_i)}{N_{EntProd_i}}
}
where:

\enumerate{
  \item \eqn{EntProd_i}: relative entropy change given a class over
   the reference data.
  \item \eqn{Ent_i(B)}: entropy of class \emph{i} of the
  reference with respect to the class on the reference. B is a matrix.
  \item \eqn{x_{i+}}: sum of all elements in rows i.
  \item \eqn{Ent_i(B|a_j)}: Entropy of reference map B knowing that
  the location corresponding map of product A is in class \eqn{a_j}.
  \item \eqn{N_{EntProd_i}}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$EntProd_i(i, a = NULL, v = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{\verb{
Class to evaluate, where} \eqn{i \in \mathbb{Z}-\{0\}}.}

\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}

\item{\code{v}}{\verb{
Base of the logarithm, where} \eqn{v \in \mathbb{R}^{+}-\{1\}}. \verb{ By default
v=10. This value is used
for the entropy units, v=10(units Hartleys), v=2(units bits),
v=e(units nats).
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing the relative change of entropy
for given class i, its variance, its confidence interval, entropy with
respect to reference classes, and entropy with respect to reference
classes knowing that the location corresponding to map A is in class \eqn{a_j}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(35,4,12,2,14,11,9,5,11,3,38,12,1,0,4,2),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Finn 1993")
p$EntProd_i(3,v=2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-NormEntProd"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-NormEntProd}{}}}
\subsection{Method \code{NormEntProd()}}{
Public method that calculates normalized entropy of
the reference. The method also offers the variance and confidence
interval. The reference \insertCite{finn1993}{ConfMatrix} is
followed for the calculations.


\deqn{
NormEntProd=\dfrac{Ent}{Ent_i(A)}
}
 \deqn{
Ent_i(A)=-\sum^M_{j=1}\left( \left(\dfrac{ x_{+j}}
{\sum^M_{i,j=1} x_{ij} }\right) \cdot \log \left( \dfrac{x_{+j}}
{\sum^M_{i,j=1} x_{ij} }\right) \right)
}
\deqn{
\sigma^2_{NormEntProd}=\dfrac{NormEntProd \cdot (1-NormEntProd)}{N_{NormEntProd}}
}
where:

\enumerate{
  \item \eqn{NormEntProd}: normalized mutual information using
  the entropy on the reference.
  \item \eqn{Ent}: product entropy.
  \item \eqn{Ent_i(A)}: entropy of the class \emph{i} of
  the product with respect to the class \emph{i} of the product. A is a matrix.
  \item \eqn{x_{+j}}: sum of all elements in column j.
  \item \eqn{N_{NormEntProd}}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$NormEntProd(a = NULL, v = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}

\item{\code{v}}{\verb{
Base of the logarithm, where} \eqn{v \in \mathbb{R}^{+}-\{1\}}.
\verb{By default v=10. This value is used
for the entropy units, v=10(units Hartleys), v=2(units bits),
v=e(units nats).}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing with normalized entropy
of the reference class i, conditioned to producer, its variance
and confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(35,4,12,2,14,11,9,5,11,3,38,12,1,0,4,2),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Finn 1993")
p$NormEntProd(v=2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-Ent"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-Ent}{}}}
\subsection{Method \code{Ent()}}{
Public method for calculating product entropy,which
refers to the lack of orden and predictability that the product
presents. The method also offers the variance and confidence
interval. The reference \insertCite{finn1993}{ConfMatrix} is
followed for the calculations.


\deqn{
Ent=\sum^M_{i,j=1} \left(\dfrac{x_{ij}}{\sum^M_{i,j=1} x_{ij}}
 \cdot \log \left(\dfrac{x_{ij}}{\dfrac{ x_{i+}
 \cdot  x_{+j}}{\sum^M_{i,j=1} x_{ij}}} \right) \right)
}
\deqn{
\sigma^2_{Ent}=\dfrac{Ent \cdot (1-Ent)}{N_{Ent}}
}
where:

\enumerate{
  \item \eqn{Ent}: product entropy.
  \item \eqn{x_{+j}}: sum of all elements in column j.
  \item \eqn{x_{i+}}: sum of all elements in row i.
  \item \eqn{N_{Ent}}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$Ent(a = NULL, v = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}

\item{\code{v}}{\verb{
Base of the logarithm, where} \eqn{v \in \mathbb{R}^{+}-\{1\}}.
\verb{By default v=10. This value is used
for the entropy units, v=10(units Hartleys), v=2(units bits),
v=e(units nats).}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing the entropy, its variance
and confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(35,4,12,2,14,11,9,5,11,3,38,12,1,0,4,2),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Finn 1993")
p$Ent(v=2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-AvNormEnt"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-AvNormEnt}{}}}
\subsection{Method \code{AvNormEnt()}}{
Public method that calculates normalized entropy using
the arithmetic mean of the entropies on the product and the
reference. The method also offers the variance and confidence interval. The reference
\insertCite{strehl2002}{ConfMatrix} is followed for the calculations.


\deqn{
AvNormEnt=\dfrac{2Ent}{Ent_i(A)+Ent_i(B)}
}
 \deqn{
Ent_i(A)=-\sum^M_{j=1} \left( \left(\dfrac{ x_{+j}}
{\sum^M_{i,j=1} x_{ij} }\right) \cdot \log \left(\dfrac{ x_{+j}}
{\sum^M_{i,j=1} x_{ij} }\right) \right)
}
\deqn{
Ent_i(B)=-\sum^M_{i=1}\left( \left(\dfrac{ x_{i+}}
{\sum^M_{i,j=1} x_{ij} }\right) \cdot \log \left(\dfrac{x_{i+}}
{\sum^M_{i,j=1} x_{ij} }\right) \right)
}
\deqn{
\sigma^2_{AvNormEnt}=\dfrac{AvNormEnt \cdot (1-AvNormEnt)}{N_{AvNormEnt}}
}

where:

\enumerate{
  \item \eqn{AvNormEnt}: normalized entropy using the
  arithmetic mean of the entropies of product and reference.
  \item \eqn{Ent}: product entropy.
  \item \eqn{Ent_i(A)}: entropy of the class \emph{i} of
  the product with respect to the class \emph{i} of the product. A is a matrix.
  \item \eqn{Ent_i(B)}: entropy of class \emph{i} of the
  reference with respect to the class on the reference. B is a matrix.
  \item \eqn{x_{+j}}: sum of all elements in column j.
  \item \eqn{x_{i+}}: sum of all elements in row i.
  \item \eqn{N_{AvNormEnt}}: number of cases involved in the calculation of the
  index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$AvNormEnt(a = NULL, v = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}

\item{\code{v}}{\verb{
Base of the logarithm, where} \eqn{v \in \mathbb{R}^{+}-\{1\}}.
\verb{By default v=10. This value is used
for the entropy units, v=10(units Hartleys), v=2(units bits),
v=e(units nats).}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing the normalized
entropy (arithmetic mean of the entropies on the product
and reference), its variance and confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Liu et al. 2007")
p$AvNormEnt(v=2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-GeomAvNormEnt"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-GeomAvNormEnt}{}}}
\subsection{Method \code{GeomAvNormEnt()}}{
Public method that calculates the normalized entropy
using the geometric mean of the product and reference entropies.
The method also offers the variance and confidence interval.
The reference \insertCite{ghosh2002}{ConfMatrix} is followed
for the calculations.


\deqn{
GeomAvNormEnt=\dfrac{Ent}{\sqrt{Ent_i(A) \cdot Ent_i(B)}}
}
 \deqn{
Ent_i(A)=-\sum^M_{j=1} \left( \left(\dfrac{ x_{+j}}
{\sum^M_{i,j=1} x_{ij} }\right) \cdot \log \left(\dfrac{ x_{+j}}
{\sum^M_{i,j=1} x_{ij} }\right) \right)
}
\deqn{
Ent_i(B)=-\sum^M_{i=1}\left( \left(\dfrac{ x_{i+}}
{\sum^M_{i,j=1} x_{ij} }\right) \cdot \log \left(\dfrac{ x_{i+}}
{\sum^M_{i,j=1} x_{ij} }\right) \right)
}
\deqn{
\sigma^2_{GeomAvNormEnt}=
\dfrac{GeomAvNormEnt \cdot (1-GeomAvNormEnt)}{N_{GeomAvNormEnt}}
}
where:

\enumerate{
  \item \eqn{GeomAvNormEnt}: normalized entropy using the
  geometric mean of the entropies on the product and reference.
  \item \eqn{Ent}: product entropy.
  \item \eqn{Ent_i(A)}: entropy of the class \emph{i} of
  the product with respect to the class \emph{i} of the product. A is a matrix.
  \item \eqn{Ent_i(B)}: entropy of class \emph{i} of the
  reference with respect to the class on the reference. B is a matrix.
  \item \eqn{x_{+j}}: sum of all elements in column j.
  \item \eqn{x_{i+}}: sum of all elements in row i.
  \item \eqn{N_{GeomAvNormEnt}}: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$GeomAvNormEnt(a = NULL, v = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}

\item{\code{v}}{\verb{
Base of the logarithm, where} \eqn{v \in \mathbb{R}^{+}-\{1\}}.
\verb{By default v=10. This value is used
for the entropy units, v=10(units Hartleys), v=2(units bits),
v=e(units nats).}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing the normalized
entropy (geometric mean of the entropies on the product
and reference), its variance and confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Liu et al. 2007")
p$GeomAvNormEnt(v=2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-AvMaxNormEnt"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-AvMaxNormEnt}{}}}
\subsection{Method \code{AvMaxNormEnt()}}{
Public method that provides normalized entropy using
the arithmetic mean of the maximum entropies of the product and
reference. The method also offers the variance and confidence interval.
The reference \insertCite{strehl2002relationship}{ConfMatrix} is
followed for the calculations.


\deqn{
AvMaxNormEnt=\dfrac{2 Ent}{max(Ent_i(A))+max(Ent_i(B))}=
\dfrac{Ent}{\log M}
}
 \deqn{
Ent_i(A)=-\sum^M_{j=1} \left( \left(\dfrac{ x_{+j}}
{\sum^M_{i,j=1} x_{ij} }\right) \cdot \log \left(\dfrac{ x_{+j}}
{\sum^M_{i,j=1} x_{ij} }\right) \right)
}
\deqn{
Ent_i(B)=-\sum^M_{i=1}\left( \left(\dfrac{ x_{i+}}
{\sum^M_{i,j=1} x_{ij} }\right) \cdot \log \left(\dfrac{ x_{i+}}
{\sum^M_{i,j=1} x_{ij} }\right) \right)
}
\deqn{
\sigma^2_{AvMaxNormEnt}=
\dfrac{AvMaxNormEnt \cdot (1-AvMaxNormEnt)}{N_{AvMaxNormEnt}}
}
where:

\enumerate{
  \item \eqn{AvMaxNormEnt}: normalized entropy using the arithmetic
  mean of the maximum entropies on product and on reference.
  \item \eqn{Ent}: product entropy.
  \item \eqn{Ent_i(A)}: entropy of the class \emph{i} of
  the product with respect to the class \emph{i} of the product. A is a matrix.
  \item \eqn{Ent_i(B)}: entropy of class \emph{i} of the
  reference with respect to the class on the reference. B is a matrix.
  \item \eqn{x_{+j}}: sum of all elements in column j.
  \item \eqn{x_{i+}}: sum of all elements in row i.
  \item \eqn{M}: number of classes.
  \item \eqn{N_{AvMaxNormEnt}}: number of cases involved in the calculation
  of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$AvMaxNormEnt(a = NULL, v = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}

\item{\code{v}}{\verb{
Base of the logarithm, where} \eqn{v \in \mathbb{R}^{+}-\{1\}}.
\verb{By default v=10. This value is used
for the entropy units, v=10(units Hartleys), v=2(units bits),
v=e(units nats).}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing the normalized entropy
(arithmetic mean of the maximum entropies in the product and in
reference), its variance, and its confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(8,0,0,0,0,16,0,0,0,0,8,0,0,0,0,16),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Liu et al. 2007")
p$AvMaxNormEnt(v=2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-Sucess"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-Sucess}{}}}
\subsection{Method \code{Sucess()}}{
Public method that provides the Classification
Success Index (CSI) which considers all classes and gives an
overall estimation of classification effectiveness.
The method also offers the variance and confidence interval.
The references \insertCite{koukoulas2001,turk2002}{ConfMatrix}
are followed for the calculations.


The mathematical expression is:
 \deqn{
Sucess=1-(1-AvUserAcc+1-AvProdAcc)=AvUserAcc+AvProdAcc-1
}
 \deqn{
\sigma^2_{Sucess}=\dfrac{Sucess \cdot (1-Sucess)}{N_{Sucess}}
}

where:

\enumerate{
  \item \eqn{Sucess}: classification success index.
  \item \eqn{AvUserAcc}: average accuracy from user's perspective.
  \item \eqn{AvProdAcc}: average accuracy from producer's perspective.
  \item \eqn{N_{Sucess}}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$Sucess(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing the ICSI, its variance
and its confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(0.3,0.02,0.01,0.12,0.19,0.03,0.02,0.01,0.3),
nrow=3,ncol=3)
p<-ConfMatrix$new(A,Source="Labatut and Cherifi 2011")
p$Sucess()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-Sucess_i"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-Sucess_i}{}}}
\subsection{Method \code{Sucess_i()}}{
Public method that provides the Individual
Classification Success Index (ICSI) which considers  the classification
effectiveness for one particular class of interest.
The method also offers the variance and confidence interval.
The references \insertCite{koukoulas2001,turk2002}{ConfMatrix}
are followed for the calculations.


The mathematical expression is:
 \deqn{
Sucess_i=1-(1-UserAcc_i+1-ProdAcc_i)=UserAcc_i+ProdAcc_i-1
}

\deqn{
\sigma^2_{Sucess_i}=\dfrac{Sucess_i \cdot (1-Sucess_i)}{N_{Sucess_i}}
}

where:

\enumerate{
  \item \eqn{Sucess_i}: individual classification success index.
  \item \eqn{UserAcc_i}: user accuracy index for class i.
  \item \eqn{ProdAcc_i}: producer accuracy index for class i.
  \item \eqn{N_{Sucess_i}}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$Sucess_i(i, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{\verb{
Class to evaluate, where} \eqn{i \in \mathbb{Z}-\{0\}}.}

\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing the ICSI,
its variance and its confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(0.3,0.02,0.01,0.12,0.19,0.03,0.02,0.01,0.3),
nrow=3,ncol=3)
p<-ConfMatrix$new(A,Source="Labatut and Cherifi 2011")
p$Sucess_i(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-AvHellAcc"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-AvHellAcc}{}}}
\subsection{Method \code{AvHellAcc()}}{
Public method that provides the average value of the
Hellden mean precision index. The method also offers the
variance and confidence interval.
The reference \insertCite{liu2007}{ConfMatrix} is followed for
the calculations.


\deqn{
AvHellAcc=\dfrac{1}{M} 2 \sum^M_{i=1} \dfrac{ x_{ii}}
{ x_{+i} + x_{i+}}
}
 \deqn{
\sigma^2_{AvHellAcc}=\dfrac{AvHellAcc \cdot (1-AvHellAcc)}{N_{AvHellAcc}}
}

where:

\enumerate{
  \item \eqn{AvHellAcc}: average of Hellden's mean accuracy index.
  \item \eqn{x_{ii}}: diagonal element of the matrix.
  \item \eqn{x_{+i}}: sum of all elements in column i.
  \item \eqn{x_{i+}}: sum of all elements in row i.
  \item \eqn{M}: number of classes.
  \item \eqn{N_{AvHellAcc}}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$AvHellAcc(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing the average of
Hellden's mean accuracy index, its variance and
confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AvHellAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-AvHellAcc_i"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-AvHellAcc_i}{}}}
\subsection{Method \code{AvHellAcc_i()}}{
Public method that provides the Hellden’ average
accuracy, denotes for the probability that a randomly chosen
position or element assigned to a specific class on the product
has a correspondence of the same class in the homologous position
or element in the reference, and that a randomly chosen point
or element assigned to a specific class on the reference has a
correspondence of the same class in the homologous position or
element in the product. The method also offers the variance and
confidence interval. The references
\insertCite{hellden1980,rosenfield1986}{ConfMatrix} are
followed for the calculations.


\deqn{
AvHellAcc_i=\dfrac{2}{\dfrac{1}{UserAcc_i}+\dfrac{1}{ProdAcc_i}}=
\dfrac{2 UserAcc_i \cdot ProdAcc_i}{UserAcc_i + ProdAcc_i}
}
\deqn{
\sigma^2_{AvHellAcc_i}=\dfrac{AvHellAcc_i \cdot (1-AvHellAcc_i)}{N_{AvHellAcc_i}}
}
where:

\enumerate{
  \item \eqn{AvHellAcc_i}: Hellden's mean accuracy.
  \item \eqn{UserAcc_i}: user accuracy index for class i.
  \item \eqn{ProdAcc_i}: producer accuracy index for class i.
  \item \eqn{N_{AvHellAcc_i}}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$AvHellAcc_i(i, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{\verb{
Class to evaluate, where} \eqn{i \in \mathbb{Z}-\{0\}}.}

\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing the Hellden’s mean
accuracy, its variance and its confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A <- matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,39,
7,1,1,0,6,25,1,1,0,0,1,6), nrow=5,ncol=5)
p<-ConfMatrix$new(A,Source="Rosenfield and Fitzpatrick 1986")
p$AvHellAcc_i(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-AvShortAcc"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-AvShortAcc}{}}}
\subsection{Method \code{AvShortAcc()}}{
Public method that provides the average of the Short's
mapping accuracy index. The method also offers the
variance and confidence interval. The
reference \insertCite{liu2007}{ConfMatrix} is followed for
the calculations.


\deqn{
AvShortAcc=\dfrac{1}{M} \sum^M_{i=1} \dfrac{x_{ii}}
{ x_{+ i}+ x_{i +}-x_{ii}}
}
\deqn{
\sigma^2_{AvShortAcc}=\dfrac{AvShortAcc \cdot (1-AvShortAcc)}{N_{AvShortAcc}}
}
where:

\enumerate{
  \item \eqn{AvShortAcc}: average of Short's mapping accuracy index.
  \item \eqn{x_{ii}}: diagonal element of the matrix.
  \item \eqn{x_{i+}}: sum of all omissions in row i.
  \item \eqn{x_{+i}}: sum of all commissions in column i.
  \item \eqn{M}: number of classes.
  \item \eqn{N_{AvShortAcc}}: number of cases involved in the calculation of the index.
   }
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$AvShortAcc(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing the average of
Short's mapping accuracy index, its variance and
confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AvShortAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-ShortAcc_i"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-ShortAcc_i}{}}}
\subsection{Method \code{ShortAcc_i()}}{
Public method that provides the Short's mapping
accuracy. For each category of the matrix i, it is determined
as the quotient between the well-classified elements (value on
the diagonal) and the sum of that same value and the errors of
omission and commission (rest of values in the column and row)
corresponding to that class. The method also offers the
variance and confidence interval. The references
\insertCite{rosenfield1986,short1982}{ConfMatrix}
are followed for the calculations.


\deqn{
ShortAcc_i=\dfrac{x_{ii}}{ x_{+ i}+
 x_{i +}-x_{ii}}
}
\deqn{
\sigma^2_{ShortAcc_i}=\dfrac{ShortAcc_i \cdot (1-ShortAcc_i)}{N_{ShortAcc_i}}
}
where:

\enumerate{
  \item \eqn{ShortAcc_i}: Short's mapping accuracy
  \item \eqn{x_{ii}}: diagonal element of the matrix.
  \item \eqn{x_{i+}}: sum of all omissions in row i.
  \item \eqn{x_{+i}}: sum of all commissions in column i.
  \item \eqn{N_{ShortAcc_i}}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$ShortAcc_i(i, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{\verb{
Class to evaluate, where} \eqn{i \in \mathbb{Z}-\{0\}}.}

\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing the Short's
mapping accuracy, its variance and its confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A <- matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,
39,7,1,1,0,6,25,1,1,0,0,1,6), nrow=5,ncol=5)
p<-ConfMatrix$new(A,Source="Rosenfield and Fitzpatrick-Lins 1986")
p$ShortAcc_i(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-Tau"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-Tau}{}}}
\subsection{Method \code{Tau()}}{
Public method that calculates the Tau index and
its variance. Its value indicates how much the classification has
improved compared to a random classification of the N elements into
M groups. The method also offers the
variance and confidence interval.
The reference \insertCite{ma1995Tau}{ConfMatrix} is followed
for the computations.


The mathematical expression is:

\deqn{
Tau = \dfrac{OverallAcc-PrAgCoef}{1-PrAgCoef}
}
\deqn{
PrAgCoef=\dfrac{1}{M}
}

\deqn{
\sigma^2_{Tau}=\dfrac{OverallAcc \cdot (1-OverallAcc)}
{N_{Tau} \cdot (1-PrAgCoef)^2}
}

Where:
\enumerate{
  \item \eqn{Tau}: Tau index.
  \item \eqn{OverallAcc}: overall accuracy.
  \item \eqn{PrAgCoef}: a priori random agreement coefficient.
  \item \eqn{M}: number of classes.
  \item \eqn{N_{Tau}}: number of cases involved in the calculation
  of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$Tau(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of real values containing the Tau index,
its variance and confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(238051,7,132,0,0,24,9,2,189,1,4086,188,0,4,16,45,1,0,939,5082,
51817,0,34,500,1867,325,17,0,0,5,11148,1618,78,0,0,0,0,48,4,834,2853,340,
32,0,197,5,151,119,135,726,6774,75,1,553,0,105,601,110,174,155,8257,8,0,
29,36,280,0,0,6,5,2993,0,115,2,0,4,124,595,0,0,4374),nrow=9,ncol=9)
p<-ConfMatrix$new(A,Source="Muñoz 2016")
p$Tau()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-GroundTruth"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-GroundTruth}{}}}
\subsection{Method \code{GroundTruth()}}{
Public method that calculates the Ground Truth index
, its variance and confidence interval.The reference \insertCite{turk1979gt}{ConfMatrix}
is followed for the computations.


The mathematical expression is:

To calculate \eqn{R} we begin the following iterative process:
Be \eqn{U_j^{(0)}=f_j^0} with \eqn{f_j^0} equal to user accuracy and
\eqn{f_i^0} equal to producer accuracy.

 When \eqn{2m (m=1,2,\cdots)}
 \deqn{
 V_i^{2m-1}=\dfrac{f_i^0}{U_.^{2m-2}-U_i^{2m-2}}
 }
 where \eqn{U_.^{2m}=\sum_{i=1}^k U_j^{2m} }
 and when \eqn{2m+1 (m=1,2,\cdots)}
 \deqn{
 u_j^{2m}=\dfrac{f_j^0}{V_.^{2m-1}-V_i^{2m-1}}
 }
 where \eqn{V_.^{2m-1}=\sum_{i=1}^k V_i^{2m-1} }

 The iterative steps continue for \eqn{m=1, 2,\cdots} until
 the accuracy stabilizes.
 Where
 \deqn{
R=\dfrac{V}{\sum_{i=1}^{k} V_i}
}

\deqn{
ProdAcc=\dfrac{x_{ii}}{\sum_{j=1}^M x_{+j}}
}
\deqn{
GroundTruth = \dfrac{ProdAcc-R}{1-R}
}

\deqn{
\sigma^2_{GroundTruth}=\dfrac{GroundTruth \cdot (1-GroundTruth)}
{N_{GroundTruth}}
}

Where:
\enumerate{
  \item \eqn{GroundTruth}: index ground truth.
  \item \eqn{R}: casual lucky guess.
  \item \eqn{ProdAcc}: producer accuracy.
  \item \eqn{N_{GroundTruth}}: number of elements of the matrix.
  }
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$GroundTruth(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with Ground Truth indexes, their variance, confidence
intervals and the matrix with the expected frequencies.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,39,7,1,1,0,
6,25,1,1,0,0,1,6),nrow=5,ncol=5)
p<-ConfMatrix$new(A,Source="Türk 1979")
p$GroundTruth()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-GroundTruth_i"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-GroundTruth_i}{}}}
\subsection{Method \code{GroundTruth_i()}}{
Public method that calculates the Ground Truth index
for class i, its variance and confidence interval.The reference
\insertCite{turk1979gt}{ConfMatrix} is followed for the computations.


The mathematical expression is:

To calculate R_i we begin the following iterative process:
Take the original matrix by replacing its diagonal elements with 0.
Thus define the new matrix \eqn{M_0}.
Be \eqn{U_j^{(0)}=f_j^0} with \eqn{f_j^0} equal to user accuracy and
\eqn{f_i^0} equal to producer accuracy for \eqn{M_0}.

 When \eqn{2m (m=1,2,\cdots)}
 \deqn{
 V_i^{2m-1}=\dfrac{f_i^0}{U_.^{2m-2}-U_i^{2m-2}}
 }
 where \eqn{U_.^{2m}=\sum_{i=1}^k U_j^{2m} }
 and when \eqn{2m+1 (m=1,2,\cdots)}
 \deqn{
 u_j^{2m}=\dfrac{f_j^0}{V_.^{2m-1}-V_i^{2m-1}}
 }
 where \eqn{V_.^{2m-1}=\sum_{i=1}^k V_i^{2m-1} }

 The iterative steps continue for \eqn{m=1, 2,\cdots} until
 the accuracy stabilizes.
 Where
 \deqn{
R_i=\dfrac{V_i}{\sum_{i=1}^{k} V_i}
}

\deqn{
ProdAcc_i=\dfrac{x_{ii}}{\sum_{j=1}^M x_{+j}}
}
\deqn{
GroundTruth_i = \dfrac{ProdAcc_i-R_i}{1-R_i}
}

\deqn{
\sigma^2_{GroundTruth_i}=\dfrac{GroundTruth_i \cdot (1-GroundTruth_i)}
{N_{GroundTruth_i}}
}

Where:
\enumerate{
  \item \eqn{GroundTruth_i}: index ground truth for class i.
  \item \eqn{R_i}: casual lucky guess for class i. Is a real value.
  \item \eqn{ProdAcc_i}: producer accuracy for class i.
  \item \eqn{N_{GroundTruth_i}}: number of elements of the matrix.
  }
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$GroundTruth_i(i, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{\verb{
Class to evaluate, where} \eqn{i \in \mathbb{Z}-\{0\}}.}

\item{\code{a}}{\verb{
Significance level. By default 0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with Ground Truth index for class i, its variance, confidence
interval and the matrix with the expected frequencies for all classes.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,39,7,1,1,0,
6,25,1,1,0,0,1,6),nrow=5,ncol=5)
p<-ConfMatrix$new(A,Source="Türk 1979")
p$GroundTruth_i(3)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-UserProdAcc"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-UserProdAcc}{}}}
\subsection{Method \code{UserProdAcc()}}{
Public method that calculates the user’s and the
producer’s indexes jointly. This method is equivalent to the methods
[ConfMatrix$UserAcc] and [ConfMatrix$ProdAcc].
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$UserProdAcc()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list containing the producer's and user's accuracies and
their standard deviations, respectively.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$UserProdAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-DetailKappa"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-DetailKappa}{}}}
\subsection{Method \code{DetailKappa()}}{
Public method that calculates the general Kappa
agreement index, its standard deviation and the test statistic
to test its significance. The delta method has been used to calculate
the sample variance. The reference
\insertCite{congalton2008}{ConfMatrix} is followed for the computations.

The mathematical expression is:

\deqn{
Kappa=\dfrac{OverallAcc-ExpAcc}{1-ExpAcc}
}

 \deqn{
ExpAcc= \dfrac{x_{+ j} \cdot x_{i +}}{\sum_{(i,j=1}^M x_{ij})^{2}}
}
\deqn{
\sigma^2_{Kappa} = \dfrac{1}{N_{Kappa}} \left( \dfrac{\theta_1 (1-\theta_1) }{(1-\theta_2)^2}
+ \dfrac{2(1-\theta_1)(2\theta_1\theta_2-\theta_3)}{(1-\theta_2)^3}
+ \dfrac{(1-\theta_1)^2(\theta_4-4\theta_2^2)}{(1-\theta_2)^4} \right)
}
where

\deqn{
\theta_1=OverallAcc= \sum_{i, j=1}^{M} \dfrac{ x_{ii}}{ x_{ij}}
}

\deqn{
\theta_2=ExpAcc=\sum^M_{i=1}
\left( \dfrac{x_{+ i}}{\sum_{j=1}^M x_{ij}}
\cdot \dfrac{x_{i +}}{\sum_{j=1}^M x_{ij}} \right)
}


\deqn{
\theta_3=\sum^M_{i=1} \left( \dfrac{x_{ii} x_{+ i}}{\sum_{j=1}^M x_{ij}}
\cdot \dfrac{x_{ii} x_{i +}}{\sum_{j=1}^M x_{ij}} \right)
}


\deqn{
\theta_4=\dfrac{1}{ ( \sum_{i,j=1}^M x_{ij})^3} \sum_{i,j=1}^M x_{ij}
(x_{j+}+x_{+i})^2
}

\deqn{
Z=\dfrac{Kappa}{\sqrt{\sigma^2_{Kappa}}}
}


Where:
\enumerate{
  \item \eqn{Kappa}: Kappa coefficient.
  \item \eqn{ExpAcc}: expected accuracy of agreement if agreement
  were purely random.
  \item \eqn{OverallAcc}: overall accuracy.
  \item \eqn{\theta_1, \theta_2, \theta_3, \theta_4}: real values.
  \item \eqn{x_{+j}}: sum of all elements in column j.
  \item \eqn{x_{i+}}: sum of all elements in row i.
  \item \eqn{Z}: the test statistic.
  \item \eqn{N_{Kappa}}: number of cases involved in the calculation of
  the index.
  \item \eqn{\sigma^2_{Kappa}}: kappa variance using the delta method
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$DetailKappa()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list of real values containing the kappa coefficient,
its standard deviation, and the value of its test statistic.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$DetailKappa()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-DetailCondKappa"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-DetailCondKappa}{}}}
\subsection{Method \code{DetailCondKappa()}}{
Public method that calculates the Kappa class agreement
index (conditional Kappa) from the perspective of user (i) and
producer (j) and its standard deviations. The reference
\insertCite{congalton2008}{ConfMatrix} is followed for the computations.


The mathematical expression is:

\deqn{
CondKappa_{user}=\dfrac{\dfrac{x_{ii}}{x_{i+}}-x_{+j}}{1-x_{+j}}
}

\deqn{
CondKappa_{producer}=\dfrac{\dfrac{x_{ii}}{x_{+j}}-x_{i+}}{1-x_{i+}}
}

\deqn{
\sigma^2_{CondKappa_{producer}}=\dfrac{1}{\sum_{i,j=1}^M x_{ii}} \cdot
\dfrac{x_{+j}-x_{ii}}{x_{+j}^3 (1-x_{i+})^3} \cdot ((x_{+j}-x_{ii})\cdot
(x_{+j}x_{i+}-x_{ii}) + x_{ii} (1-x_{+j}-x_{i+}+x_{ii})  )
}

\eqn{\sigma^2_{CondKappa_{user}}} is done in an analogous way by exchanging
\eqn{x_{i+}} to \eqn{x_{+j}}.

\enumerate{
\item \eqn{CondKappa_{User}}: Conditional kappa index from the user's perspective.
\item \eqn{CondKappa_{Producer}}: Conditional kappa index from the producer's perspective.
\item \eqn{x_{ii}}: diagonal elements of the matrix.
\item \eqn{x_{+j}}: sum of all elements in column j.
\item \eqn{x_{i+}}: sum of all elements in row i.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$DetailCondKappa()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list of real values containing conditional Kappa index of the user and the
producer, and its corresponding standard deviation.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(0.2361,0.0694,0.1389,0.0556,0.1667,0.0417,0.1111,0,0.1806),
ncol=3,nrow=3)
p<-ConfMatrix$new(A,Source="Czaplewski 1994")
p$DetailCondKappa ()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-QES"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-QES}{}}}
\subsection{Method \code{QES()}}{
Public method that calculates the values of quantity
difference, exchange and shift. Quantity difference is the amount of
difference between the product and the reference and is due to the
less than maximum match in the proportions of the categories. Exchange
represents transitions from class i to j and a transition from class j
to class i in an identical number of cases. Shift refers to the
difference remaining after subtracting quantity difference and exchange
from the overall difference. The reference
\insertCite{pontius2014}{ConfMatrix} is followed for the computations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$QES()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
For the interval t of difference. A list of integer values with
quantity, exchange, and shift. In addition to the differences for
classes of the components of quantity, exchange and turn.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(3,2,1,1,3,3,2,0,1),
nrow=3,ncol=3)
p<-ConfMatrix$new(A,Source="Pontius Jr. and Santacruz 2023")
p$QES()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-DetailWTau"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-DetailWTau}{}}}
\subsection{Method \code{DetailWTau()}}{
Public method that calculates the general Tau
concordance index (weighted) and its standard deviation.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$DetailWTau(WV)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{WV}}{Weights vector (as matrix)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with the weighted Tau index, the weight matrix,
its standard deviation and its statistics.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
WV <-matrix(c(0.4, 0.1, 0.4, 0.1), ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$DetailWTau(WV)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-DetailWKappa"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-DetailWKappa}{}}}
\subsection{Method \code{DetailWKappa()}}{
Public method that calculates the general Kappa agreement
index (weighted) and its standard deviation. The reference
\insertCite{fleiss1969,naesset1996,congalton2008}{ConfMatrix} are followed for the
computations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$DetailWKappa(WM)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{WM}}{Weight matrix (as matrix).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with the weight matrix, kappa index obtained from
the original matrix and the weight matrix, its standard deviations
and the value of its test statistic.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A <- matrix(c(1,1,0,0,0,5,55,27,23,0,3,30,68,74,4,0,8,8,39,
26,0,0,2,4,26),nrow=5)
WM <- matrix(c(1,0.75,0.5,0.25,0,0.75,1,0.75,0.5,0.25,0.5,0.75,
1,0.75,0.5,0.25,0.5,0.75,1,0.75,0,0.25,0.5,0.75,1),nrow=5)
p<-ConfMatrix$new(A, Source="Næsset 1996")
p$DetailWKappa(WM)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-UserProdAcc_W"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-UserProdAcc_W}{}}}
\subsection{Method \code{UserProdAcc_W()}}{
Public method that calculates the weighted user’s
and producer’s accuracies and their standard deviations.
The reference \insertCite{congalton2008}{ConfMatrix} is followed
for the computations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$UserProdAcc_W(WM)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{WM}}{Weight matrix (as matrix)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with the weight matrix, the product of the
confusion matrix and the weight matrix, weighted user's
and producer's accuracies and their standard deviations.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
WM<- t(matrix(c(1,0,0.67,1,0,1,0,0,1,0,1,1,0.91,0,0.61,1),
nrow = 4, ncol=4))
p$UserProdAcc_W(WM)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-MTypify"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-MTypify}{}}}
\subsection{Method \code{MTypify()}}{
Public method that typifies the confusion matrix.
The total sum of the original matrix is used for typing. In a
typed matrix the sum of all values is unity. The resulting
values can be presented as real values (parameter RaR=1), or as
a percentage (parameter RaR !=1).


The matematical expression is:
 \deqn{
MTypify=\dfrac{Values}{\sum^M_{i,j=1} x_{ij}}
}

where:

\enumerate{
  \item MTypify: typified matrix.
  \item Values: Matrix of integer values.
  \item \eqn{x_{ij}}: matrix element.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$MTypify(RaR = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{RaR}}{"1" indicates result as real, other values mean percentage
as integer. By default RaR=1.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with two arrays, the first is the original array,
the second the typed one.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A, Source="Congalton and Green 2008")
p$MTypify(RaR=5)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-AllParameters"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-AllParameters}{}}}
\subsection{Method \code{AllParameters()}}{
Public method in which multiple parameters are
calculated for the given confusion matrix. This method is
equivalent to [ConfMatrix$OverallAcc],[ConfMatrix$UserAcc],
[ConfMatrix$ProdAcc],[ConfMatrix$Kappa] and [ConfMatrix$MPseudoZeroes].
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$AllParameters()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The following list of elements: the confusion matrix,
dimension, total sum of cell values, overall accuracy, overall
accuracy variance, global kappa index, global kappa simplified
variance, producer accuracy by class, user accuracy by class,
and pseudoceros matrix.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AllParameters()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-MBootStrap"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-MBootStrap}{}}}
\subsection{Method \code{MBootStrap()}}{
Public method that provides B resamples, using a
multinomial distribution, of the confusion matrix of a ConfMatrix
object. As a result, a set of bootstrapped cases is offered. The
reference \insertCite{fienberg1970}{ConfMatrix} is
followed for the computations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$MBootStrap(B, pr = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{B}}{Number of resamples.}

\item{\code{pr}}{Vector with resampling probabilities. By default, the
success probability of each cell will be taken.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of B + 1 arrays formed by the original confusion matrix
and all the simulated cases.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A, Source="Congalton and Green 2008")
p$MBootStrap(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-MNormalize"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-MNormalize}{}}}
\subsection{Method \code{MNormalize()}}{
Public method that carries out an iterative process in
order to get the sum of values by rows and columns to be worth one.
The references \insertCite{fienberg1970,munoz2016}{ConfMatrix}
are followed for the computations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$MNormalize(iter = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{iter}}{\verb{
Number of iteration. By default iter=1000.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\verb{
A list formed by the original confusion matrix and the
normalized matrix.
}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(238051,7,132,0,0,24,9,2,189,1,4086,188,0,4,16,45,1,0,939,5082,
51817,0,34,500,1867,325,17,0,0,5,11148,1618,78,0,0,0,0,48,4,834,2853,340,
32,0,197,5,151,119,135,726,6774,75,1,553,0,105,601,110,174,155,8257,8,0,
29,36,280,0,0,6,5,2993,0,115,2,0,4,124,595,0,0,4374),nrow=9,ncol=9)
p<-ConfMatrix$new(A,Source="Muñoz 2016")
p$MNormalize()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-MPseudoZeroes"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-MPseudoZeroes}{}}}
\subsection{Method \code{MPseudoZeroes()}}{
Public method that small values are calculated for empty
cells of the matrix. All non-empty cells of the matrix change their
values. This function will not be applied if all the elements of the
matrix are different from 0.
The reference \insertCite{munoz2016}{ConfMatrix} is followed
for the computations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$MPseudoZeroes()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list formed by the original confusion matrix and the
Pseudozeroes matrix.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(238051,7,132,0,0,24,9,2,189,1,4086,188,0,4,16,45,1,0,939,5082,
51817,0,34,500,1867,325,17,0,0,5,11148,1618,78,0,0,0,0,48,4,834,2853,340,
32,0,197,5,151,119,135,726,6774,75,1,553,0,105,601,110,174,155,8257,8,0,
29,36,280,0,0,6,5,2993,0,115,2,0,4,124,595,0,0,4374),nrow=9,ncol=9)
p<-ConfMatrix$new(A,Source="Muñoz 2016")
p$MPseudoZeroes()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-StHell"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-StHell}{}}}
\subsection{Method \code{StHell()}}{
Public method that provides the Hellinger distance
between two elements of the ConfMatrix class.
The reference \insertCite{garcia2018}{ConfMatrix} is followed
for the computations.
The mathematical expression is:

\deqn{
HD = \dfrac{4n_{A}m_{B}}{n_{A}+m_{B}} \sum^{M}_{i=1} (\sqrt{p_i}-\sqrt{q_i})^2
}

Where:
\enumerate{
  \item \eqn{HD}: Hellinger Distance.
  \item \eqn{n_{A}}: number of elements in the matrix A.
  \item \eqn{m_{B}}: number of elements in the matrix B.
  \item \eqn{p_i}: element i of the probability vector of matrix A.
  \item \eqn{q_i}: element i of the probability vector of matrix B.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$StHell(f, p = NULL, q = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{f}}{\verb{
Element of the ConfMatrix.
}}

\item{\code{p}}{\verb{
probability vector of matrix A. By default, the probability of
success for each cell is taken.}}

\item{\code{q}}{\verb{
probability vector of matrix B. By default, the probability of
success for each cell is taken.}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A real value for the statistic value of the statistical
test based on the Hellinger distance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
r<-ConfMatrix$new(A,Source="Congalton and Green 2008")
B<-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),
nrow=4,ncol=4)
f<-ConfMatrix$new(B,Source="Congalton and Green 2008")
r$StHell(f)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-Kappa.test"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-Kappa.test}{}}}
\subsection{Method \code{Kappa.test()}}{
Public method that tests whether two independent
confusion matrices (instances of the ConfMatrix class), are
significantly different when using the kappa indexes.
The reference \insertCite{congalton2008}{ConfMatrix} is followed
for the computations.
The mathematical expression is:

\deqn{
Z = \dfrac{|k_A-k_B|}{\sqrt{(\sigma^2_{k_A}+\sigma^2_{k_B})}}
}

Where:
\enumerate{
 \item \eqn{Z}: statistic.
  \item \eqn{k_A}: kappa index of matrix A
  \item \eqn{k_B}: kappa index of matrix B
  \item \eqn{\sigma^2_{k_A}}: variance of \eqn{k_A}.
  \item \eqn{\sigma^2_{k_B}}: variance of \eqn{k_B}.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$Kappa.test(f, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{f}}{\verb{
Element of the ConfMatrix class.
}}

\item{\code{a}}{\verb{
Significance level. By default a=0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with the value of the test statistic and its
z score for a given significance level.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
B<-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),nrow=4,ncol=4)
f<-ConfMatrix$new(B,Source="Congalton and Green 2008")
p$Kappa.test(f)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-OverallAcc.test"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-OverallAcc.test}{}}}
\subsection{Method \code{OverallAcc.test()}}{
Public method that tests whether two independent
confusion matrices (instances of the ConfMatrix class), are
significantly different using their overall accuracy indexes.
The reference \insertCite{book,ma1995Tau}{ConfMatrix} are followed
for the computations.
The mathematical expression is:

\deqn{
Z = \dfrac{|O_A-O_B|}{\sqrt{(\sigma^2_{O_A}+\sigma^2_{O_B})}}
}

Where:
\enumerate{
 \item \eqn{Z}: statistic.
  \item \eqn{O_A}: overall index of matrix A
  \item \eqn{O_B}: overall index of matrix B
  \item \eqn{\sigma^2_{O_A}}: variance of \eqn{O_A}.
  \item \eqn{\sigma^2_{O_B}}: variance of \eqn{O_B}.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$OverallAcc.test(f, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{f}}{\verb{
Element of the ConfMatrix class.
}}

\item{\code{a}}{\verb{
Significance level. By default a=0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with the value of the test statistic and its z
score for a given significance level.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
B<-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),nrow=4,ncol=4)
f<-ConfMatrix$new(B,Source="Congalton and Green 2008")
p$OverallAcc.test(f)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-Tau.test"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-Tau.test}{}}}
\subsection{Method \code{Tau.test()}}{
Public method that tests whether two independent
confusion matrices (instances of the ConfMatrix class), are
significantly different using their Tau indexes.
The reference \insertCite{book,ma1995Tau}{ConfMatrix} are followed
for the computations.
The mathematical expression is:

\deqn{
Z = \dfrac{|\tau_A-\tau_B|}{\sqrt{(\sigma^2_{\tau_A}+\sigma^2_{\tau_B})}}
}

Where:
\enumerate{
 \item \eqn{Z}: statistic.
  \item \eqn{\tau_A}: Tau index of matrix A
  \item \eqn{\tau_B}: Tau index of matrix B
  \item \eqn{\sigma^2_{\tau_A}}: variance of \eqn{\tau_A}.
  \item \eqn{\sigma^2_{\tau_B}}: variance of \eqn{\tau_B}.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$Tau.test(f, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{f}}{\verb{
Element of the ConfMatrix class.
}}

\item{\code{a}}{\verb{
Significance level. By default a=0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with the value of the test statistic and its z
score for a given significance level.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
B<-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),
nrow=4,ncol=4)
f<-ConfMatrix$new(B,Source="Congalton and Green 2008")
p$Tau.test(f)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-TSCM.test"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-TSCM.test}{}}}
\subsection{Method \code{TSCM.test()}}{
Public method that performs a homogeneity test
based on the Hellinger distance between two confusion matrices
(instances of the ConfMatrix class)
The test considers the individual cell values in the matrices.
To use this test, the column vectors are chained one after the other.
The reference \insertCite{garcia2018}{ConfMatrix} is followed for
the computations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$TSCM.test(f, B = NULL, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{f}}{\verb{
Element of the ConfMatrix class.
}}

\item{\code{B}}{\verb{
Number of bootstraps that you want to generate.
By default B=1000.
}}

\item{\code{a}}{\verb{
Significance level. By default a=0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with the value of the test statistic and its z
score for a given significance level.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
B<-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),
nrow=4,ncol=4)
f<-ConfMatrix$new(B,Source="Congalton and Green 2008")
p$TSCM.test(f)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-QIndep.test"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-QIndep.test}{}}}
\subsection{Method \code{QIndep.test()}}{
Public method that performs the
 quasi-independence test for the elements of a confusion matrix.
 The reference
 \insertCite{turk1979gt,goodman1968analysis}{ConfMatrix} are followed for the computations.
The mathematical expression is:

\deqn{
G^2 = 2 \cdot \sum \log \dfrac{x_{ij}}{E_{ij}}
}

Where:
\enumerate{
  \item \eqn{G^2}: statistic.
  \item \eqn{x_{ij}}: matrix element. Observed frequency.
  \item \eqn{E_{ij}}: expected frequency.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$QIndep.test(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{\verb{
Significance level. By default a=0.05.
}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of the statistic's value and its z-score for a given
significance level.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,39,
7,1,1,0,6,25,1,1,0,0,1,6),nrow=5,ncol=5)
p<-ConfMatrix$new(A,Source= "Türk 1979")
p$QIndep.test()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-plot.global"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-plot.global}{}}}
\subsection{Method \code{plot.global()}}{
Public method that provides a graph of the indices of
the functions [ConfMatrix$OverallAcc], [ConfMatrix$Kappa],
[ConfMatrix$Tau], [ConfMatrix$AvHellAcc] and [ConfMatrix$AvShortAcc]
 with their corresponding standard deviations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$plot.global()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A graph of the indices of the functions OverallAcc, Kappa,
Tau, AvHellAcc, AvShortAcc with their corresponding
standard deviations.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$plot.global()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-plot.class"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-plot.class}{}}}
\subsection{Method \code{plot.class()}}{
Public method that provides a graph for the user’s
and producer’s accuracies and standard deviations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$plot.class()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The graph of the accuracy index of users and producers
with their corresponding standard desviation.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$plot.class()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-print"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-print}{}}}
\subsection{Method \code{print()}}{
Public method that shows all the data entered
by the user.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$print()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
ConfMatrix object identifier, date, class name, data
source and confusion matrix.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,ClassName=c("Deciduous","conifer",
"agriculture","shrub"),Source="Congalton and Green 2008")
p$print()

}
\if{html}{\out{</div>}}

}

}
}
