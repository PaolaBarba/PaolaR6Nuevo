% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MatCon.R
\name{MatCon}
\alias{MatCon}
\title{Confusion matrix}
\value{
Object of class MatCon #y mas
}
\description{
Using the confusion matrix, various indices are calculated.
}
\examples{
C = matrix( c(5, 0, 1, 0,4,0,0,0,3), nrow=3,  ncol=3)
mc2 <- MatCon$new (C,ID=5,Date="27-10-2023")

## ------------------------------------------------
## Method `MatCon$oa`
## ------------------------------------------------

A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$oa()

## ------------------------------------------------
## Method `MatCon$dec`
## ------------------------------------------------

A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$dec()

## ------------------------------------------------
## Method `MatCon$ua`
## ------------------------------------------------

A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A,ID=1,Date="30/10/2023")
p$ua()

## ------------------------------------------------
## Method `MatCon$uai`
## ------------------------------------------------

A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$uai(2)

## ------------------------------------------------
## Method `MatCon$pai`
## ------------------------------------------------

A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$pai(1)

## ------------------------------------------------
## Method `MatCon$pa`
## ------------------------------------------------

A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$pa()

## ------------------------------------------------
## Method `MatCon$aup`
## ------------------------------------------------

A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$aup(2)

## ------------------------------------------------
## Method `MatCon$ICSI`
## ------------------------------------------------

A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$ICSI(2)

## ------------------------------------------------
## Method `MatCon$mah`
## ------------------------------------------------

A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$mah(2)

## ------------------------------------------------
## Method `MatCon$mas`
## ------------------------------------------------

A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$mas(2)

## ------------------------------------------------
## Method `MatCon$cku`
## ------------------------------------------------

A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$cku(2)

## ------------------------------------------------
## Method `MatCon$ckp`
## ------------------------------------------------

A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$ckp(2)

## ------------------------------------------------
## Method `MatCon$mcku`
## ------------------------------------------------

A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$mcku(2)

## ------------------------------------------------
## Method `MatCon$mckp`
## ------------------------------------------------

A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$mckp(2)

## ------------------------------------------------
## Method `MatCon$ecnu`
## ------------------------------------------------

A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$ecnu(2)

## ------------------------------------------------
## Method `MatCon$ecnp`
## ------------------------------------------------

A<-matrix(c(36,5,4,7,2,2,6,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$ecnp(2)

## ------------------------------------------------
## Method `MatCon$aau`
## ------------------------------------------------

A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$aau()

## ------------------------------------------------
## Method `MatCon$Normalize`
## ------------------------------------------------

A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$Normalize()
p$Normalize(1000)

## ------------------------------------------------
## Method `MatCon$aap`
## ------------------------------------------------

A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$aap()
}
\references{
Story, M., & Congalton, R. G. (1986). Accuracy assessment: a user’s perspective. Photogrammetric Engineering and remote sensing, 52(3), 397-399.

Koukoulas, S., & Blackburn, G. A. (2001). Introducing new indices for accuracy evaluation of classified images representing semi-natural woodland environments. Photogrammetric Engineering and Remote Sensing, 67(4), 499-510.

Turk, G. (2002). Map evaluation and" chance correction". Photogrammetric Engineering and Remote Sensing, 68(2), 123-129.

Helldén, U. (1980). A test of landsat-2 imagery and digital data for thematic mapping illustrated by an environmental study in northern Kenya, Lund University. Natural Geography Institute Report No. 47.

Rosenfield, G. H., & Fitzpatrick-Lins, K. (1986). A coefficient of agreement as a measure of thematic classification accuracy. Photogrammetric engineering and remote sensing, 52(2), 223-227.

Short, N. M. (1982). The Landsat tutorial workbook: Basics of satellite remote sensing (Vol. 1078). National Aeronautics and Space Administration, Scientific and Technical Information Branch.

Stehman, S. V. (1997). Selecting and interpreting measures of thematic classification accuracy. Remote sensing of Environment, 62(1), 77-89.

Finn, J. T. (1993). Use of the average mutual information index in evaluating classification error and consistency. International Journal of Geographical Information Science, 7(4), 349-366.

Tung, F., & LeDrew, E. (1988). The determination of optimal threshold levels for change detection using various accuracy indexes. Photogrammetric Engineering and Remote Sensing, 54(10), 1449-1454.

Fienberg, S. E. (1970). An iterative procedure for estimation in contingency tables. The Annals of Mathematical Statistics, 41(3), 907-917.
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-MatCon-new}{\code{MatCon$new()}}
\item \href{#method-MatCon-oa}{\code{MatCon$oa()}}
\item \href{#method-MatCon-dec}{\code{MatCon$dec()}}
\item \href{#method-MatCon-ua}{\code{MatCon$ua()}}
\item \href{#method-MatCon-uai}{\code{MatCon$uai()}}
\item \href{#method-MatCon-pai}{\code{MatCon$pai()}}
\item \href{#method-MatCon-pa}{\code{MatCon$pa()}}
\item \href{#method-MatCon-aup}{\code{MatCon$aup()}}
\item \href{#method-MatCon-ICSI}{\code{MatCon$ICSI()}}
\item \href{#method-MatCon-mah}{\code{MatCon$mah()}}
\item \href{#method-MatCon-mas}{\code{MatCon$mas()}}
\item \href{#method-MatCon-cku}{\code{MatCon$cku()}}
\item \href{#method-MatCon-ckp}{\code{MatCon$ckp()}}
\item \href{#method-MatCon-mcku}{\code{MatCon$mcku()}}
\item \href{#method-MatCon-mckp}{\code{MatCon$mckp()}}
\item \href{#method-MatCon-ecnu}{\code{MatCon$ecnu()}}
\item \href{#method-MatCon-ecnp}{\code{MatCon$ecnp()}}
\item \href{#method-MatCon-aau}{\code{MatCon$aau()}}
\item \href{#method-MatCon-Normalize}{\code{MatCon$Normalize()}}
\item \href{#method-MatCon-aap}{\code{MatCon$aap()}}
\item \href{#method-MatCon-clone}{\code{MatCon$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-new"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-new}{}}}
\subsection{Method \code{new()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$new(values, ID = NULL, Date = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{values}}{Confusion matrix}

\item{\code{ID}}{Identifier (optional)}

\item{\code{Date}}{System or user-provided date (optional)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-oa"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-oa}{}}}
\subsection{Method \code{oa()}}{
Overall accuracy for a particular classified image/map is then calculated by dividing the sum of the entries that form the major diagonal (i.e., the number of correct classifications) by the total number of samples taken.


The mathematical expression is:

\deqn{
oa = \frac{\sum_{i=1}^{n} x_{ii}}{\sum_{i, j=1}^{n} x_{ij}}
}

Where:
\enumerate{
  \item `oa`: overall accuracy.
  \item `x_ii`: diagonal element of the matrix.
  \item `x_ij`: element of the matrix.
}
This represents a mathematical expression with a fraction.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$oa(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{(ignored).}
}
\if{html}{\out{</div>}}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$oa()
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-dec"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-dec}{}}}
\subsection{Method \code{dec()}}{
Determines whether a value is decimal or not.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$dec(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{(ignored).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
TRUE or FALSE
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$dec()
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-ua"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-ua}{}}}
\subsection{Method \code{ua()}}{
The accuracy from the point of view of a map user, not the map maker.


The mathematical expression is:
\deqn{
ua=\frac{x_{ii}}{\sum_{j=1}^n x_{ij}}
}

where:

\enumerate{
  \item `ua`: user accuracy.
  \item `x_ii`: diagonal element of the matrix.
  \item `x_ij`: element of the matrix.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$ua(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{(ignored).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
vector of values with the user's accuracy indexes of all classes
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A,ID=1,Date="30/10/2023")
p$ua()
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-uai"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-uai}{}}}
\subsection{Method \code{uai()}}{
The accuracy from the point of view of a map user, not the map maker.


\deqn{
ua_{i}=\frac{x_{ii}}{\sum_{j=1}^n x_{ij}}
}

where:

\enumerate{
  \item `ua_i`: user accuracy.
  \item `x_ii`: diagonal element of the matrix.
  \item `x_ij`: element of the matrix.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$uai(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{User class to evaluate}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Class i user accuracy index
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$uai(2)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-pai"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-pai}{}}}
\subsection{Method \code{pai()}}{
The map accuracy from the point of view of the map maker (the producer).


\deqn{
pa_{i}=\frac{x_{jj}}{\sum_{j=1}^n x_{ij}}
}

where:

\enumerate{
  \item `pa_i`: producer accuracy.
  \item `x_jj`: diagonal element of the matrix.
  \item `x_ij`: element of the matrix.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$pai(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Producer class to evaluate}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Class i producer accuracy index
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$pai(1)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-pa"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-pa}{}}}
\subsection{Method \code{pa()}}{
The map accuracy from the point of view of the map maker (the producer).


\deqn{
pa=\frac{x_{jj}}{\sum_{j=1}^n x_{ij}}
}

where:

\enumerate{
  \item `pa`: producer accuracy.
  \item `x_jj`: diagonal element of the matrix.
  \item `x_ij`: element of the matrix.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$pa(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{(ignored).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Vector of values with the producer's accuracy indexes of all classes
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$pa()
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-aup"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-aup}{}}}
\subsection{Method \code{aup()}}{
Average of the accuracy from the point of view of a map user, not the map maker and the map accuracy from the point of view of the map maker (the producer).


\deqn{
aup=\frac{ua_i+pa_i}{2}
}

where:

\enumerate{
  \item `aup`: Average of user's and producer's accuracy.
  \item `ua_i`: user accuracy
  \item `pa_i`: producer accuracy.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$aup(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}
}
\if{html}{\out{</div>}}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$aup(2)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-ICSI"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-ICSI}{}}}
\subsection{Method \code{ICSI()}}{
The Individual Classification Success Index (ICSI) applies to the classification effectiveness for one particular class of interest.


\deqn{
ICSI=ua_i+pa_i-1
}

where:

\enumerate{
  \item `ICSI`: Individual classification success index.
  \item `ua_i`: user accuracy.
  \item `pa_i`: producer accuracy.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$ICSI(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}
}
\if{html}{\out{</div>}}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$ICSI(2)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-mah"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-mah}{}}}
\subsection{Method \code{mah()}}{
The probability that a randomly chosen point of a specific class on the map has a correspondence of the same class in the same position in the field and that a randomly chosen point in the field of the same class has a correspondence of the same class in the same position on the map.


\deqn{
mah=\frac{2}{\frac{1}{ua_i}+\frac{1}{pa_i}}
}

where:

\enumerate{
  \item `mah`: Hellden's mean accuracy.
  \item `ua_i`: user accuracy.
  \item `pa_i`: producer accuracy.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$mah(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}
}
\if{html}{\out{</div>}}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$mah(2)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-mas"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-mas}{}}}
\subsection{Method \code{mas()}}{
Mapping accuracy for each class is stated as the number of correctly classified pixels (equal to the total in the correctly classified area) in terms of all pixels affected by its classification (equal to this total in the displayed area as well as the pixels involved in errors of commission and omission).


\deqn{
mas=\frac{x_{ii}}{\sum^n_{j=1} x_{\cdot j}+\sum^n_{i=1} x_{i \cdot }-x_{ii}}
}

where:

\enumerate{
  \item `mas`: Short's mapping accuracy
  \item `x_ii`: diagonal element of the matrix.
  \item `x_.j`: sum with respect to j (rows).
  \item `x_i.`: sum with respect to i (columns).
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$mas(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}
}
\if{html}{\out{</div>}}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$mas(2)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-cku"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-cku}{}}}
\subsection{Method \code{cku()}}{
Conditional Kappa will identify the degree of agreement between the two raters for each possible category.


\deqn{
cku=\frac{ua_i-\frac{\sum^n_{i=1} x_{i \cdot }}{\sum^n_{i=1}\sum^n_{j=1} x_{ij}}}{1-\frac{\sum^n_{i=1} x_{i \cdot }}{\sum^n_{i=1}\sum^n_{j=1} x_{ij}}}
}

where:

\enumerate{
  \item `cku`: Conditional kappa (user's).
  \item `ua_i`: user accuracy.
  \item `x_ii`: diagonal element of the matrix.
  \item `x_.j`: sum with respect to j (rows).
  \item `x_i.`: sum with respect to i (columns).
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$cku(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}
}
\if{html}{\out{</div>}}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$cku(2)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-ckp"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-ckp}{}}}
\subsection{Method \code{ckp()}}{
Conditional Kappa will identify the degree of agreement between the two raters for each possible category.


\deqn{
ckp=\frac{pa_i-\frac{\sum^n_{j=1} x_{ \cdot j }}{\sum^n_{i=1}\sum^n_{j=1} x_{ij}}}{1-\frac{\sum^n_{j=1} x_{\cdot j }}{\sum^n_{i=1}\sum^n_{j=1} x_{ij}}}
}

where:

\enumerate{
  \item `ckp`: Conditional kappa (producer's).
  \item `pa_i`: producer accuracy.
  \item `x_ii`: diagonal element of the matrix.
  \item `x_.j`: sum with respect to j (rows).
  \item `x_i.`: sum with respect to i (columns).
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$ckp(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}
}
\if{html}{\out{</div>}}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$ckp(2)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-mcku"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-mcku}{}}}
\subsection{Method \code{mcku()}}{
Modified kappa index for the user


\deqn{
mcku=\frac{ua_i-\frac{1}{\sqrt{card(p)}}}{1-\frac{1}{\sqrt{card(p)}}}
}

where:

\enumerate{
  \item `mcku`: Modified conditional kappa (user's).
  \item `ua_i`: user accuracy.
  \item `card(p)`: number of elements of the matrix, cardinal of the matrix.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$mcku(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}
}
\if{html}{\out{</div>}}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$mcku(2)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-mckp"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-mckp}{}}}
\subsection{Method \code{mckp()}}{
Modified kappa index for the producer


\deqn{
mckp=\frac{pa_i-\frac{1}{\sqrt{card(p)}}}{1-\frac{1}{\sqrt{card(p)}}}
}

where:

\enumerate{
  \item `mckp`: Modified conditional kappa (producer's).
  \item `pa_i`: producer accuracy.
  \item `card(p)`: number of elements of the matrix, cardinal of the matrix.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$mckp(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}
}
\if{html}{\out{</div>}}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$mckp(2)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-ecnu"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-ecnu}{}}}
\subsection{Method \code{ecnu()}}{
Relative entropy is a quantity that measures the difference between two maps.


\deqn{
H(A)=-\sum^n_{j=1}( (\frac{\sum^n_{i=1} x_{i \cdot}}{\sum^n_{i,j=1} x_{ij} }) \cdot \log(\frac{\sum^n_{i=1} x_{i \cdot}}{\sum^n_{i,j=1} x_{ij} }) ) \\
H(A|b_i)=-\sum^n_{j=1}( (\frac{ x_{ij}}{\sum^n_{j=1} x_{\cdot j} }) \cdot \log (\frac{x_{ij}}{\sum^n_{j=1} x_{\cdot j}}) ) \\
ecnu= \frac{H(A)-H(A|b_i)}{H(A)}
}

where:

\enumerate{
  \item `ecnu`: Relative change of entropy given a category on map.
  \item `H(A)`: the entropy of the map.
  \item `x_.j`: sum with respect to j (rows).
  \item `x_i.`: sum with respect to i (columns).
  \item `H(A|b_i)`: Entropy of map A knowing that the location corresponding to map B is in class b_i.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$ecnu(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}
}
\if{html}{\out{</div>}}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$ecnu(2)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-ecnp"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-ecnp}{}}}
\subsection{Method \code{ecnp()}}{
Relative entropy is a quantity that measures the difference between two ground truthing.


\deqn{
H(B)=-\sum^n_{i=1}( (\frac{\sum^n_{j=1} x_{\cdot j}}{\sum^n_{i,j=1} x_{ij} }) \cdot \log (\frac{\sum^n_{j=1} x_{\cdot j}}{\sum^n_{i,j=1} x_{ij} }) ) \\
H(B|a_j)=-\sum^n_{j=1}( (\frac{ x_{ij}}{\sum^n_{i=1} x_{i \cdot} }) \cdot \log (\frac{x_{ij}}{\sum^n_{i=1} x_{i \cdot}}) ) \\
ecnp= \frac{H(B)-H(B|a_j)}{H(B)}
}

where:

\enumerate{
  \item `ecnp`: Relative change of entropy given a category on ground truthing.
  \item `H(B)`: the entropy of the map.
  \item `x_.j`: sum with respect to j (rows).
  \item `x_i.`: sum with respect to i (columns).
  \item `H(B|a_j)`: Entropy of map B knowing that the location corresponding to map A is in class a_j.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$ecnp(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate}
}
\if{html}{\out{</div>}}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(36,5,4,7,2,2,6,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$ecnp(2)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-aau"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-aau}{}}}
\subsection{Method \code{aau()}}{
The average accuracy is an average of the accuracy of individual categories. Because the individual categories can be the user's or the producer's accuracy, it can be computed in both ways accordingly.


\deqn{
aau=\frac{1}{\sqrt{card(p)}} \sum^n_{i=1} \frac{x_{ii}}{\sum_{j=1}^n x_{ij}}
}

where:

\enumerate{
  \item `aau`: Average accuracy from user's perspective
  \item `card(p)`: number of elements of the matrix, cardinal of the matrix.
  \item `x_.j`: sum with respect to j (rows).
  \item `x_ii`: diagonal element of the matrix.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$aau()}\if{html}{\out{</div>}}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$aau()
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-Normalize"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-Normalize}{}}}
\subsection{Method \code{Normalize()}}{
An iterative process is carried out where each element is divided by the total of the sum of its row, thus obtaining new values. In the next iteration, all the elements are added by columns and each element is divided by the total of its column and they obtain new values, and so on.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$Normalize(n = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n}}{Iteration}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Normalized matrix (Class MatCon)
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$Normalize()
p$Normalize(1000)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-aap"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-aap}{}}}
\subsection{Method \code{aap()}}{
The average accuracy is an average of the accuracy of individual categories. Because the individual categories can be the user's or the producer's accuracy, it can be computed in both ways accordingly.


\deqn{
aap=\frac{1}{\sqrt{card(p)}} \sum^n_{i=1} \frac{x_{ii}}{\sum_{j=1}^n x_{ji}}
}

where:

\enumerate{
  \item `aap`: Average accuracy from producer's perspective
  \item `card(p)`: number of elements of the matrix, cardinal of the matrix.
  \item `x_.j`: sum with respect to j (rows).
  \item `x_ii`: diagonal element of the matrix.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$aap()}\if{html}{\out{</div>}}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(36,1,0,0,2,0,0,1,20),nrow=3,ncol=3)
p<-MatCon$new(A)
p$aap()
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-clone"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
