% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MatCon.R
\name{MatCon}
\alias{MatCon}
\title{Confusion matrix}
\value{
Object of class MatCon or an error if a matrix is not entered.
}
\description{
Using the confusion matrix, various indices are calculated.
}
\details{
List of possible errors:
\itemize{
 \item \code{Error type 1}: Non-square matrix.
 \item \code{Error type 2}: Single element matrix.
 \item \code{Error type 3}: negative values.
 \item \code{Error type 4}: Sum of elements 0.
 \item \code{Error type 5}: Sum of rows 0.
 \item \code{Error type 6}: Sum of columns 0.
 \item \code{Error type 7}: It is not a matrix.
}
}
\examples{
A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
mc <- MatCon$new (A,ID=5,Date="27-10-2023",Source="Congalton&Green, 2008")


## ------------------------------------------------
## Method `MatCon$new`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
mc <- MatCon$new (A,ID=5,Date="27-10-2023",Source="Congalton&Green, 2008")


## ------------------------------------------------
## Method `MatCon$OverallAcc`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$OverallAcc()


## ------------------------------------------------
## Method `MatCon$UserAcc`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$UserAcc()


## ------------------------------------------------
## Method `MatCon$UserAcc_i`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$UserAcc_i(2)


## ------------------------------------------------
## Method `MatCon$ProdAcc`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$ProdAcc()


## ------------------------------------------------
## Method `MatCon$ProdAcc_i`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$ProdAcc_i(1)


## ------------------------------------------------
## Method `MatCon$AvUserProdAcc_i`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$AvUserProdAcc_i(2)


## ------------------------------------------------
## Method `MatCon$Sucess`
## ------------------------------------------------

A<-matrix(c(0.3,0.02,0.01,0.12,0.19,0.03,0.02,0.01,0.3),nrow=3,ncol=3)
p<-MatCon$new(A,Source="Labatut&Cherifi, 2011")
p$Sucess()


## ------------------------------------------------
## Method `MatCon$Sucess_i`
## ------------------------------------------------

A<-matrix(c(0.3,0.02,0.01,0.12,0.19,0.03,0.02,0.01,0.3),nrow=3,ncol=3)
p<-MatCon$new(A,Source="Labatut&Cherifi, 2011")
p$Sucess_i(2)


## ------------------------------------------------
## Method `MatCon$AvHelldenAcc_i`
## ------------------------------------------------

A <- matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,39,7,1,1,0,6,25,1,1,0,0,1,6),
nrow=5,ncol=5)
p<-MatCon$new(A,Source="Rosenfield&Fitzpatrick, 1986")
p$AvHelldenAcc_i(2)


## ------------------------------------------------
## Method `MatCon$ShortAcc_i`
## ------------------------------------------------

A <- matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,39,7,1,1,0,6,25,1,1,0,0,1,6),
nrow=5,ncol=5)
p<-MatCon$new(A,Source="Rosenfield&Fitzpatrick-Lins, 1986")
p$ShortAcc_i(2)


## ------------------------------------------------
## Method `MatCon$UserKappa_i`
## ------------------------------------------------

A<-matrix(c(73,13,5,1,0,21,32,13,3,0,16,39,35,29,13,3,5,7,28,48,1,0,2,3,17),
nrow=5,ncol=5)
p<-MatCon$new(A,Source="Næsset, 1996")
p$UserKappa_i(2)


## ------------------------------------------------
## Method `MatCon$ProdKappa_i`
## ------------------------------------------------

A<-matrix(c(73,13,5,1,0,21,32,13,3,0,16,39,35,29,13,3,5,7,28,48,1,0,2,3,17),
nrow=5,ncol=5)
p<-MatCon$new(A,Source="Næsset, 1996")
p$ProdKappa_i(2)


## ------------------------------------------------
## Method `MatCon$ModKappa`
## ------------------------------------------------

A<-matrix(c(317,61,2,35,23,120,4,29,0,0,60,0,0,0,0,8),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Foody, 1992")
p$ModKappa()


## ------------------------------------------------
## Method `MatCon$ModKappaUser_i`
## ------------------------------------------------

A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Liu et al., 2007")
p$ModKappaUser_i(2)


## ------------------------------------------------
## Method `MatCon$ModKappaProd_i`
## ------------------------------------------------

A<-matrix(c(317,61,2,35,23,120,4,29,0,0,60,0,0,0,0,8),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Liu et al., 2007")
p$ModKappaProd_i(2)


## ------------------------------------------------
## Method `MatCon$EntropUser_i`
## ------------------------------------------------

A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Liu et al., 2007")
p$EntropUser_i(1)


## ------------------------------------------------
## Method `MatCon$EntropProd_i`
## ------------------------------------------------

A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Liu et al., 2007")
p$EntropProd_i(2)


## ------------------------------------------------
## Method `MatCon$AvUserAcc`
## ------------------------------------------------

A<-matrix(c(352,43,89,203),nrow=2,ncol=2)
p<-MatCon$new(A,Source="Tung&LeDrew, 1988")
p$AvUserAcc()


## ------------------------------------------------
## Method `MatCon$AvProdAcc`
## ------------------------------------------------

A<-matrix(c(352,43,89,203),nrow=2,ncol=2)
p<-MatCon$new(A,Source="Tung&LeDrew, 1988")
p$AvProdAcc()


## ------------------------------------------------
## Method `MatCon$AvUserProdAcc`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$AvUserProdAcc()


## ------------------------------------------------
## Method `MatCon$AvHelldenAcc`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$AvHelldenAcc()


## ------------------------------------------------
## Method `MatCon$AvShortAcc`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$AvShortAcc()


## ------------------------------------------------
## Method `MatCon$CombUserAcc`
## ------------------------------------------------

A<-matrix(c(352,43,89,203),nrow=2,ncol=2)
p<-MatCon$new(A,Source="Tung&LeDrew, 1988")
p$CombUserAcc()


## ------------------------------------------------
## Method `MatCon$CombProdAcc`
## ------------------------------------------------

A<-matrix(c(352,43,89,203),nrow=2,ncol=2)
p<-MatCon$new(A,Source="Tung&LeDrew, 1988")
p$CombProdAcc()


## ------------------------------------------------
## Method `MatCon$CombUserProdAcc`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$CombUserProdAcc()


## ------------------------------------------------
## Method `MatCon$Kappa`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$Kappa()


## ------------------------------------------------
## Method `MatCon$Entrop`
## ------------------------------------------------

A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Liu et al.,2007")
p$Entrop()


## ------------------------------------------------
## Method `MatCon$NormEntropUser`
## ------------------------------------------------

A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Liu et al., 2007")
p$NormEntropUser()


## ------------------------------------------------
## Method `MatCon$NormEntropProd`
## ------------------------------------------------

A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Liu et al., 2007")
p$NormEntropProd()


## ------------------------------------------------
## Method `MatCon$AvNormEntrop`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$AvNormEntrop()


## ------------------------------------------------
## Method `MatCon$GeomAvNormEntrop`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$GeomAvNormEntrop()


## ------------------------------------------------
## Method `MatCon$AvMaxNormEntrop`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$AvMaxNormEntrop()


## ------------------------------------------------
## Method `MatCon$Tau`
## ------------------------------------------------

A<-matrix(c(238051,7,132,0,0,24,9,2,189,1,4086,188,0,4,16,45,1,0,939,5082,
51817,0,34,500,1867,325,17,0,0,5,11148,1618,78,0,0,0,0,48,4,834,2853,340,
32,0,197,5,151,119,135,726,6774,75,1,553,0,105,601,110,174,155,8257,8,0,
29,36,280,0,0,6,5,2993,0,115,2,0,4,124,595,0,0,4374),nrow=9,ncol=9)
p<-MatCon$new(A,Source="Muñoz, 2016")
p$Tau()


## ------------------------------------------------
## Method `MatCon$UserProdAcc`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green,2008")
p$UserProdAcc()


## ------------------------------------------------
## Method `MatCon$DetailedKappa`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green,2008")
p$DetailedKappa()


## ------------------------------------------------
## Method `MatCon$DetailedCondKappa`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green,2008")
p$DetailedCondKappa ()


## ------------------------------------------------
## Method `MatCon$QES`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$QES(TI=1, SF=6)


## ------------------------------------------------
## Method `MatCon$MTypify`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A, Source="Congalton&Green, 2008")
p$MTypify(RaR=5)

## ------------------------------------------------
## Method `MatCon$AllParameters`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$AllParameters()


## ------------------------------------------------
## Method `MatCon$MBootStrap`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A, Source="Congalton&Green, 2008")
p$MBootStrap(2)


## ------------------------------------------------
## Method `MatCon$MNormalize`
## ------------------------------------------------

A<-matrix(c(238051,7,132,0,0,24,9,2,189,1,4086,188,0,4,16,45,1,0,939,5082,
51817,0,34,500,1867,325,17,0,0,5,11148,1618,78,0,0,0,0,48,4,834,2853,340,
32,0,197,5,151,119,135,726,6774,75,1,553,0,105,601,110,174,155,8257,8,0,
29,36,280,0,0,6,5,2993,0,115,2,0,4,124,595,0,0,4374),nrow=9,ncol=9)
p<-MatCon$new(A,Source="Muñoz, 2016")
p$MNormalize()$values


## ------------------------------------------------
## Method `MatCon$MPseudoZeroes`
## ------------------------------------------------

A<-matrix(c(238051,7,132,0,0,24,9,2,189,1,4086,188,0,4,16,45,1,0,939,5082,
51817,0,34,500,1867,325,17,0,0,5,11148,1618,78,0,0,0,0,48,4,834,2853,340,
32,0,197,5,151,119,135,726,6774,75,1,553,0,105,601,110,174,155,8257,8,0,
29,36,280,0,0,6,5,2993,0,115,2,0,4,124,595,0,0,4374),nrow=9,ncol=9)
p<-MatCon$new(A,Source="Muñoz, 2016")
p$MPseudoZeroes()$values


## ------------------------------------------------
## Method `MatCon$DetailedWTau`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
WV <-matrix(c(0.4, 0.1, 0.4, 0.1), ncol=4)
p<-MatCon$new(A,Source="Congalton&Green,2008")
p$DetailedWTau(WV)


## ------------------------------------------------
## Method `MatCon$DetailedWKappa`
## ------------------------------------------------

A <- A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
WM<- t(matrix(c(1,0,0.67,1,0,1,0,0,1,0,1,1,0.91,0,0.61,1), nrow = 4, ncol=4))
p<-MatCon$new(A)
p$DetailedWKappa(WM)


## ------------------------------------------------
## Method `MatCon$UserProdAcc_W`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
WM<- t(matrix(c(1,0,0.67,1,0,1,0,0,1,0,1,1,0.91,0,0.61,1), nrow = 4, ncol=4))
p$UserProdAcc_W(WM)

}
\references{
\insertRef{congalton2008}{PaolaR6Nuevo}

\insertRef{liu2007}{PaolaR6Nuevo}

\insertRef{koukoulas2001}{PaolaR6Nuevo}

\insertRef{turk2002}{PaolaR6Nuevo}

\insertRef{hellden1980}{PaolaR6Nuevo}

\insertRef{rosenfield1986}{PaolaR6Nuevo}

\insertRef{short1982}{PaolaR6Nuevo}

\insertRef{finn1993}{PaolaR6Nuevo}

\insertRef{tung1988}{PaolaR6Nuevo}

\insertRef{cohen1960}{PaolaR6Nuevo}

\insertRef{strehl2002}{PaolaR6Nuevo}

\insertRef{ghosh2002}{PaolaR6Nuevo}

\insertRef{strehl2002relationship}{PaolaR6Nuevo}

\insertRef{book}{PaolaR6Nuevo}

\insertRef{pontius2014}{PaolaR6Nuevo}

\insertRef{ariza2011}{PaolaR6Nuevo}

\insertRef{fienberg1970}{PaolaR6Nuevo}

\insertRef{munoz2016}{PaolaR6Nuevo}

\insertRef{foody1992}{PaolaR6Nuevo}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-MatCon-new}{\code{MatCon$new()}}
\item \href{#method-MatCon-OverallAcc}{\code{MatCon$OverallAcc()}}
\item \href{#method-MatCon-UserAcc}{\code{MatCon$UserAcc()}}
\item \href{#method-MatCon-UserAcc_i}{\code{MatCon$UserAcc_i()}}
\item \href{#method-MatCon-ProdAcc}{\code{MatCon$ProdAcc()}}
\item \href{#method-MatCon-ProdAcc_i}{\code{MatCon$ProdAcc_i()}}
\item \href{#method-MatCon-AvUserProdAcc_i}{\code{MatCon$AvUserProdAcc_i()}}
\item \href{#method-MatCon-Sucess}{\code{MatCon$Sucess()}}
\item \href{#method-MatCon-Sucess_i}{\code{MatCon$Sucess_i()}}
\item \href{#method-MatCon-AvHelldenAcc_i}{\code{MatCon$AvHelldenAcc_i()}}
\item \href{#method-MatCon-ShortAcc_i}{\code{MatCon$ShortAcc_i()}}
\item \href{#method-MatCon-UserKappa_i}{\code{MatCon$UserKappa_i()}}
\item \href{#method-MatCon-ProdKappa_i}{\code{MatCon$ProdKappa_i()}}
\item \href{#method-MatCon-ModKappa}{\code{MatCon$ModKappa()}}
\item \href{#method-MatCon-ModKappaUser_i}{\code{MatCon$ModKappaUser_i()}}
\item \href{#method-MatCon-ModKappaProd_i}{\code{MatCon$ModKappaProd_i()}}
\item \href{#method-MatCon-EntropUser_i}{\code{MatCon$EntropUser_i()}}
\item \href{#method-MatCon-EntropProd_i}{\code{MatCon$EntropProd_i()}}
\item \href{#method-MatCon-AvUserAcc}{\code{MatCon$AvUserAcc()}}
\item \href{#method-MatCon-AvProdAcc}{\code{MatCon$AvProdAcc()}}
\item \href{#method-MatCon-AvUserProdAcc}{\code{MatCon$AvUserProdAcc()}}
\item \href{#method-MatCon-AvHelldenAcc}{\code{MatCon$AvHelldenAcc()}}
\item \href{#method-MatCon-AvShortAcc}{\code{MatCon$AvShortAcc()}}
\item \href{#method-MatCon-CombUserAcc}{\code{MatCon$CombUserAcc()}}
\item \href{#method-MatCon-CombProdAcc}{\code{MatCon$CombProdAcc()}}
\item \href{#method-MatCon-CombUserProdAcc}{\code{MatCon$CombUserProdAcc()}}
\item \href{#method-MatCon-Kappa}{\code{MatCon$Kappa()}}
\item \href{#method-MatCon-Entrop}{\code{MatCon$Entrop()}}
\item \href{#method-MatCon-NormEntropUser}{\code{MatCon$NormEntropUser()}}
\item \href{#method-MatCon-NormEntropProd}{\code{MatCon$NormEntropProd()}}
\item \href{#method-MatCon-AvNormEntrop}{\code{MatCon$AvNormEntrop()}}
\item \href{#method-MatCon-GeomAvNormEntrop}{\code{MatCon$GeomAvNormEntrop()}}
\item \href{#method-MatCon-AvMaxNormEntrop}{\code{MatCon$AvMaxNormEntrop()}}
\item \href{#method-MatCon-Tau}{\code{MatCon$Tau()}}
\item \href{#method-MatCon-UserProdAcc}{\code{MatCon$UserProdAcc()}}
\item \href{#method-MatCon-DetailedKappa}{\code{MatCon$DetailedKappa()}}
\item \href{#method-MatCon-DetailedCondKappa}{\code{MatCon$DetailedCondKappa()}}
\item \href{#method-MatCon-QES}{\code{MatCon$QES()}}
\item \href{#method-MatCon-MTypify}{\code{MatCon$MTypify()}}
\item \href{#method-MatCon-AllParameters}{\code{MatCon$AllParameters()}}
\item \href{#method-MatCon-MBootStrap}{\code{MatCon$MBootStrap()}}
\item \href{#method-MatCon-MNormalize}{\code{MatCon$MNormalize()}}
\item \href{#method-MatCon-MPseudoZeroes}{\code{MatCon$MPseudoZeroes()}}
\item \href{#method-MatCon-DetailedWTau}{\code{MatCon$DetailedWTau()}}
\item \href{#method-MatCon-DetailedWKappa}{\code{MatCon$DetailedWKappa()}}
\item \href{#method-MatCon-UserProdAcc_W}{\code{MatCon$UserProdAcc_W()}}
\item \href{#method-MatCon-clone}{\code{MatCon$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-new"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-new}{}}}
\subsection{Method \code{new()}}{
Public method to create an instance of the MatCon class. When creating it, values must be given to the matrix. The optional possibility of adding metadata to the matrix is offered.
The creation includes a series of checks on the data that, if not met, give coded error messages. The values of the matrix must be organized in such a way that the columns represent the categories in the reference and the rows represent the categories in the product being evaluated.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$new(values, ID = NULL, Date = NULL, Source = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{values}}{Confusion matrix}

\item{\code{ID}}{Identifier. By default, the date in YYYYMMDD format will be taken as the ID.}

\item{\code{Date}}{Date provided by the user. By default the date provided by the system will be taken.}

\item{\code{Source}}{Indicates where the matrix comes from (article, project, etc.). By default is NULL.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Object of class MatCon or an error if a matrix isn't entered.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
mc <- MatCon$new (A,ID=5,Date="27-10-2023",Source="Congalton&Green, 2008")

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-OverallAcc"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-OverallAcc}{}}}
\subsection{Method \code{OverallAcc()}}{
Public method to calculate the global index called Overall accuracy. The Overall accuracy for a particular classified image/map is then calculated by dividing the sum of the entries that form the major diagonal (i.e., the number of correct classifications) by the total number of samples taken. The method also offers the variance. The reference \insertCite{congalton2008}{PaolaR6Nuevo} is followed for the computations.


The mathematical expression is:

\deqn{
OverallAcc = \frac{\sum_{i=1}^{n} x_{ii}}{\sum_{i, j=1}^{n} x_{ij}}
}

\deqn{
\sigma^2_{OverallAcc}=\frac{OverallAcc \cdot (1-OverallAcc)}{N}
}
Where:
\enumerate{
  \item OverallAcc: overall accuracy.
  \item x_ii: diagonal element of the matrix.
  \item x_ij: element of the matrix.
  \item N: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$OverallAcc()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Overall accuracy and variance as a list.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$OverallAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-UserAcc"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-UserAcc}{}}}
\subsection{Method \code{UserAcc()}}{
Public method for deriving a class index called user's accuracy. The user's accuracy for the class i of thematic map is calculated by dividing the value in the diagonal of class i by the sum of all values in the row of the class i. The method also offers the variance. The reference \insertCite{congalton2008}{PaolaR6Nuevo} is followed for the computations.


The mathematical expression is:
\deqn{
UserAcc=\frac{x_{ii}}{\sum_{j=1}^n x_{ij}}
}
 \deqn{
\sigma^2_{UserAcc}=\frac{UserAcc \cdot (1-UserAcc)}{N}
}
where:

\enumerate{
  \item UserAcc: user accuracy.
  \item x_ii: diagonal element of the matrix.
  \item x_ij: element of the matrix.
  \item N: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$UserAcc()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list with a vector of values for the user's accuracy index of all classes and another vector with their variances.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$UserAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-UserAcc_i"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-UserAcc_i}{}}}
\subsection{Method \code{UserAcc_i()}}{
Public method where the user's accuracy index is defined for a specific class i. The user precision for class i of the thematic map is calculated by dividing the value on the diagonal of class i by the sum of all values in the row of class i. The method also offers variance. The reference \insertCite{congalton2008}{PaolaR6Nuevo} is followed for the calculations.


\deqn{
UserAcc_{i}=\frac{x_{ii}}{\sum_{j=1}^n x_{ij}}
}
\deqn{
\sigma^2_{UserAcc_i}=\frac{UserAcc_i \cdot (1-UserAcc_i)}{N}
}


where:

\enumerate{
  \item UserAcc_i: user accuracy index for class i.
  \item x_ii: diagonal element of the matrix.
  \item x_ij: element of the matrix.
  \item N: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$UserAcc_i(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{User class to evaluate}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of the user's accuracy index values for class i and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$UserAcc_i(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-ProdAcc"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-ProdAcc}{}}}
\subsection{Method \code{ProdAcc()}}{
Public method for deriving a class index called producer's accuracy. The producer's accuracy for the class i of thematic map is calculated by dividing the value in the diagonal of class i by the sum of all values in the column of the class i. The method also offers the variance. The reference \insertCite{congalton2008}{PaolaR6Nuevo} if followed for the computations.


\deqn{
ProdAcc=\frac{x_{jj}}{\sum_{j=1}^n x_{ij}}
}
\deqn{
\sigma^2_{ProdAcc}=\frac{ProdAcc \cdot (1-ProdAcc)}{N}
}
where:

\enumerate{
  \item ProdAcc: producer accuracy.
  \item x_jj: diagonal element of the matrix.
  \item x_ij: element of the matrix.
  \item N: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$ProdAcc()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list with a vector of values for the producer's accuracy index of all classes and another vector with their variances.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$ProdAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-ProdAcc_i"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-ProdAcc_i}{}}}
\subsection{Method \code{ProdAcc_i()}}{
Public method where the producer's accuracy index is defined for a specific class i. The user precision for class i of the thematic map is calculated by dividing the value on the diagonal of class i by the sum of all values in the column of class i. The method also offers variance. The reference \insertCite{congalton2008}{PaolaR6Nuevo} is followed for the calculations.


\deqn{
ProdAcc_{i}=\frac{x_{jj}}{\sum_{j=1}^n x_{ij}}
}
\deqn{
\sigma^2_{ProdAcc_i}=\frac{ProdAcc_i \cdot (1-ProdAcc_i)}{N}
}

where:

\enumerate{
  \item ProdAcc_i: producer accuracy index for class i.
  \item x_jj: diagonal element of the matrix.
  \item x_ij: element of the matrix.
  \item N: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$ProdAcc_i(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Producer class to evaluate.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of the producer's accuracy index values for class i and its variance
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$ProdAcc_i(1)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-AvUserProdAcc_i"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-AvUserProdAcc_i}{}}}
\subsection{Method \code{AvUserProdAcc_i()}}{
Public method that provides the average of the accuracy rates of the user and producer of a specific class. The method also offers variance. The reference \insertCite{liu2007}{PaolaR6Nuevo} is followed for the calculations.


The mathematical expression is:
 \deqn{
AvUserProdAcc_i=\frac{UserAcc_i+ProdAcc_i}{2}
}
\deqn{
\sigma^2_{AvUserProdAcc_i}=\frac{AvUserProdAcc_i \cdot (1-AvUserProdAcc_i)}{N}
}
where:

\enumerate{
  \item AvUserProdAcc_i: average of user's and producer's accuracy.
  \item UserAcc_i: user accuracy index for class i.
  \item ProdAcc_i: producer accuracy index for class i.
  \item N: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$AvUserProdAcc_i(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with average of user's and producer's accuracy and its variance for class i.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$AvUserProdAcc_i(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-Sucess"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-Sucess}{}}}
\subsection{Method \code{Sucess()}}{
Public method that provides the Classification Success Index (CSI) applies to all class and gives an overall estimation of classification effectiveness. The reference \insertCite{koukoulas2001,turk2002}{PaolaR6Nuevo} is followed for the calculations.


The mathematical expression is:
 \deqn{
Sucess=1-(1-AvUserAcc+1-AvProdAcc)=AvUserAcc+AvProdAcc-1
}
 \deqn{
VarSucess=\frac{Sucess \cdot (1-Sucess)}{N}
}

where:

\enumerate{
  \item Sucess: classification succes index.
  \item AvUserAcc: average accuracy from user's perspective.
  \item AvProdAcc: average accuracy from producer's perspective.
  \item N: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$Sucess()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list with the classification success index and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(0.3,0.02,0.01,0.12,0.19,0.03,0.02,0.01,0.3),nrow=3,ncol=3)
p<-MatCon$new(A,Source="Labatut&Cherifi, 2011")
p$Sucess()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-Sucess_i"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-Sucess_i}{}}}
\subsection{Method \code{Sucess_i()}}{
Public method that provides the Individual Classification Success Index (ICSI) applies to the classification effectiveness for one particular class of interest. The reference \insertCite{koukoulas2001,turk2002}{PaolaR6Nuevo} is followed for the calculations.


The mathematical expression is:
 \deqn{
Sucess_i=1-(1-UserAcc_i+1-ProdAcc_i)=UserAcc_i+ProdAcc_i-1
}

\deqn{
\sigma^2_{Sucess_i}=\frac{Sucess_i \cdot (1-Sucess_i)}{N}
}

where:

\enumerate{
  \item Sucess_i: individual classification success index.
  \item UserAcc_i: user accuracy index for class i.
  \item ProdAcc_i: producer accuracy index for class i.
  \item N: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$Sucess_i(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with the individual classification success index and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(0.3,0.02,0.01,0.12,0.19,0.03,0.02,0.01,0.3),nrow=3,ncol=3)
p<-MatCon$new(A,Source="Labatut&Cherifi, 2011")
p$Sucess_i(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-AvHelldenAcc_i"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-AvHelldenAcc_i}{}}}
\subsection{Method \code{AvHelldenAcc_i()}}{
Public method that provides the Hellden' average accuracy, denotes for the probability that a randomly chosen point of a specific class on the map has a correspondence of the same class in the same position in the field and that a randomly chosen point in the field of the same class has a correspondence of the same class in the same position on the map.The method also offers variance. The reference \insertCite{hellden1980,rosenfield1986}{PaolaR6Nuevo} is followed for the calculations.


\deqn{
AvHelldenAcc_i=\frac{2}{\frac{1}{UserAcc_i}+\frac{1}{ProdAcc_i}}
}
\deqn{
\sigma^2_{AvHelldenAcc_i}=\frac{AvHelldenAcc_i \cdot (1-AvHelldenAcc_i)}{N}
}
where:

\enumerate{
  \item AvHelldenAcc_i: Hellden's mean accuracy.
  \item UserAcc_i: user accuracy index for class i.
  \item ProdAcc_i: producer accuracy index for class i.
  \item N: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$AvHelldenAcc_i(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with Hellden's mean accuracy and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A <- matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,39,7,1,1,0,6,25,1,1,0,0,1,6),
nrow=5,ncol=5)
p<-MatCon$new(A,Source="Rosenfield&Fitzpatrick, 1986")
p$AvHelldenAcc_i(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-ShortAcc_i"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-ShortAcc_i}{}}}
\subsection{Method \code{ShortAcc_i()}}{
Public method that provides Short's mapping accuracy for each class is stated as the number of correctly classified pixels (equal to the total in the correctly classified area) in terms of all pixels affected by its classification (equal to this total in the displayed area as well as the pixels involved in errors of commission and omission). The method also offers variance. The reference \insertCite{rosenfield1986,short1982}{PaolaR6Nuevo} is followed for the calculations.


\deqn{
ShortAcc_i=\frac{x_{ii}}{\sum^n_{j=1} x_{+ j}+\sum^n_{i=1} x_{i +}-x_{ii}}
}
\deqn{
\sigma^2_{ShortAcc_i}=\frac{ShortAcc_i \cdot (1-ShortAcc_i)}{N}
}
where:

\enumerate{
  \item ShortAcc_i: Short's mapping accuracy
  \item x_ii: diagonal element of the matrix.
  \item x_j+: sum of all elements in rows j.
  \item x_+j: sum of all elements in column j.
  \item N: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$ShortAcc_i(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with Short's mapping accuracy and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A <- matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,39,7,1,1,0,6,25,1,1,0,0,1,6),
nrow=5,ncol=5)
p<-MatCon$new(A,Source="Rosenfield&Fitzpatrick-Lins, 1986")
p$ShortAcc_i(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-UserKappa_i"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-UserKappa_i}{}}}
\subsection{Method \code{UserKappa_i()}}{
Public method that evaluates the kappa coefficient from the user's perspective, for a specific class i. The method also offers variance. The reference \insertCite{rosenfield1986}{PaolaR6Nuevo} is followed for the calculations.


\deqn{
UserKappa_i=\frac{UserAcc_i-\frac{\sum^n_{i=1} x_{i + }}{\sum^n_{i=1}\sum^n_{j=1} x_{ij}}}{1-\frac{\sum^n_{i=1} x_{i + }}{\sum^n_{i=1}\sum^n_{j=1} x_{ij}}}
}
#'  \deqn{
\sigma^2_{UserKappa_i}=\frac{UserKappa_i \cdot (1-UserKappa_i)}{N}
}
where:

\enumerate{
  \item UserKappa_i: coefficient kappa (user's).
  \item UserAcc_i: user accuracy index for class i.
  \item x_ii: diagonal element of the matrix.
  \item x_j+: sum of all elements in rows j.
  \item x_+j: sum of all elements in column j.
  \item N: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$UserKappa_i(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with coefficient kappa (user's) and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(73,13,5,1,0,21,32,13,3,0,16,39,35,29,13,3,5,7,28,48,1,0,2,3,17),
nrow=5,ncol=5)
p<-MatCon$new(A,Source="Næsset, 1996")
p$UserKappa_i(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-ProdKappa_i"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-ProdKappa_i}{}}}
\subsection{Method \code{ProdKappa_i()}}{
Public method that evaluates the kappa coefficient from the producer's perspective, for a specific class i. The method also offers variance. The reference \insertCite{rosenfield1986}{PaolaR6Nuevo} is followed for the calculations.


\deqn{
ProdKappa_i=\frac{ProdAcc_i-\frac{\sum^n_{j=1} x_{ + j }}{\sum^n_{i=1}\sum^n_{j=1} x_{ij}}}{1-\frac{\sum^n_{j=1} x_{+ j }}{\sum^n_{i=1}\sum^n_{j=1} x_{ij}}}
}
 \deqn{
\sigma^2_{ProdKappa_i}=\frac{ProdKappa_i \cdot (1- ProdKappa_i)}{N}
}
where:

\enumerate{
  \item ProdKappa_i: coefficient kappa (producer's).
  \item ProdAcc_i: producer accuracy index for class i.
  \item x_ii: diagonal element of the matrix.
  \item x_j+: sum of all elements in rows j.
  \item x_+j: sum of all elements in column j.
  \item N: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$ProdKappa_i(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with coefficient kappa (producer's) and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(73,13,5,1,0,21,32,13,3,0,16,39,35,29,13,3,5,7,28,48,1,0,2,3,17),
nrow=5,ncol=5)
p<-MatCon$new(A,Source="Næsset, 1996")
p$ProdKappa_i(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-ModKappa"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-ModKappa}{}}}
\subsection{Method \code{ModKappa()}}{
Public method that provides the overall modified kappa coefficient. The method also offers variance. The reference \insertCite{stehman1997,foody1992}{PaolaR6Nuevo} is followed for the calculations.


\deqn{
ModKappa=\frac{OverallAcc-\frac{1}{\sqrt{M}}}{1-\frac{1}{\sqrt{M}}}
}
\deqn{
\sigma^2_{ModKappa}=\frac{ModKappa \cdot (1- ModKappa)}{N}
}
where:

\enumerate{
  \item ModKappa: modified coefficient kappa.
  \item OverallAcc: overall accuracy.
  \item M: number of elements of the matrix.
  \item N: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$ModKappa(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with modified coefficient kappa and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(317,61,2,35,23,120,4,29,0,0,60,0,0,0,0,8),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Foody, 1992")
p$ModKappa()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-ModKappaUser_i"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-ModKappaUser_i}{}}}
\subsection{Method \code{ModKappaUser_i()}}{
Public method, derived from the general modified kappa coefficient, which provides the modified coefficient kappa for the user. The method also offers variance. The reference \insertCite{stehman1997,foody1992}{PaolaR6Nuevo} is followed for the calculations.


\deqn{
ModKappaUser_i=\frac{UserAcc_i-\frac{1}{\sqrt{M}}}{1-\frac{1}{\sqrt{M}}}
}
\deqn{
\sigma^2_{ModKappaUser_i}=\frac{ModKappaUser_i \cdot (1- ModKappaUser_i)}{N}
}
where:

\enumerate{
  \item ModKappaUser_i: modified coefficient kappa (user's).
  \item UserAcc_i: user accuracy index for class i.
  \item M: number of elements of the matrix.
  \item N: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$ModKappaUser_i(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with modified coefficient kappa (user's) and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Liu et al., 2007")
p$ModKappaUser_i(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-ModKappaProd_i"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-ModKappaProd_i}{}}}
\subsection{Method \code{ModKappaProd_i()}}{
Public method, derived from the general modified kappa coefficient, which provides the modified coefficient kappa for the producer. The method also offers variance. The reference \insertCite{stehman1997,foody1992}{PaolaR6Nuevo} is followed for the calculations.


\deqn{
ModKappaProd_i=\frac{ProdAcc_i-\frac{1}{\sqrt{M}}}{1-\frac{1}{\sqrt{M}}}
}
\deqn{
\sigma^2_{ModKappaProd_i}=\frac{ModKappaProd_i \cdot (1- ModKappaProd_i)}{N}
}
where:

\enumerate{
  \item ModKappaUser_i: modified coefficient kappa (producer's).
  \item ProdAcc_i: producer accuracy index for class i.
  \item M: number of elements of the matrix.
  \item N: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$ModKappaProd_i(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with modified coefficient kappa (producer's) and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(317,61,2,35,23,120,4,29,0,0,60,0,0,0,0,8),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Liu et al., 2007")
p$ModKappaProd_i(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-EntropUser_i"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-EntropUser_i}{}}}
\subsection{Method \code{EntropUser_i()}}{
Public method that calculates relative change of entropy given a category on map. That is, the degree of uncertainty of the category. The method also offers variance. The reference \insertCite{finn1993}{PaolaR6Nuevo} is followed for the calculations.


\deqn{
Entrop_i(A)=-\sum^n_{j=1}( (\frac{\sum^n_{i=1} x_{i +}}{\sum^n_{i,j=1} x_{ij} }) \cdot \log(\frac{\sum^n_{i=1} x_{i +}}{\sum^n_{i,j=1} x_{ij} }) )
}
\deqn{
Entrop_i(A|b_i)=-\sum^n_{j=1}( (\frac{ x_{ij}}{\sum^n_{j=1} x_{+ j} }) \cdot \log (\frac{x_{ij}}{\sum^n_{j=1} x_{+ j}}) )
}
\deqn{
EntropUser_i= \frac{Entrop_i(A)-Entrop_i(A|b_i)}{Entrop_i(A)}
}
\deqn{
\sigma^2_{EntropUser_i}= \frac{EntropUser_i \cdot (1-EntropUser_i)}{N}
}

where:

\enumerate{
  \item EntropUser_i: relative change of entropy given a category on map.
  \item Entrop_i(A): Entropy of the map with respect to the category of the map.
  \item x_j+: sum of all elements in rows j.
  \item x_+j: sum of all elements in column j.
  \item Entrop_i(A|b_i): Entropy of map A knowing that the location corresponding to map B is in class b_i.
  \item N: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$EntropUser_i(i, v = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate (row).}

\item{\code{v}}{Base of the logarithm. By default v=10. This value is used for the entropy units, v=10(Hartleys), v=2(bits), v=e(nats).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with the relative change of entropy given a category on map, its variance, map entropy, and entropy of map A knowing that the location corresponding to map B is in class b_i.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Liu et al., 2007")
p$EntropUser_i(1)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-EntropProd_i"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-EntropProd_i}{}}}
\subsection{Method \code{EntropProd_i()}}{
Public method that calculates relative change of entropy given a category on ground truthing. That is, the degree of uncertainty of the category. The method also offers variance. The reference \insertCite{stehman1997}{PaolaR6Nuevo} is followed for the calculations.


\deqn{
Entrop_i(B)=-\sum^n_{i=1}( (\frac{\sum^n_{j=1} x_{+ j}}{\sum^n_{i,j=1} x_{ij} }) \cdot \log (\frac{\sum^n_{j=1} x_{+ j}}{\sum^n_{i,j=1} x_{ij} }) )
}
\deqn{
Entrop_i(B|a_j)=-\sum^n_{j=1}( (\frac{ x_{ij}}{\sum^n_{i=1} x_{i +} }) \cdot \log (\frac{x_{ij}}{\sum^n_{i=1} x_{i +}}) )
}
\deqn{
EntropProd_i= \frac{EntropMap(B)-EntropMap(B|a_j)}{EntropMap(B)}
}
\deqn{
\sigma^2_{EntropProd_i}= \frac{EntropProd_i \cdot (1-EntropProd_i)}{N}
}
where:

\enumerate{
  \item EntropProd_i: relative change of entropy given a category on ground truthing.
  \item Entrop_i(B): Entropy of the map with respect to the category on ground truthing.
  \item x_j+: sum of all elements in rows j.
  \item x_+j: sum of all elements in column j.
  \item Entrop_i(B|a_j): Entropy of map B knowing that the location corresponding to map A is in class a_j.
  \item N: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$EntropProd_i(i, v = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate}

\item{\code{v}}{Base of the logarithm. By default v=10. This value is used for the entropy units, v=10(Hartleys), v=2(bits), v=e(nats).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of the relative change of entropy given a category on ground truthing, its variance, map entropy, and entropy of map B knowing that the location corresponding to map A is in class a_j.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Liu et al., 2007")
p$EntropProd_i(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-AvUserAcc"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-AvUserAcc}{}}}
\subsection{Method \code{AvUserAcc()}}{
Public method that provides the user's average accuracy, which is an average of the accuracy of individual categories, in this case the categories will be taken from the user's perspective. The method also offers variance. The reference \insertCite{tung1988}{PaolaR6Nuevo} is followed for the calculations.


\deqn{
AvUserAcc=\frac{1}{\sqrt{M}} \sum^n_{i=1} \frac{x_{ii}}{\sum_{j=1}^n x_{j+}}
}
\deqn{
\sigma^2_{AvUserAcc}=\frac{AvUserAcc \cdot (1-AvUserAcc)}{N}
}
where:

\enumerate{
  \item AvUserAcc: average accuracy from user's perspective.
  \item x_j.: sum of all elements in rows j.
  \item x_ii: diagonal element of the matrix.
  \item M: number of elements of the matrix.
  \item N: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$AvUserAcc()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list with the average accuracy from user's perspective and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(352,43,89,203),nrow=2,ncol=2)
p<-MatCon$new(A,Source="Tung&LeDrew, 1988")
p$AvUserAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-AvProdAcc"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-AvProdAcc}{}}}
\subsection{Method \code{AvProdAcc()}}{
Public method that provides the producer's average accuracy, which is an average of the accuracy of individual categories, in this case the categories will be taken from the producer's perspective. The method also offers variance. The reference \insertCite{tung1988}{PaolaR6Nuevo} is followed for the calculations.


\deqn{
AvProdAcc=\frac{1}{\sqrt{N}} \sum^n_{i=1} \frac{x_{ii}}{\sum_{j=1}^n x_{+j}}
}
\deqn{
\sigma^2_{AvProdAcc}=\frac{AvProdAcc \cdot (1-AvProdAcc)}{N}
}
where:

\enumerate{
  \item AvProdAcc: average accuracy from producer's perspective.
  \item x_+j: sum of all elements in column j.
  \item x_ii: diagonal element of the matrix.
  \item M: number of elements of the matrix.
  \item N: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$AvProdAcc()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list with the average accuracy from producer's perspective and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(352,43,89,203),nrow=2,ncol=2)
p<-MatCon$new(A,Source="Tung&LeDrew, 1988")
p$AvProdAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-AvUserProdAcc"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-AvUserProdAcc}{}}}
\subsection{Method \code{AvUserProdAcc()}}{
Public method that offers the average of the average precision from the perspective of the user and the producer. The method also offers variance. The reference \insertCite{liu2007}{PaolaR6Nuevo} is followed for the calculations.


\deqn{
AvUserProdAcc=\frac{AvUserAcc+AvProdAcc}{2}
}
 \deqn{
\sigma^2_{AvUserProdAcc}=\frac{AvUserProdAcc \cdot (1-AvUserProdAcc}{N}
}

where:

\enumerate{
  \item AvUserProdAcc: average of average of user's and producer's perspective.
  \item AvUserAcc: average accuracy from user's perspective.
  \item AvProdAcc: average accuracy from producer's perspective.
  \item N: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$AvUserProdAcc()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list with the values of the average of the average precision from the perspective of the user and the producer the user and producer perspective and their variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$AvUserProdAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-AvHelldenAcc"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-AvHelldenAcc}{}}}
\subsection{Method \code{AvHelldenAcc()}}{
Public method that provides the average value of the Hellden mean precision index. The method also offers variance. The reference \insertCite{liu2007}{PaolaR6Nuevo} is followed for the calculations.


\deqn{
AvHelldenAcc=\frac{1}{\sqrt{M}}\sum^n_{i=1} \frac{2 x_{ii}}{ x_{+i} + x_{i+}}
}
 \deqn{
\sigma^2_{AvHelldenAcc}=\frac{AvHelldenAcc \cdot (1-AvHelldenAcc)}{N}
}

where:

\enumerate{
  \item AvHelldenAcc: average of Hellden's mean accuracy index.
  \item x_+i: sum of all elements in column i.
  \item x_i+: sum of all elements in row i.
  \item x_ii: diagonal element of the matrix.
  \item M: number of elements of the matrix.
  \item N: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$AvHelldenAcc()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list with average of Hellden's mean accuracy index and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$AvHelldenAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-AvShortAcc"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-AvShortAcc}{}}}
\subsection{Method \code{AvShortAcc()}}{
Public method that provides the average of Short's mapping accuracy index. The method also offers variance. The reference \insertCite{liu2007}{PaolaR6Nuevo} is followed for the calculations.


\deqn{
AvShortAcc=\frac{1}{\sqrt{M}}\frac{\frac{\sum^n_{i=1} x_{ii}}{\sum^n_{i,j=1}x_{ij}}}{\sum^n_{j=1} x_{+ j}+\sum^n_{i=1} x_{i +}-x_{ii}}
}
\deqn{
\sigma^2_{AvShortAcc}=\frac{AvShortAcc \cdot (1-AvShortAcc)}{N}
}
where:

\enumerate{
  \item x_+i: sum of all elements in column i.
  \item x_i+: sum of all elements in row i.
  \item x_ii: diagonal element of the matrix.
  \item M: number of elements of the matrix.
  \item N: number of cases involved in the calculation of the index.#' }
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$AvShortAcc()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list with average of Short's mapping accuracy index and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$AvShortAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-CombUserAcc"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-CombUserAcc}{}}}
\subsection{Method \code{CombUserAcc()}}{
Public method that provides the combined user accuracy that is the average of the overall accuracy and the average user accuracy. The method also offers variance. The reference \insertCite{tung1988}{PaolaR6Nuevo} is followed for the calculations.


\deqn{
CombUserAcc=\frac{OverallAcc+AvUserAcc}{2}
}
\deqn{
\sigma^2_{CombUserAcc}=\frac{CombUserAcc \cdot (1-CombUserAcc)}{N}
}

where:

\enumerate{
  \item CombUserAcc: combined accuracy from user's perspective.
  \item OverallAcc: overall accuracy.
  \item AvUserAcc: average accuracy from user's perspective.
  \item N: number of cases involved in the calculation of the index.
  }
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$CombUserAcc()}\if{html}{\out{</div>}}
}

\subsection{Details}{
Example matrix taken from Tung, F., & LeDrew, E. (1988). The determination of optimal threshold levels for change detection using various accuracy indexes. Photogrammetric Engineering and Remote Sensing, 54(10), 1449-1454.
}

\subsection{Returns}{
A list of the combined accuracy from the user's perspective and its variation.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(352,43,89,203),nrow=2,ncol=2)
p<-MatCon$new(A,Source="Tung&LeDrew, 1988")
p$CombUserAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-CombProdAcc"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-CombProdAcc}{}}}
\subsection{Method \code{CombProdAcc()}}{
Public method that provides the combined producer accuracy that is the average of the overall accuracy and the average producer accuracy. The method also offers variance. The reference \insertCite{tung1988}{PaolaR6Nuevo} is followed for the calculations.


\deqn{
CombProdAcc=\frac{OverallAcc+AvProdAcc}{2}
}
\deqn{
\sigma^2_{CombProdAcc}=\frac{CombProdAcc \cdot (1-CombProdAcc)}{N}
}
where:

\enumerate{
  \item CombProdAcc: combined accuracy from producer's perspective.
  \item OverallAcc: overall accuracy.
  \item AvProdAcc: average accuracy from producer's perspective.
  \item N: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$CombProdAcc()}\if{html}{\out{</div>}}
}

\subsection{Details}{
Example matrix taken from Tung, F., & LeDrew, E. (1988). The determination of optimal threshold levels for change detection using various accuracy indexes. Photogrammetric Engineering and Remote Sensing, 54(10), 1449-1454.
}

\subsection{Returns}{
A list of the combined accuracy from producer's perspective and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(352,43,89,203),nrow=2,ncol=2)
p<-MatCon$new(A,Source="Tung&LeDrew, 1988")
p$CombProdAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-CombUserProdAcc"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-CombUserProdAcc}{}}}
\subsection{Method \code{CombUserProdAcc()}}{
Public method that provides the combined accuracy which is the average of the overall accuracy and the Hellden average accuracy, which refers to the average user and producer accuracies. The method also offers variation. The reference \insertCite{liu2007}{PaolaR6Nuevo} is followed for the calculations.


\deqn{
CombUserProdAcc=\frac{OverallAcc+AvHelldenAcc}{2}
}
 \deqn{
\sigma^2_{CombUserProdAcc}=\frac{CombUserProdAcc \cdot (1-CombUserProdAcc)}{N}
}
where:

\enumerate{
  \item CombUserProdAcc: combined accuracy from both user's and producer's perspectives.
  \item OverallAcc: overall accuracy.
  \item AvHelldenAcc: average of Hellden's mean accuracy index.
  \item N: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$CombUserProdAcc()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list of the combined accuracy from both user's and producer's perspectives and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$CombUserProdAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-Kappa"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-Kappa}{}}}
\subsection{Method \code{Kappa()}}{
Public method that provides kappa coefficient, which measures the relationship between agreement beyond chance and expected disagreement. The method also offers variation. The reference \insertCite{cohen1960}{PaolaR6Nuevo} is followed for the calculations.


\deqn{
ExpAcc=\sum^n_{i=1} (\frac{x _{+ i}}{\sum_{j=1}^n x_{ij}} \cdot \frac{x _{i +}}{\sum_{j=1}^n x_{ij}})
}
\deqn{
Kappa=\frac{OverallAcc-ExpAcc}{1-ExpAcc}
}
#' \deqn{
\sigma^2_{Kappa}=\frac{OverallAcc-ExpAcc}{(1-ExpAcc) \cdot N}
}



where:

\enumerate{
  \item Kappa: Kappa coefficient.
  \item OverallAcc: overall accuracy.
  \item ExpAcc: expected accuracy of agreement if agreement were purely random.
  \item x_+i: sum of all elements in column i.
  \item x_i+: sum of all elements in row i.
  \item N: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$Kappa()}\if{html}{\out{</div>}}
}

\subsection{Details}{
Example matrix taken from Congalton, R.G., & Green, K. (2008). Assessing the Accuracy of Remotely Sensed Data: Principles and Practices, Second Edition (2nd ed.). CRC press
}

\subsection{Returns}{
A list with kappa coefficient and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$Kappa()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-Entrop"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-Entrop}{}}}
\subsection{Method \code{Entrop()}}{
Public method for calculating map entropy. Which refers to the degree of uncertainty that the map presents. The method also offers variation. The reference \insertCite{finn1993}{PaolaR6Nuevo} is followed for the calculations.


\deqn{
Entrop=\sum^n_{i,j=1} (\frac{x_{ij}}{\sum^n_{i,j=1} x_{ij}} \cdot \log (\frac{x_{ij}}{\frac{\sum^n_{i=1} x_{i +} \cdot \sum^n_{j=1} x_{+ j}}{\sum^n_{i,j=1} x_{ij}}}))
}
\deqn{
\sigma^2_{Entrop}=\frac{Entrop \cdot (1-Entrop)}{N}
}
where:

\enumerate{
  \item Entrop: map entropy.
  \item x_+i: sum of all elements in column i.
  \item x_i+: sum of all elements in row i.
  \item N: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$Entrop(v = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{v}}{Base of the logarithm. By default v=10. This value is used for the entropy units, v=10(Hartleys), v=2(bits), v=e(nats).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with map entropy and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Liu et al.,2007")
p$Entrop()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-NormEntropUser"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-NormEntropUser}{}}}
\subsection{Method \code{NormEntropUser()}}{
Public method that calculates normalized entropy using the map. The method also offers variation. The reference \insertCite{finn1993}{PaolaR6Nuevo} is followed for the calculations.


\deqn{
Entrop_i(B)=-\sum^n_{i=1}( (\frac{\sum^n_{j=1} x_{+ j}}{\sum^n_{i,j=1} x_{ij} }) \cdot \log (\frac{\sum^n_{j=1} x_{+ j}}{\sum^n_{i,j=1} x_{ij} }) )
}
\deqn{
NormEntropUser=\frac{Entrop}{Entrop_i(B)}
}
\deqn{
\sigma^2_{NormEntropUser}=\frac{NormEntropUser \cdot (1-NormEntropUser)}{N}
}
where:

\enumerate{
  \item NormEntropUser: normalized entropy using map.
  \item Entrop_i(B): entropy of the map with respect to the category on ground truthing.
  \item Entrop: map entropy.
  \item x_+i: sum of all elements in column i.
  \item x_i+: sum of all elements in row i.
  \item N: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$NormEntropUser(v = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{v}}{Base of the logarithm. By default v=10. This value is used for the entropy units, v=10(Hartleys), v=2(bits), v=e(nats).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with normalized entropy using map and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Liu et al., 2007")
p$NormEntropUser()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-NormEntropProd"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-NormEntropProd}{}}}
\subsection{Method \code{NormEntropProd()}}{
Public method that calculates normalized entropy using on ground truthing. The method also offers variation. The reference \insertCite{finn1993}{PaolaR6Nuevo} is followed for the calculations.


\deqn{
Entrop_i(A)=-\sum^n_{j=1}( (\frac{\sum^n_{i=1} x_{i +}}{\sum^n_{i,j=1} x_{ij} }) \cdot \log(\frac{\sum^n_{i=1} x_{i +}}{\sum^n_{i,j=1} x_{ij} }) )
}
\deqn{
NormEntropProd=\frac{Entrop}{Entrop_i(A)}
}
\deqn{
\sigma^2_{NormEntropProd}=\frac{NormEntropProd \cdot (1-NormEntropProd)}{N}
}
where:

\enumerate{
  \item NormEntropProd: normalized mutual information using the entropy on ground truthing.
  \item Entrop_i(A): Entropy of the map with respect to the category of the map.
  \item Entrop: map entropy.
  \item x_+i: sum of all elements in column i.
  \item x_i+: sum of all elements in row i.
  \item N: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$NormEntropProd(v = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{v}}{Base of the logarithm. By default v=10. This value is used for the entropy units, v=10(Hartleys), v=2(bits), v=e(nats).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with normalized entropy using on ground truthing and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Liu et al., 2007")
p$NormEntropProd()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-AvNormEntrop"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-AvNormEntrop}{}}}
\subsection{Method \code{AvNormEntrop()}}{
Public method that calculates normalized entropy using the arithmetic mean of the entropies on the map and on ground truthing. The method also offers variation. The reference \insertCite{strehl2002}{PaolaR6Nuevo} is followed for the calculations.


\deqn{
Entrop_i(A)=-\sum^n_{j=1}( (\frac{\sum^n_{i=1} x_{i +}}{\sum^n_{i,j=1} x_{ij} }) \cdot \log(\frac{\sum^n_{i=1} x_{i +}}{\sum^n_{i,j=1} x_{ij} }) )
}
\deqn{
Entrop_i(B)=-\sum^n_{i=1}( (\frac{\sum^n_{j=1} x_{+ j}}{\sum^n_{i,j=1} x_{ij} }) \cdot \log (\frac{\sum^n_{j=1} x_{+ j}}{\sum^n_{i,j=1} x_{ij} }) )
}
\deqn{
AvNormEntrop=\frac{2Entrop}{Entrop_i(A)+Entrop_i(B)}
}
\deqn{
\sigma^2_{AvNormEntrop}=\frac{AvNormEntrop \cdot (1-AvNormEntrop)}{N}
}

where:

\enumerate{
  \item AvNormEntrop: normalized entropy using the arithmetic mean of the entropies on the map and on ground truthing.
  \item Entrop_i(B): entropy of the map with respect to the category on ground truthing.
  \item Entrop_i(A): Entropy of the map with respect to the category of the map.
  \item Entrop: map entropy.
  \item x_+i: sum of all elements in column i.
  \item x_i+: sum of all elements in row i.
  \item N: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$AvNormEntrop(v = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{v}}{Base of the logarithm. By default v=10. This value is used for the entropy units, v=10(Hartleys), v=2(bits), v=e(nats).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
normalized entropy using the arithmetic mean of the entropies on the map and on ground truthing and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$AvNormEntrop()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-GeomAvNormEntrop"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-GeomAvNormEntrop}{}}}
\subsection{Method \code{GeomAvNormEntrop()}}{
Public method that calculates normalized entropy using the geometric mean of the entropies on the map and on ground truthing. The method also offers variation. The reference \insertCite{ghosh2002}{PaolaR6Nuevo} is followed for the calculations.


\deqn{
Entrop_i(A)=-\sum^n_{j=1}( (\frac{\sum^n_{i=1} x_{i +}}{\sum^n_{i,j=1} x_{ij} }) \cdot \log(\frac{\sum^n_{i=1} x_{i +}}{\sum^n_{i,j=1} x_{ij} }) )
}
\deqn{
Entrop_i(B)=-\sum^n_{i=1}( (\frac{\sum^n_{j=1} x_{+ j}}{\sum^n_{i,j=1} x_{ij} }) \cdot \log (\frac{\sum^n_{j=1} x_{+ j}}{\sum^n_{i,j=1} x_{ij} }) )
}
\deqn{
GeomAvNormEntrop=\frac{Entrop}{\sqrt{Entrop_i(A) \cdot Entrop_i(B)}}
}
\deqn{
\sigma^2_{GeomAvNormEntrop}=\frac{GeomAvNormEntrop \cdot (1-GeomAvNormEntrop)}{N}
}
where:

\enumerate{
  \item GeomAvNormEntrop: normalized entropy using the geometric mean of the entropies on map and on ground truthing.
  \item Entrop_i(B): entropy of the map with respect to the category on ground truthing.
  \item Entrop_i(A): Entropy of the map with respect to the category of the map.
  \item Entrop: map entropy.
  \item x_+i: sum of all elements in column i.
  \item x_i+: sum of all elements in row i.
  \item N: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$GeomAvNormEntrop(v = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{v}}{Base of the logarithm. By default v=10. This value is used for the entropy units, v=10(Hartleys), v=2(bits), v=e(nats).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with normalized entropy using the geometric mean of the entropies on map and on ground truthing and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$GeomAvNormEntrop()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-AvMaxNormEntrop"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-AvMaxNormEntrop}{}}}
\subsection{Method \code{AvMaxNormEntrop()}}{
Public mathod that provides normalized entropy using the arithmetic mean of the maximum entropies on map and on ground truthing.The method also offers variation. The reference \insertCite{strehl2002relationship}{PaolaR6Nuevo} is followed for the calculations.



\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$AvMaxNormEntrop(v = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{v}}{Base of the logarithm. By default v=10. This value is used for the entropy units, v=10(Hartleys), v=2(bits), v=e(nats).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with normalized entropy using the arithmetic mean of the maximum entropies on map and on ground truthing and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$AvMaxNormEntrop()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-Tau"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-Tau}{}}}
\subsection{Method \code{Tau()}}{
Public method that calculates the tau index and its variance. Its value indicates how much the classification has improved compared to a random classification of the N elements into M groups. The method also offers the variance. The reference \insertCite{book}{PaolaR6Nuevo} is followed for the computations.


The mathematical expression is:

\deqn{
PrAgCoef=\frac{1}{M}
}
\deqn{
Tau = \frac{OverallAcc-CoefAccPr}{1-PrAgCoef}
}

\deqn{
\sigma^2_{Tau}=\frac{OverallAcc \cdot (1-OverallAcc)}{N \cdot (1-CoefAccPr)^2}
}

Where:
\enumerate{
  \item OverallAcc: overall accuracy.
  \item PrAgCoef: a priori random agreement coefficient.
  \item M: number of classes.
  \item N: number of elements of the matrix, cardinal of the matrix.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$Tau()}\if{html}{\out{</div>}}
}

\subsection{Details}{
Example matrix taken from Muñoz, J. M. S. (2016). Análisis de Calidad Cartográfica mediante el estudio de la Matriz de Confusión. Pensamiento matemático, 6(2), 9-26.
}

\subsection{Returns}{
A list with Tau index and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(238051,7,132,0,0,24,9,2,189,1,4086,188,0,4,16,45,1,0,939,5082,
51817,0,34,500,1867,325,17,0,0,5,11148,1618,78,0,0,0,0,48,4,834,2853,340,
32,0,197,5,151,119,135,726,6774,75,1,553,0,105,601,110,174,155,8257,8,0,
29,36,280,0,0,6,5,2993,0,115,2,0,4,124,595,0,0,4374),nrow=9,ncol=9)
p<-MatCon$new(A,Source="Muñoz, 2016")
p$Tau()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-UserProdAcc"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-UserProdAcc}{}}}
\subsection{Method \code{UserProdAcc()}}{
Public method that calculates the pressures of the user and the producer jointly. The method also offers the standard desviations. The reference \insertCite{congalton2008}{PaolaR6Nuevo} is followed for the computations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$UserProdAcc()}\if{html}{\out{</div>}}
}

\subsection{Details}{
Example matrix taken from Congalton, R.G., & Green, K. (2008). Assessing the Accuracy of Remotely Sensed Data: Principles and Practices, Second Edition (2nd ed.). CRC press
}

\subsection{Returns}{
A list containing the producer's and user's accuracies and their standard deviations, respectively.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green,2008")
p$UserProdAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-DetailedKappa"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-DetailedKappa}{}}}
\subsection{Method \code{DetailedKappa()}}{
Public method that calculates the general Kappa agreement index, its standard deviation and the test statistic to test its significance. The reference \insertCite{congalton2008}{PaolaR6Nuevo} is followed for the computations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$DetailedKappa()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list of the kappa coefficient, its standard deviation, and the value of its test statistic.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green,2008")
p$DetailedKappa()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-DetailedCondKappa"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-DetailedCondKappa}{}}}
\subsection{Method \code{DetailedCondKappa()}}{
Public method that calculates the Kappa class agreement index (conditional Kappa) from the perspective of user (i) and producer (j) and its standard desviations. The reference \insertCite{congalton2008}{PaolaR6Nuevo} is followed for the computations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$DetailedCondKappa()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list with conditional Kappa index of the user and the producer, and its corresponding standard deviation.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green,2008")
p$DetailedCondKappa ()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-QES"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-QES}{}}}
\subsection{Method \code{QES()}}{
Public method that calculates the values of quantity, change and shift. The reference \insertCite{pontius2014}{PaolaR6Nuevo} is followed for the computations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$QES(TI = NULL, SF = 1)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{TI}}{Time interval (default value = 1)}

\item{\code{SF}}{Scale factor for results (default value = 1)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of general values for the interval t of difference, quantity, shift, and shift.In addition to the differences for categories, number of components, change of categories and turn of the components.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$QES(TI=1, SF=6)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-MTypify"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-MTypify}{}}}
\subsection{Method \code{MTypify()}}{
Public method that types the values of each cell. The total sum of the original matrix is used for typing. The resulting values can be presented as real (parameter RaR=1) or as a percentage (parameter RaR !=1)


\deqn{
MTypify=\frac{x_{ij}}{\sum^n_{i,j=1} x_{ij}}
}

where:

\enumerate{
  \item MTyipify: typified matrix.
  \item x_ij: matrix element.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$MTypify(RaR = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{RaR}}{"1" indicates result as real, other values mean percentage as integer. By default RaR=1.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with original matrix and typified matrix
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A, Source="Congalton&Green, 2008")
p$MTypify(RaR=5)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-AllParameters"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-AllParameters}{}}}
\subsection{Method \code{AllParameters()}}{
Public method in which multiple parameters are calculated for the given confusion matrix. The reference [1,11,16,19] is followed for the computations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$AllParameters()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list containing Confusion Matrix, Dimension, Total Sum of Cell Values, Overall Precision, Overall Variance Precision, Global Precision Kappa Index, Global Kappa Simplified Variance, Producer Precision by Class, User Precision by Class, k value for the calculation of pseudozeroes, Pseudoceros Matrix, L Matrix for the calculation of pseudozeroes.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
p$AllParameters()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-MBootStrap"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-MBootStrap}{}}}
\subsection{Method \code{MBootStrap()}}{
Public method that provides N resamples of the confusion matrix from a MatCon object. The reference \insertCite{ariza2011}{PaolaR6Nuevo} is followed for the computations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$MBootStrap(n)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n}}{Number of resamples.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list formed by the original confusion matrix and simulated matrices, from the confusion matrix. The multinomial distribution is applied.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A, Source="Congalton&Green, 2008")
p$MBootStrap(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-MNormalize"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-MNormalize}{}}}
\subsection{Method \code{MNormalize()}}{
Public method that carries out an iterative process is carried out where each element is divided by the total of the sum of its row, thus obtaining new values. In the next iteration, all the elements are added by columns and each element is divided by the total of its column and they obtain new values, and so on. The reference \insertCite{fienberg1970,munoz2016}{PaolaR6Nuevo} is followed for the computations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$MNormalize(n = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n}}{Number of iteration. By default n=100.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list formed by the original confusion matrix and the normalized matrix.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(238051,7,132,0,0,24,9,2,189,1,4086,188,0,4,16,45,1,0,939,5082,
51817,0,34,500,1867,325,17,0,0,5,11148,1618,78,0,0,0,0,48,4,834,2853,340,
32,0,197,5,151,119,135,726,6774,75,1,553,0,105,601,110,174,155,8257,8,0,
29,36,280,0,0,6,5,2993,0,115,2,0,4,124,595,0,0,4374),nrow=9,ncol=9)
p<-MatCon$new(A,Source="Muñoz, 2016")
p$MNormalize()$values

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-MPseudoZeroes"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-MPseudoZeroes}{}}}
\subsection{Method \code{MPseudoZeroes()}}{
Public method that small values are calculated for empty cells of the matrix. All non-empty cells of the matrix change their values. This function will not be applied if all the elements of the matrix are different from 0. The reference \insertCite{munoz2016}{PaolaR6Nuevo} is followed for the computations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$MPseudoZeroes()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list formed by the original confusion matrix and the Pseudozeroes matrix.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(238051,7,132,0,0,24,9,2,189,1,4086,188,0,4,16,45,1,0,939,5082,
51817,0,34,500,1867,325,17,0,0,5,11148,1618,78,0,0,0,0,48,4,834,2853,340,
32,0,197,5,151,119,135,726,6774,75,1,553,0,105,601,110,174,155,8257,8,0,
29,36,280,0,0,6,5,2993,0,115,2,0,4,124,595,0,0,4374),nrow=9,ncol=9)
p<-MatCon$new(A,Source="Muñoz, 2016")
p$MPseudoZeroes()$values

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-DetailedWTau"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-DetailedWTau}{}}}
\subsection{Method \code{DetailedWTau()}}{
Public method that calculates the general Tau concordance index and its standard deviation.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$DetailedWTau(WV)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{WV}}{Weights vector (as matrix)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Overall accuracy index, producer accurancy index, O3,O4, Tau index?(mirar definicion en funcion) y its standard desviation.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
WV <-matrix(c(0.4, 0.1, 0.4, 0.1), ncol=4)
p<-MatCon$new(A,Source="Congalton&Green,2008")
p$DetailedWTau(WV)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-DetailedWKappa"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-DetailedWKappa}{}}}
\subsection{Method \code{DetailedWKappa()}}{
Public method that calculates the general Kappa agreement index (weighted) and its standard deviation. The reference \insertCite{congalton2008}{PaolaR6Nuevo} is followed for the computations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$DetailedWKappa(WM)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{WM}}{Weight matrix}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with the weight matrix, kappa index obtained from the original matrix and the weight matrix, its standard desviations and the value of its test statistic.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A <- A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
WM<- t(matrix(c(1,0,0.67,1,0,1,0,0,1,0,1,1,0.91,0,0.61,1), nrow = 4, ncol=4))
p<-MatCon$new(A)
p$DetailedWKappa(WM)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-UserProdAcc_W"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-UserProdAcc_W}{}}}
\subsection{Method \code{UserProdAcc_W()}}{
Public method that calculates the weighted accuracies and standard deviations of the user and the producer. The reference \insertCite{congalton2008}{PaolaR6Nuevo} is followed for the computations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$UserProdAcc_W(WM)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{WM}}{Weight matrix}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with weight matrix, Matrix formed with its original elements and their corresponding weights, general accuracy of the weight matrix obtained, accuracy of the producer and user and their standard deviations,
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,Source="Congalton&Green, 2008")
WM<- t(matrix(c(1,0,0.67,1,0,1,0,0,1,0,1,1,0.91,0,0.61,1), nrow = 4, ncol=4))
p$UserProdAcc_W(WM)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-clone"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
