% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MatCon.R
\name{MatCon}
\alias{MatCon}
\title{Confusion matrix}
\value{
Object of class MatCon or an error if a matrix is not entered.
\itemize{
 \item \code{Error type 1}: Non-square matrix.
 \item \code{Error type 2}: Single element matrix.
 \item \code{Error type 3}: negative values.
 \item \code{Error type 4}: Sum of elements 0.
 \item \code{Error type 5}: Sum of rows 0.
 \item \code{Error type 6}: Sum of columns 0.
 \item \code{Error type 7}: It is not a matrix.
}
}
\description{
Using the confusion matrix, various indices are calculated.
}
\examples{
A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
mc <- MatCon$new (A,ID=5,Date="27-10-2023")


## ------------------------------------------------
## Method `MatCon$new`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
mc <- MatCon$new (A,ID=5,Date="27-10-2023")


## ------------------------------------------------
## Method `MatCon$OverallAcc`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$OverallAcc()


## ------------------------------------------------
## Method `MatCon$ua`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,ID=1,Date="30/10/2023")
p$ua()


## ------------------------------------------------
## Method `MatCon$uai`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$uai(2)


## ------------------------------------------------
## Method `MatCon$pai`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$pai(1)


## ------------------------------------------------
## Method `MatCon$pa`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$pa()


## ------------------------------------------------
## Method `MatCon$aup`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$aup(2)


## ------------------------------------------------
## Method `MatCon$ICSI`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$ICSI(2)


## ------------------------------------------------
## Method `MatCon$mah`
## ------------------------------------------------

A <- t(matrix(c(35, 14,11,1,4,11,3,0,12,9,38,4,2,5,12,2), nrow = 4, ncol=4))
p<-MatCon$new(A)
p$mah(2)


## ------------------------------------------------
## Method `MatCon$mas`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$mas(2)


## ------------------------------------------------
## Method `MatCon$cku`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$cku(2)


## ------------------------------------------------
## Method `MatCon$ckp`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$ckp(2)


## ------------------------------------------------
## Method `MatCon$mcku`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$mcku(2)


## ------------------------------------------------
## Method `MatCon$mckp`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$mckp(4)


## ------------------------------------------------
## Method `MatCon$ecnu`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$ecnu(2)


## ------------------------------------------------
## Method `MatCon$ecnp`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$ecnp(4)


## ------------------------------------------------
## Method `MatCon$aau`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$aau()


## ------------------------------------------------
## Method `MatCon$aap`
## ------------------------------------------------

A <- matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$aap()


## ------------------------------------------------
## Method `MatCon$daup`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$daup()


## ------------------------------------------------
## Method `MatCon$CSI`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$CSI()


## ------------------------------------------------
## Method `MatCon$amah`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$amah()


## ------------------------------------------------
## Method `MatCon$amas`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$amas()


## ------------------------------------------------
## Method `MatCon$cau`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$cau()


## ------------------------------------------------
## Method `MatCon$cap`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$cap()


## ------------------------------------------------
## Method `MatCon$caup`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$caup()


## ------------------------------------------------
## Method `MatCon$KappaValue`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$KappaValue()


## ------------------------------------------------
## Method `MatCon$mkp`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$mkp()


## ------------------------------------------------
## Method `MatCon$ami`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$ami()


## ------------------------------------------------
## Method `MatCon$nmiu`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$nmiu()


## ------------------------------------------------
## Method `MatCon$nmip`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$nmip()


## ------------------------------------------------
## Method `MatCon$nmiam`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$nmiam()


## ------------------------------------------------
## Method `MatCon$nmigm`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$nmigm()


## ------------------------------------------------
## Method `MatCon$nmimx`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$nmimx()


## ------------------------------------------------
## Method `MatCon$Tau`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$Tau()


## ------------------------------------------------
## Method `MatCon$CAccuracies`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$CAccuracies()


## ------------------------------------------------
## Method `MatCon$DetailedKappa`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$DetailedKappa()


## ------------------------------------------------
## Method `MatCon$DetailedCKappa`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$DetailedCKappa ()


## ------------------------------------------------
## Method `MatCon$QES`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$QES(TI=1, SF=6)


## ------------------------------------------------
## Method `MatCon$MAllParameters`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$MAllParameters()


## ------------------------------------------------
## Method `MatCon$BootStrap`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$BootStrap(2)


## ------------------------------------------------
## Method `MatCon$Normalize`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$Normalize()$values


## ------------------------------------------------
## Method `MatCon$MPseudozeroes`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$MPseudozeroes()$values


## ------------------------------------------------
## Method `MatCon$DetailedTau`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
WV <-matrix(c(0.4, 0.1, 0.4, 0.1), ncol=4)
p<-MatCon$new(A)
p$DetailedTau(WV)


## ------------------------------------------------
## Method `MatCon$DetailedWKappa`
## ------------------------------------------------

A <- A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
WM<- t(matrix(c(1,0,0.67,1,0,1,0,0,1,0,1,1,0.91,0,0.61,1), nrow = 4, ncol=4))
p<-MatCon$new(A)
p$DetailedWKappa(WM)


## ------------------------------------------------
## Method `MatCon$CAccuraciesW`
## ------------------------------------------------

A <- t(matrix(c(35, 14,11,1,4,11,3,0,12,9,38,4,2,5,12,2), nrow = 4, ncol=4))
p<-MatCon$new(A)
WM<- t(matrix(c(1,0,0.67,1,0,1,0,0,1,0,1,1,0.91,0,0.61,1), nrow = 4, ncol=4))
p$CAccuraciesW(WM)

}
\references{
[1] Story, M., & Congalton, R. G. (1986). Accuracy assessment: a user’s perspective. Photogrammetric Engineering and remote sensing, 52(3), 397-399.

[2] Liu, C., Frazier, P., & Kumar, L. (2007). Comparative assessment of the measures of thematic classification accuracy. Remote sensing of environment, 107(4), 606-616.

[3] Koukoulas, S., & Blackburn, G. A. (2001). Introducing new indices for accuracy evaluation of classified images representing semi-natural woodland environments. Photogrammetric Engineering and Remote Sensing, 67(4), 499-510.

[4] Turk, G. (2002). Map evaluation and" chance correction". Photogrammetric Engineering and Remote Sensing, 68(2), 123-129.

[5] Helldén, U. (1980). A test of landsat-2 imagery and digital data for thematic mapping illustrated by an environmental study in northern Kenya, Lund University. Natural Geography Institute Report No. 47.

[6] Rosenfield, G. H., & Fitzpatrick-Lins, K. (1986). A coefficient of agreement as a measure of thematic classification accuracy. Photogrammetric engineering and remote sensing, 52(2), 223-227.

[7] Short, N. M. (1982). The Landsat tutorial workbook: Basics of satellite remote sensing (Vol. 1078). National Aeronautics and Space Administration, Scientific and Technical Information Branch.

[8] Stehman, S. V. (1997). Selecting and interpreting measures of thematic classification accuracy. Remote sensing of Environment, 62(1), 77-89.

[9] Finn, J. T. (1993). Use of the average mutual information index in evaluating classification error and consistency. International Journal of Geographical Information Science, 7(4), 349-366.

[10] Tung, F., & LeDrew, E. (1988). The determination of optimal threshold levels for change detection using various accuracy indexes. Photogrammetric Engineering and Remote Sensing, 54(10), 1449-1454.

[11] Cohen, J. (1960). A coefficient of agreement for nominal scales. Educational and psychological measurement, 20(1), 37-46.

[12] Strehl, A., & Ghosh, J. (2002). Cluster ensembles---a knowledge reuse framework for combining multiple partitions. Journal of machine learning research, 3(Dec), 583-617.

[13] Ghosh, J., Strehl, A., & Merugu, S. (2002, November). A consensus framework for integrating distributed clusterings under limited knowledge sharing. In Proc. NSF Workshop on Next Generation Data Mining (pp. 99-108).

[14] Strehl, A. (2002). Relationship-based clustering and cluster ensembles for high-dimensional data mining. The University of Texas at Austin.

[15] Ariza-López, F. J. (2013). Fundamentos de evaluación de la calidad de la información geográfica. Universidad de Jaén. Servicio de Publicaciones.

[16] Pontius Jr, R. G., & Santacruz, A. (2014). Quantity, exchange, and shift components of difference in a square contingency table. International Journal of Remote Sensing, 35(21), 7543-7554.

[17] Ariza, F. J., Pinilla, C., & Garcia, J. L. (2011). Comparación de matrices de confusión celda a celda mediante bootstraping.

[18] Fienberg, S. E. (1970). An iterative procedure for estimation in contingency tables. The Annals of Mathematical Statistics, 41(3), 907-917.

[19] Muñoz, J. M. S. (2016). Análisis de Calidad Cartográfica mediante el estudio de la Matriz de Confusión. Pensamiento matemático, 6(2), 9-26.
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-MatCon-new}{\code{MatCon$new()}}
\item \href{#method-MatCon-OverallAcc}{\code{MatCon$OverallAcc()}}
\item \href{#method-MatCon-ua}{\code{MatCon$ua()}}
\item \href{#method-MatCon-uai}{\code{MatCon$uai()}}
\item \href{#method-MatCon-pai}{\code{MatCon$pai()}}
\item \href{#method-MatCon-pa}{\code{MatCon$pa()}}
\item \href{#method-MatCon-aup}{\code{MatCon$aup()}}
\item \href{#method-MatCon-ICSI}{\code{MatCon$ICSI()}}
\item \href{#method-MatCon-mah}{\code{MatCon$mah()}}
\item \href{#method-MatCon-mas}{\code{MatCon$mas()}}
\item \href{#method-MatCon-cku}{\code{MatCon$cku()}}
\item \href{#method-MatCon-ckp}{\code{MatCon$ckp()}}
\item \href{#method-MatCon-mcku}{\code{MatCon$mcku()}}
\item \href{#method-MatCon-mckp}{\code{MatCon$mckp()}}
\item \href{#method-MatCon-ecnu}{\code{MatCon$ecnu()}}
\item \href{#method-MatCon-ecnp}{\code{MatCon$ecnp()}}
\item \href{#method-MatCon-aau}{\code{MatCon$aau()}}
\item \href{#method-MatCon-aap}{\code{MatCon$aap()}}
\item \href{#method-MatCon-daup}{\code{MatCon$daup()}}
\item \href{#method-MatCon-CSI}{\code{MatCon$CSI()}}
\item \href{#method-MatCon-amah}{\code{MatCon$amah()}}
\item \href{#method-MatCon-amas}{\code{MatCon$amas()}}
\item \href{#method-MatCon-cau}{\code{MatCon$cau()}}
\item \href{#method-MatCon-cap}{\code{MatCon$cap()}}
\item \href{#method-MatCon-caup}{\code{MatCon$caup()}}
\item \href{#method-MatCon-KappaValue}{\code{MatCon$KappaValue()}}
\item \href{#method-MatCon-mkp}{\code{MatCon$mkp()}}
\item \href{#method-MatCon-ami}{\code{MatCon$ami()}}
\item \href{#method-MatCon-nmiu}{\code{MatCon$nmiu()}}
\item \href{#method-MatCon-nmip}{\code{MatCon$nmip()}}
\item \href{#method-MatCon-nmiam}{\code{MatCon$nmiam()}}
\item \href{#method-MatCon-nmigm}{\code{MatCon$nmigm()}}
\item \href{#method-MatCon-nmimx}{\code{MatCon$nmimx()}}
\item \href{#method-MatCon-Tau}{\code{MatCon$Tau()}}
\item \href{#method-MatCon-CAccuracies}{\code{MatCon$CAccuracies()}}
\item \href{#method-MatCon-DetailedKappa}{\code{MatCon$DetailedKappa()}}
\item \href{#method-MatCon-DetailedCKappa}{\code{MatCon$DetailedCKappa()}}
\item \href{#method-MatCon-QES}{\code{MatCon$QES()}}
\item \href{#method-MatCon-MAllParameters}{\code{MatCon$MAllParameters()}}
\item \href{#method-MatCon-BootStrap}{\code{MatCon$BootStrap()}}
\item \href{#method-MatCon-Normalize}{\code{MatCon$Normalize()}}
\item \href{#method-MatCon-MPseudozeroes}{\code{MatCon$MPseudozeroes()}}
\item \href{#method-MatCon-DetailedTau}{\code{MatCon$DetailedTau()}}
\item \href{#method-MatCon-DetailedWKappa}{\code{MatCon$DetailedWKappa()}}
\item \href{#method-MatCon-CAccuraciesW}{\code{MatCon$CAccuraciesW()}}
\item \href{#method-MatCon-clone}{\code{MatCon$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-new"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-new}{}}}
\subsection{Method \code{new()}}{
Creates a new instance of this [R6][R6::R6Class] class.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$new(values, ID = NULL, Date = NULL, Source = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{values}}{Confusion matrix}

\item{\code{ID}}{Identifier. By default ID is a date in YYYYMMDD format}

\item{\code{Date}}{Date provided by the user. By default the date provided by the system will be taken.}

\item{\code{Source}}{Indicates where the matrix comes from (article, project, etc.). By default is NULL.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Object of class MatCon or an error if a matrix is not entered.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
mc <- MatCon$new (A,ID=5,Date="27-10-2023")

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-OverallAcc"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-OverallAcc}{}}}
\subsection{Method \code{OverallAcc()}}{
Overall accuracy for a particular classified image/map is then calculated by dividing the sum of the entries that form the major diagonal (i.e., the number of correct classifications) by the total number of samples taken. See reference [1].


The mathematical expression is:

\deqn{
OverallAcc = \frac{\sum_{i=1}^{n} x_{ii}}{\sum_{i, j=1}^{n} x_{ij}}
}

\deqn{
\sigma^2_{OverallAcc}=\frac{OverallAcc \cdot (1-OverallAcc)}{N}
}
Where:
\enumerate{
  \item OverallAcc: overall accuracy.
  \item x_ii: diagonal element of the matrix.
  \item x_ij: element of the matrix.
  \item N: number of elements of the matrix, cardinal of the matrix.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$OverallAcc()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Overall accuracy and variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$OverallAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-ua"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-ua}{}}}
\subsection{Method \code{ua()}}{
The accuracy from the point of view of a map user, not the map maker. See reference [1].


The mathematical expression is:
\deqn{
ua=\frac{x_{ii}}{\sum_{j=1}^n x_{ij}}
}

where:

\enumerate{
  \item `ua`: user accuracy.
  \item `x_ii`: diagonal element of the matrix.
  \item `x_ij`: element of the matrix.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$ua()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Vector of values with the user's accuracy indexes of all classes and their variances.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A,ID=1,Date="30/10/2023")
p$ua()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-uai"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-uai}{}}}
\subsection{Method \code{uai()}}{
The accuracy from the point of view of a map user, not the map maker. See reference [1].


\deqn{
ua_{i}=\frac{x_{ii}}{\sum_{j=1}^n x_{ij}}
}

where:

\enumerate{
  \item `ua_i`: user accuracy.
  \item `x_ii`: diagonal element of the matrix.
  \item `x_ij`: element of the matrix.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$uai(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{User class to evaluate}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Class i user accuracy index and their variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$uai(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-pai"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-pai}{}}}
\subsection{Method \code{pai()}}{
The map accuracy from the point of view of the map maker (the producer). See reference [1].


\deqn{
pa_{i}=\frac{x_{jj}}{\sum_{j=1}^n x_{ij}}
}

where:

\enumerate{
  \item `pa_i`: producer accuracy.
  \item `x_jj`: diagonal element of the matrix.
  \item `x_ij`: element of the matrix.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$pai(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Producer class to evaluate}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Class i producer accuracy index and their variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$pai(1)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-pa"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-pa}{}}}
\subsection{Method \code{pa()}}{
The map accuracy from the point of view of the map maker (the producer). See reference [1].


\deqn{
pa=\frac{x_{jj}}{\sum_{j=1}^n x_{ij}}
}

where:

\enumerate{
  \item `pa`: producer accuracy.
  \item `x_jj`: diagonal element of the matrix.
  \item `x_ij`: element of the matrix.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$pa()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Vector of values with the producer's accuracy indexes of all classes
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$pa()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-aup"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-aup}{}}}
\subsection{Method \code{aup()}}{
Average of the accuracy from the point of view of a map user, not the map maker and the map accuracy from the point of view of the map maker (the producer). See reference [2].


\deqn{
aup=\frac{ua_i+pa_i}{2}
}

where:

\enumerate{
  \item `aup`: average of user's and producer's accuracy.
  \item `ua_i`: user accuracy
  \item `pa_i`: producer accuracy.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$aup(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Average of user's and producer's accuracy and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$aup(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-ICSI"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-ICSI}{}}}
\subsection{Method \code{ICSI()}}{
The Individual Classification Success Index (ICSI) applies to the classification effectiveness for one particular class of interest. See reference [3,4].


\deqn{
ICSI=ua_i+pa_i-1
}

where:

\enumerate{
  \item `ICSI`: individual classification success index.
  \item `ua_i`: user accuracy.
  \item `pa_i`: producer accuracy.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$ICSI(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Individual Classification Success Index and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$ICSI(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-mah"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-mah}{}}}
\subsection{Method \code{mah()}}{
The probability that a randomly chosen point of a specific class on the map has a correspondence of the same class in the same position in the field and that a randomly chosen point in the field of the same class has a correspondence of the same class in the same position on the map. See references [5,6].


\deqn{
mah=\frac{2}{\frac{1}{ua_i}+\frac{1}{pa_i}}
}

where:

\enumerate{
  \item `mah`: Hellden's mean accuracy.
  \item `ua_i`: user accuracy.
  \item `pa_i`: producer accuracy.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$mah(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Hellden's mean accuracy.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A <- t(matrix(c(35, 14,11,1,4,11,3,0,12,9,38,4,2,5,12,2), nrow = 4, ncol=4))
p<-MatCon$new(A)
p$mah(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-mas"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-mas}{}}}
\subsection{Method \code{mas()}}{
Mapping accuracy for each class is stated as the number of correctly classified pixels (equal to the total in the correctly classified area) in terms of all pixels affected by its classification (equal to this total in the displayed area as well as the pixels involved in errors of commission and omission). See references [6,7].


\deqn{
mas=\frac{x_{ii}}{\sum^n_{j=1} x_{\cdot j}+\sum^n_{i=1} x_{i \cdot }-x_{ii}}
}

where:

\enumerate{
  \item `mas`: Short's mapping accuracy
  \item `x_ii`: diagonal element of the matrix.
  \item `x_.j`: sum with respect to j (rows).
  \item `x_i.`: sum with respect to i (columns).
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$mas(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Short's mapping accuracy and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$mas(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-cku"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-cku}{}}}
\subsection{Method \code{cku()}}{
Conditional Kappa will identify the degree of agreement between the two raters for each possible category. See reference [6].


\deqn{
cku=\frac{ua_i-\frac{\sum^n_{i=1} x_{i \cdot }}{\sum^n_{i=1}\sum^n_{j=1} x_{ij}}}{1-\frac{\sum^n_{i=1} x_{i \cdot }}{\sum^n_{i=1}\sum^n_{j=1} x_{ij}}}
}

where:

\enumerate{
  \item `cku`: conditional kappa (user's).
  \item `ua_i`: user accuracy.
  \item `x_ii`: diagonal element of the matrix.
  \item `x_.j`: sum with respect to j (rows).
  \item `x_i.`: sum with respect to i (columns).
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$cku(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Conditional kappa (user's) and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$cku(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-ckp"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-ckp}{}}}
\subsection{Method \code{ckp()}}{
Conditional Kappa will identify the degree of agreement between the two raters for each possible category. See reference [6].


\deqn{
ckp=\frac{pa_i-\frac{\sum^n_{j=1} x_{ \cdot j }}{\sum^n_{i=1}\sum^n_{j=1} x_{ij}}}{1-\frac{\sum^n_{j=1} x_{\cdot j }}{\sum^n_{i=1}\sum^n_{j=1} x_{ij}}}
}

where:

\enumerate{
  \item `ckp`: conditional kappa (producer's).
  \item `pa_i`: producer accuracy.
  \item `x_ii`: diagonal element of the matrix.
  \item `x_.j`: sum with respect to j (rows).
  \item `x_i.`: sum with respect to i (columns).
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$ckp(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Conditional kappa (producer's) and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$ckp(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-mcku"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-mcku}{}}}
\subsection{Method \code{mcku()}}{
Modified kappa index for the user. See reference [8]


\deqn{
mcku=\frac{ua_i-\frac{1}{\sqrt{N}}}{1-\frac{1}{\sqrt{N}}}
}

where:

\enumerate{
  \item `mcku`: modified conditional kappa (user's).
  \item `ua_i`: user accuracy.
  \item N: number of elements of the matrix.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$mcku(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Modified conditional kappa (user's) and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$mcku(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-mckp"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-mckp}{}}}
\subsection{Method \code{mckp()}}{
Modified kappa index for the producer. See reference [8].


\deqn{
mckp=\frac{pa_i-\frac{1}{\sqrt{N}}}{1-\frac{1}{\sqrt{N}}}
}

where:

\enumerate{
  \item `mckp`: modified conditional kappa (producer's).
  \item `pa_i`: producer accuracy.
  \item N: number of elements of the matrix, cardinal of the matrix.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$mckp(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Modified conditional kappa (producer's) and variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$mckp(4)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-ecnu"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-ecnu}{}}}
\subsection{Method \code{ecnu()}}{
Relative entropy is a quantity that measures the difference between two maps. See reference [9].


\deqn{
H(A)=-\sum^n_{j=1}( (\frac{\sum^n_{i=1} x_{i \cdot}}{\sum^n_{i,j=1} x_{ij} }) \cdot \log(\frac{\sum^n_{i=1} x_{i \cdot}}{\sum^n_{i,j=1} x_{ij} }) )
}
\deqn{
H(A|b_i)=-\sum^n_{j=1}( (\frac{ x_{ij}}{\sum^n_{j=1} x_{\cdot j} }) \cdot \log (\frac{x_{ij}}{\sum^n_{j=1} x_{\cdot j}}) )
}
\deqn{
ecnu= \frac{H(A)-H(A|b_i)}{H(A)}
}

where:

\enumerate{
  \item `ecnu`: relative change of entropy given a category on map.
  \item `H(A)`: the entropy of the map.
  \item `x_.j`: sum with respect to j (rows).
  \item `x_i.`: sum with respect to i (columns).
  \item `H(A|b_i)`: Entropy of map A knowing that the location corresponding to map B is in class b_i.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$ecnu(i, v = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate (row).}

\item{\code{v}}{Base of the logarithm. By default v=10. This value is used for the entropy units, v=10(Hartleys), v=2(bits), v=e(nats).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Relative change of entropy given a category on map and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$ecnu(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-ecnp"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-ecnp}{}}}
\subsection{Method \code{ecnp()}}{
Relative entropy is a quantity that measures the difference between two ground truthing. See reference [8].


\deqn{
H(B)=-\sum^n_{i=1}( (\frac{\sum^n_{j=1} x_{\cdot j}}{\sum^n_{i,j=1} x_{ij} }) \cdot \log (\frac{\sum^n_{j=1} x_{\cdot j}}{\sum^n_{i,j=1} x_{ij} }) )
}
\deqn{
H(B|a_j)=-\sum^n_{j=1}( (\frac{ x_{ij}}{\sum^n_{i=1} x_{i \cdot} }) \cdot \log (\frac{x_{ij}}{\sum^n_{i=1} x_{i \cdot}}) )
}
\deqn{
ecnp= \frac{H(B)-H(B|a_j)}{H(B)}
}

where:

\enumerate{
  \item `ecnp`: relative change of entropy given a category on ground truthing.
  \item `H(B)`: the entropy of the map.
  \item `x_.j`: sum with respect to j (rows).
  \item `x_i.`: sum with respect to i (columns).
  \item `H(B|a_j)`: Entropy of map B knowing that the location corresponding to map A is in class a_j.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$ecnp(i, v = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate}

\item{\code{v}}{Base of the logarithm. By default v=10. This value is used for the entropy units, v=10(Hartleys), v=2(bits), v=e(nats).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Relative change of entropy given a category on ground truthing and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$ecnp(4)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-aau"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-aau}{}}}
\subsection{Method \code{aau()}}{
The average accuracy is an average of the accuracy of individual categories. Because the individual categories can be the user's or the producer's accuracy, it can be computed in both ways accordingly. See reference [10].


\deqn{
aau=\frac{1}{\sqrt{N}} \sum^n_{i=1} \frac{x_{ii}}{\sum_{j=1}^n x_{ij}}
}

where:

\enumerate{
  \item `aau`: average accuracy from user's perspective.
  \item N: number of elements of the matrix, cardinal of the matrix.
  \item `x_.j`: sum with respect to j (rows).
  \item `x_ii`: diagonal element of the matrix.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$aau()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Average accuracy from user's perspective and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$aau()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-aap"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-aap}{}}}
\subsection{Method \code{aap()}}{
The average accuracy is an average of the accuracy of individual categories. Because the individual categories can be the user's or the producer's accuracy, it can be computed in both ways accordingly. See reference [10].


\deqn{
aap=\frac{1}{\sqrt{N}} \sum^n_{i=1} \frac{x_{ii}}{\sum_{j=1}^n x_{ji}}
}

where:

\enumerate{
  \item `aap`: average accuracy from producer's perspective.
  \item N: number of elements of the matrix, cardinal of the matrix.
  \item `x_.j`: sum with respect to j (rows).
  \item `x_ii`: diagonal element of the matrix.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$aap()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Average accuracy from producer's perspective and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A <- matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$aap()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-daup"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-daup}{}}}
\subsection{Method \code{daup()}}{
It is the average of the average accuracy from user's and producer's perspective. See reference [2].


\deqn{
daup=\frac{aau+aap}{2}
}

where:

\enumerate{
  \item `daup`: double average of user's and producer's perspective.
  \item `aau`: average accuracy from user's perspective.
  \item `aap`: average accuracy from producer's perspective.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$daup()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Double average of user's and producer's perspective and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$daup()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-CSI"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-CSI}{}}}
\subsection{Method \code{CSI()}}{
The Classification Success Index (CSI) applies to all classes and gives an overall estimation of classification effectiveness. See reference [3,4].


\deqn{
CSI=aau+aap-1
}

where:

\enumerate{
  \item `CSI`: classification succes index.
  \item `aau`: average accuracy from user's perspective.
  \item `aap`: average accuracy from producer's perspective.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$CSI()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Classification sucess index and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$CSI()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-amah"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-amah}{}}}
\subsection{Method \code{amah()}}{
This function provides the average value of the Hellden mean precision index. See reference [2].


\deqn{
amah=\frac{1}{\sqrt{N}}\sum^n_{i=1} \frac{2}{\frac{1}{ua_i}+\frac{1}{pa_i}}
}

where:

\enumerate{
  \item `amah`: average of Hellden's mean accuracy index.
  \item `ua_i`: user accuracy.
  \item `pa_i`: producer accuracy.
  \item N: number of elements of the matrix, cardinal of the matrix.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$amah()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Average of Hellden's mean accuracy index and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$amah()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-amas"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-amas}{}}}
\subsection{Method \code{amas()}}{
This function provides the average of Short's mapping accuracy index. See reference [2].


\deqn{
amas=\frac{1}{\sqrt{N}}\frac{\frac{\sum^n_{i=1} x_{ii}}{\sum^n_{i,j=1}x_{ij}}}{\sum^n_{j=1} x_{\cdot j}+\sum^n_{i=1} x_{i \cdot }-x_{ii}}
}

where:

\enumerate{
  \item `amas`: average of Short's mapping accuracy index.
  \item `x_ii`: diagonal element of the matrix.
  \item `x_.j`: sum with respect to j (rows).
  \item `x_i.`: sum with respect to i (columns).
  \item N: number of elements of the matrix, cardinal of the matrix.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$amas()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Average of Short's mapping accuracy index and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$amas()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-cau"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-cau}{}}}
\subsection{Method \code{cau()}}{
The combined accuracy is the average of the overall accuracy and average accuracy. See reference [10].


\deqn{
cau=\frac{OverallAcc+aau}{2}
}

where:

\enumerate{
  \item cau: combined accuracy from user's perspective.
  \item OverallAcc: overall accuracy.
  \item aau: average accuracy from user's perspective.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$cau()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Combined accuracy from user's perspective and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$cau()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-cap"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-cap}{}}}
\subsection{Method \code{cap()}}{
The combined accuracy is the average of the overall accuracy and average accuracy. See reference [10].


\deqn{
cap=\frac{OverallAcc+aap}{2}
}

where:

\enumerate{
  \item cap: combined accuracy from producer's perspective.
  \item OverallAcc: overall accuracy.
  \item aap: average accuracy from producer's perspective.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$cap()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Combined accuracy from producer's perspective and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$cap()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-caup"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-caup}{}}}
\subsection{Method \code{caup()}}{
The combined accuracy is the average of the overall accuracy and average accuracy. See reference [2].


\deqn{
caup=\frac{OverallAcc+amah}{2}
}

where:

\enumerate{
  \item caup: combined accuracy from both user's and producer's perspectives.
  \item OverallAcc: overall accuracy.
  \item amah: average of Hellden's mean accuracy index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$caup()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Combined accuracy from both user's and producer's perspectives and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$caup()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-KappaValue"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-KappaValue}{}}}
\subsection{Method \code{KappaValue()}}{
It measures the relationship of beyond chance agreement to expected disagreement. See reference [11].


\deqn{
 ea=\sum^n_{i=1} (\frac{x _{\cdot i}}{\sum_{j=1}^n x_{ij}} \cdot \frac{x _{i \cdot}}{\sum_{j=1}^n x_{ij}}) \\
KappaValue=\frac{OverallAcc-ea}{1-ea}
}

where:

\enumerate{
  \item KappaValue: Kappa coefficient.
  \item OverallAcc: overall accuracy.
  \item ea: expected accuracy of agreement if agreement were purely random.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$KappaValue()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Kappa coefficient and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$KappaValue()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-mkp"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-mkp}{}}}
\subsection{Method \code{mkp()}}{
It is the proportion of agreement after chance agreement is removed from consideration. See reference [2].


\deqn{
mkp=\frac{OverallAcc-\frac{1}{\sqrt{N}}}{1-\frac{1}{\sqrt{N}}}
}

where:

\enumerate{
  \item mkp: modified kappa
  \item OverallAcc: overall accuracy.
  \item N: number of elements of the matrix, cardinal of the matrix.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$mkp()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Modified kappa and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$mkp()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-ami"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-ami}{}}}
\subsection{Method \code{ami()}}{
Average mutual information (AMI), is applied to the comparison of thematic maps. See reference [9].


\deqn{
ami=\sum^n_{i,j=1} (\frac{x_{ij}}{\sum^n_{i,j=1} x_{ij}} \cdot \log (\frac{x_{ij}}{\frac{\sum^n_{i=1} x_{i \cdot} \cdot \sum^n_{j=1} x_{\cdot j}}{\sum^n_{i,j=1} x_{ij}}}))
}

where:

\enumerate{
  \item `ami`: average mutual information.
  \item `x_.j`: sum with respect to j (rows).
  \item `x_i.`: sum with respect to i (columns).
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$ami(v = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{v}}{Base of the logarithm. By default v=10. This value is used for the entropy units, v=10(Hartleys), v=2(bits), v=e(nats).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Average mutual information and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$ami()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-nmiu"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-nmiu}{}}}
\subsection{Method \code{nmiu()}}{
See reference [9].


\deqn{
H(B)=-\sum^n_{i=1}( (\frac{\sum^n_{j=1} x_{\cdot j}}{\sum^n_{i,j=1} x_{ij} }) \cdot \log (\frac{\sum^n_{j=1} x_{\cdot j}}{\sum^n_{i,j=1} x_{ij} }) )
}
\deqn{
nmiu=\frac{ami}{H(B)}
}

where:

\enumerate{
  \item `nmiu`: normalized mutual information using the entropy on map.
  \item `H(B)`: the entropy of the map.
  \item `x_.j`: sum with respect to j (rows).
  \item `x_i.`: sum with respect to i (columns).
  \item `ami`: average mutual information.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$nmiu(v = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{v}}{Base of the logarithm. By default v=10. This value is used for the entropy units, v=10(Hartleys), v=2(bits), v=e(nats).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Normalized mutual information using the entropy on map and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$nmiu()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-nmip"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-nmip}{}}}
\subsection{Method \code{nmip()}}{
See reference [9].


\deqn{
H(A)=-\sum^n_{j=1}( (\frac{\sum^n_{i=1} x_{i \cdot}}{\sum^n_{i,j=1} x_{ij} }) \cdot \log(\frac{\sum^n_{i=1} x_{i \cdot}}{\sum^n_{i,j=1} x_{ij} }) )
}
\deqn{
nmip=\frac{ami}{H(A)}
}

where:

\enumerate{
  \item `nmip`: normalized mutual information using the entropy on ground truthing.
  \item `H(A)`: the entropy of the map.
  \item `x_.j`: sum with respect to j (rows).
  \item `x_i.`: sum with respect to i (columns).
  \item `ami`: average mutual information.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$nmip(v = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{v}}{Base of the logarithm. By default v=10. This value is used for the entropy units, v=10(Hartleys), v=2(bits), v=e(nats).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Normalized mutual information using the entropy on ground truthing and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$nmip()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-nmiam"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-nmiam}{}}}
\subsection{Method \code{nmiam()}}{
See reference [12].


\deqn{
H(A)=-\sum^n_{j=1}( (\frac{\sum^n_{i=1} x_{i \cdot}}{\sum^n_{i,j=1} x_{ij} }) \cdot \log(\frac{\sum^n_{i=1} x_{i \cdot}}{\sum^n_{i,j=1} x_{ij} }) )
}
\deqn{
H(B)=-\sum^n_{i=1}( (\frac{\sum^n_{j=1} x_{\cdot j}}{\sum^n_{i,j=1} x_{ij} }) \cdot \log (\frac{\sum^n_{j=1} x_{\cdot j}}{\sum^n_{i,j=1} x_{ij} }) )
}
\deqn{
nmiam=\frac{2ami}{HA+HB}
}

where:

\enumerate{
  \item `nmiam`: normalized mutual information using the arithmetic mean of the entropies on map and on ground truthing.
  \item `H(A)`: the entropy of the map.
  \item `H(B)`: the entropy of the map.
  \item `x_.j`: sum with respect to j (rows).
  \item `x_i.`: sum with respect to i (columns).
  \item `ami`: average mutual information.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$nmiam(v = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{v}}{Base of the logarithm. By default v=10. This value is used for the entropy units, v=10(Hartleys), v=2(bits), v=e(nats).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Normalized mutual information using the arithmetic mean of the entropies on map and on ground truthing and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$nmiam()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-nmigm"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-nmigm}{}}}
\subsection{Method \code{nmigm()}}{
See reference [13].


\deqn{
H(A)=-\sum^n_{j=1}( (\frac{\sum^n_{i=1} x_{i \cdot}}{\sum^n_{i,j=1} x_{ij} }) \cdot \log(\frac{\sum^n_{i=1} x_{i \cdot}}{\sum^n_{i,j=1} x_{ij} }) )
}
\deqn{
H(B)=-\sum^n_{i=1}( (\frac{\sum^n_{j=1} x_{\cdot j}}{\sum^n_{i,j=1} x_{ij} }) \cdot \log (\frac{\sum^n_{j=1} x_{\cdot j}}{\sum^n_{i,j=1} x_{ij} }) )
}
\deqn{
nmigm=\frac{ami}{\sqrt{H(A) \cdot H(B)}}
}

where:

\enumerate{
  \item `nmigm`: normalized mutual information using the geometric mean of the entropies on map and on ground truthing.
  \item `H(A)`: the entropy of the map.
  \item `H(B)`: the entropy of the map.
  \item `x_.j`: sum with respect to j (rows).
  \item `x_i.`: sum with respect to i (columns).
  \item `ami`: average mutual information.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$nmigm(v = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{v}}{Base of the logarithm. By default v=10. This value is used for the entropy units, v=10(Hartleys), v=2(bits), v=e(nats).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Normalized mutual information using the geometric mean of the entropies on map and on ground truthing and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$nmigm()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-nmimx"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-nmimx}{}}}
\subsection{Method \code{nmimx()}}{
See reference [14].


\deqn{
H(A)=-\sum^n_{j=1}( (\frac{\sum^n_{i=1} x_{i \cdot}}{\sum^n_{i,j=1} x_{ij} }) \cdot \log(\frac{\sum^n_{i=1} x_{i \cdot}}{\sum^n_{i,j=1} x_{ij} }) )
}
\deqn{
H(B)=-\sum^n_{i=1}( (\frac{\sum^n_{j=1} x_{\cdot j}}{\sum^n_{i,j=1} x_{ij} }) \cdot \log (\frac{\sum^n_{j=1} x_{\cdot j}}{\sum^n_{i,j=1} x_{ij} }) )
}
\deqn{
nmimx=\frac{2 ami}{max(H(A))+max(H(B))}=\frac{ami}{\log \sqrt{N}}
}

where:

\enumerate{
  \item `nmimx`: normalized mutual information using the arithmetic mean of the maximum entropies on map and on ground truthing
  \item `H(A)`: the entropy of the map.
  \item `H(B)`: the entropy of the map.
  \item `x_.j`: sum with respect to j (rows).
  \item `x_i.`: sum with respect to i (columns).
  \item `ami`: average mutual information.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$nmimx(v = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{v}}{Base of the logarithm. By default v=10. This value is used for the entropy units, v=10(Hartleys), v=2(bits), v=e(nats).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Normalized mutual information using the arithmetic mean of the maximum entropies on map and on ground truthing and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$nmimx()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-Tau"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-Tau}{}}}
\subsection{Method \code{Tau()}}{
Calculate the tau index and its variance. Its value indicates how much the classification has improved compared to a random classification of the N elements into M groups. See reference [15].


The mathematical expression is:

\deqn{
CoefAccPr=\frac{1}{M}
}
\deqn{
Tau = \frac{OverallAcc-CoefAccPr}{1-CoefAccPr}
}

\deqn{
\sigma^2_{Tau}=\frac{OverallAcc \cdot (1-OverallAcc)}{N \cdot (1-CoefAccPr)^2}
}

Where:
\enumerate{
  \item OverallAcc: overall accuracy.
  \item CoefAccPr: a priori random agreement coefficient.
  \item M: number of classes.
  \item N: number of elements of the matrix, cardinal of the matrix.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$Tau()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Tau index and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$Tau()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-CAccuracies"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-CAccuracies}{}}}
\subsection{Method \code{CAccuracies()}}{
User's and producer's accuracies and standard deviations are computed. See reference [1].
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$CAccuracies()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list with the producer's accuracy, its standard deviation, the user's accuracy, and its standard deviation
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$CAccuracies()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-DetailedKappa"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-DetailedKappa}{}}}
\subsection{Method \code{DetailedKappa()}}{
Overall Kappa agreement index and variance elements are computed
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$DetailedKappa()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Overall accuracy, Expected accuracy of agreement if agreement were purely random,,, coefficient kappa, standar desviation kappa,
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$DetailedKappa()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-DetailedCKappa"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-DetailedCKappa}{}}}
\subsection{Method \code{DetailedCKappa()}}{
Class Kappa agreement index (conditional Kappa) and its variance are computed
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$DetailedCKappa()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Kappa index and its standard deviation.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$DetailedCKappa ()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-QES"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-QES}{}}}
\subsection{Method \code{QES()}}{
Quantity, Exchange and Shift values are computed. See reference [16].
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$QES(TI = 1, SF = 1)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{TI}}{Time interval (default value = 1)}

\item{\code{SF}}{Scale factor for results (default value = 1)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
NO VEO MUY CLARO QUE HACE
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$QES(TI=1, SF=6)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-MAllParameters"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-MAllParameters}{}}}
\subsection{Method \code{MAllParameters()}}{
Several parameters are calculated for the given Confusion Matrix. See references [1,11,16].
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$MAllParameters()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Confusion Matrix, Dimension, Total sum of cell values, Overall Accuracy, Variance overall accuracy, Kappa index of global accuracy, Simplified variance of the global Kappa, per-clas producer's accuracy, per-class user's accuracy, k value for the calculation of pseudozeroes, Pseudozeroes Matrix, L matrix for the calculation of pseudozeroes.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$MAllParameters()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-BootStrap"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-BootStrap}{}}}
\subsection{Method \code{BootStrap()}}{
N resamples of the confusion matrix are performed. See reference [17].
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$BootStrap(n)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n}}{Number of resamples.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
n simulated matrices, from the confusion matrix, applying the multinomial distribution
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$BootStrap(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-Normalize"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-Normalize}{}}}
\subsection{Method \code{Normalize()}}{
An iterative process is carried out where each element is divided by the total of the sum of its row, thus obtaining new values. In the next iteration, all the elements are added by columns and each element is divided by the total of its column and they obtain new values, and so on. See reference [18,19].
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$Normalize(n = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n}}{Iteration. By default n=100.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Normalized matrix (Class MatCon) and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$Normalize()$values

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-MPseudozeroes"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-MPseudozeroes}{}}}
\subsection{Method \code{MPseudozeroes()}}{
Small values are calculated for empty cells of the matrix. All non-empty cells of the matrix change their values. This function will not be applied if all the elements of the matrix are different from 0. See reference [19].
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$MPseudozeroes()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
An object of class MatCon with the matrix of Pseudoceros.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-MatCon$new(A)
p$MPseudozeroes()$values

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-DetailedTau"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-DetailedTau}{}}}
\subsection{Method \code{DetailedTau()}}{
Overall Tau agreement index and variance elements  are computed.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$DetailedTau(WV)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{WV}}{Weights vector (as matrix)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
NO LO VEO CLARO. Overall accuracy index, producer accurancy index, O3,O4, Tau index?(mirar definicion en funcion) y its standard desviation.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
WV <-matrix(c(0.4, 0.1, 0.4, 0.1), ncol=4)
p<-MatCon$new(A)
p$DetailedTau(WV)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-DetailedWKappa"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-DetailedWKappa}{}}}
\subsection{Method \code{DetailedWKappa()}}{
Overall Kappa agreement index (Weighted) and its variance are computed
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$DetailedWKappa(WM)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{WM}}{Weight matrix}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Weight matrix, kappa index obtained from the original matrix and the weight matrix, and its variance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A <- A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
WM<- t(matrix(c(1,0,0.67,1,0,1,0,0,1,0,1,1,0.91,0,0.61,1), nrow = 4, ncol=4))
p<-MatCon$new(A)
p$DetailedWKappa(WM)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-CAccuraciesW"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-CAccuraciesW}{}}}
\subsection{Method \code{CAccuraciesW()}}{
User's and producer's weighted accuracies and standard deviations are computed. See reference [1].
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$CAccuraciesW(WM)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{WM}}{Weight matrix}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Weight matrix, Matrix formed with its original elements and their corresponding weights, general accuracy of the weight matrix obtained, accuracy of the producer and user and their standard deviations,
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A <- t(matrix(c(35, 14,11,1,4,11,3,0,12,9,38,4,2,5,12,2), nrow = 4, ncol=4))
p<-MatCon$new(A)
WM<- t(matrix(c(1,0,0.67,1,0,1,0,0,1,0,1,1,0.91,0,0.61,1), nrow = 4, ncol=4))
p$CAccuraciesW(WM)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MatCon-clone"></a>}}
\if{latex}{\out{\hypertarget{method-MatCon-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MatCon$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
