% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ConfMatrix.R
\name{ConfMatrix}
\alias{ConfMatrix}
\title{Confusion matrix}
\value{
Object of class ConfMatrix.
}
\description{
In the ConfMatrix class works with confusion matrices,
thus providing the possibility of calculating various indices to obtain
information on the given matrices, their variances and their
confidence intervals. The most important global indices are presented
graphically, in addition to the user and producer accuracies.
}
\note{
Error Messages

List of possible errors:
\itemize{
 \item \code{Error type 1}: Non-square matrix.
 \item \code{Error type 2}: Single element matrix.
 \item \code{Error type 3}: negative values.
 \item \code{Error type 4}: Sum of elements 0.
 \item \code{Error type 5}: Sum of rows 0.
 \item \code{Error type 6}: Sum of columns 0.
 \item \code{Error type 7}: It is not a matrix.
}
}
\examples{
A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
cm<-ConfMatrix$new (A,ID=5,Date="27-10-2023",
Source="Congalton and Green, 2008")


## ------------------------------------------------
## Method `ConfMatrix$new`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
cm<-ConfMatrix$new (A,ID=5,Date="27-10-2023",
Source="Congalton and Green, 2008")


## ------------------------------------------------
## Method `ConfMatrix$OverallAcc`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A)
p$OverallAcc()


## ------------------------------------------------
## Method `ConfMatrix$UserAcc`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$UserAcc()


## ------------------------------------------------
## Method `ConfMatrix$UserAcc_i`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$UserAcc_i(2)


## ------------------------------------------------
## Method `ConfMatrix$ProdAcc`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$ProdAcc()


## ------------------------------------------------
## Method `ConfMatrix$ProdAcc_i`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$ProdAcc_i(1)


## ------------------------------------------------
## Method `ConfMatrix$AvUserProdAcc_i`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AvUserProdAcc_i(2)


## ------------------------------------------------
## Method `ConfMatrix$Sucess`
## ------------------------------------------------

A<-matrix(c(0.3,0.02,0.01,0.12,0.19,0.03,0.02,0.01,0.3),
nrow=3,ncol=3)
p<-ConfMatrix$new(A,Source="Labatut and Cherifi 2011")
p$Sucess()


## ------------------------------------------------
## Method `ConfMatrix$Sucess_i`
## ------------------------------------------------

A<-matrix(c(0.3,0.02,0.01,0.12,0.19,0.03,0.02,0.01,0.3),
nrow=3,ncol=3)
p<-ConfMatrix$new(A,Source="Labatut and Cherifi 2011")
p$Sucess_i(2)


## ------------------------------------------------
## Method `ConfMatrix$AvHelldenAcc_i`
## ------------------------------------------------

A <- matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,39,
7,1,1,0,6,25,1,1,0,0,1,6), nrow=5,ncol=5)
p<-ConfMatrix$new(A,Source="Rosenfield and Fitzpatrick 1986")
p$AvHelldenAcc_i(2)


## ------------------------------------------------
## Method `ConfMatrix$ShortAcc_i`
## ------------------------------------------------

A <- matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,
39,7,1,1,0,6,25,1,1,0,0,1,6), nrow=5,ncol=5)
p<-ConfMatrix$new(A,Source="Rosenfield and Fitzpatrick-Lins 1986")
p$ShortAcc_i(2)


## ------------------------------------------------
## Method `ConfMatrix$UserKappa_i`
## ------------------------------------------------

A<-matrix(c(73,13,5,1,0,21,32,13,3,0,16,39,35,
29,13,3,5,7,28,48,1,0,2,3,17), nrow=5,ncol=5)
p<-ConfMatrix$new(A,Source="Næsset 1996")
p$UserKappa_i(2)


## ------------------------------------------------
## Method `ConfMatrix$ProdKappa_i`
## ------------------------------------------------

A<-matrix(c(73,13,5,1,0,21,32,13,3,0,16,39,35,
29,13,3,5,7,28,48,1,0,2,3,17), nrow=5,ncol=5)
p<-ConfMatrix$new(A,Source="Næsset 1996")
p$ProdKappa_i(2)


## ------------------------------------------------
## Method `ConfMatrix$ModKappa`
## ------------------------------------------------

A<-matrix(c(317,61,2,35,23,120,4,29,0,0,60,0,0,0,0,8),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Foody 1992")
p$ModKappa()


## ------------------------------------------------
## Method `ConfMatrix$ModKappaUser_i`
## ------------------------------------------------

A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Liu et al. 2007")
p$ModKappaUser_i(2)


## ------------------------------------------------
## Method `ConfMatrix$ModKappaProd_i`
## ------------------------------------------------

A<-matrix(c(317,61,2,35,23,120,4,29,0,0,60,0,0,0,0,8),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Liu et al. 2007")
p$ModKappaProd_i(2)


## ------------------------------------------------
## Method `ConfMatrix$EntropUser_i`
## ------------------------------------------------

A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Liu et al. 2007")
p$EntropUser_i(1)


## ------------------------------------------------
## Method `ConfMatrix$EntropProd_i`
## ------------------------------------------------

A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Liu et al. 2007")
p$EntropProd_i(2)


## ------------------------------------------------
## Method `ConfMatrix$AvUserAcc`
## ------------------------------------------------

A<-matrix(c(352,43,89,203),nrow=2,ncol=2)
p<-ConfMatrix$new(A,Source="Tung and LeDrew 1988")
p$AvUserAcc()


## ------------------------------------------------
## Method `ConfMatrix$AvProdAcc`
## ------------------------------------------------

A<-matrix(c(352,43,89,203),nrow=2,ncol=2)
p<-ConfMatrix$new(A,Source="Tung and LeDrew 1988")
p$AvProdAcc()


## ------------------------------------------------
## Method `ConfMatrix$AvUserProdAcc`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AvUserProdAcc()


## ------------------------------------------------
## Method `ConfMatrix$AvHelldenAcc`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AvHelldenAcc()


## ------------------------------------------------
## Method `ConfMatrix$AvShortAcc`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AvShortAcc()


## ------------------------------------------------
## Method `ConfMatrix$CombUserAcc`
## ------------------------------------------------

A<-matrix(c(352,43,89,203),nrow=2,ncol=2)
p<-ConfMatrix$new(A,Source="Tung and LeDrew 1988")
p$CombUserAcc()


## ------------------------------------------------
## Method `ConfMatrix$CombProdAcc`
## ------------------------------------------------

A<-matrix(c(352,43,89,203),nrow=2,ncol=2)
p<-ConfMatrix$new(A,Source="Tung and LeDrew 1988")
p$CombProdAcc()


## ------------------------------------------------
## Method `ConfMatrix$CombUserProdAcc`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$CombUserProdAcc()


## ------------------------------------------------
## Method `ConfMatrix$Kappa`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$Kappa()


## ------------------------------------------------
## Method `ConfMatrix$Entrop`
## ------------------------------------------------

A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Liu et al. 2007")
p$Entrop()


## ------------------------------------------------
## Method `ConfMatrix$NormEntropUser`
## ------------------------------------------------

A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Liu et al. 2007")
p$NormEntropUser()


## ------------------------------------------------
## Method `ConfMatrix$NormEntropProd`
## ------------------------------------------------

A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Liu et al. 2007")
p$NormEntropProd()


## ------------------------------------------------
## Method `ConfMatrix$AvNormEntrop`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AvNormEntrop()


## ------------------------------------------------
## Method `ConfMatrix$GeomAvNormEntrop`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$GeomAvNormEntrop()


## ------------------------------------------------
## Method `ConfMatrix$AvMaxNormEntrop`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AvMaxNormEntrop()


## ------------------------------------------------
## Method `ConfMatrix$Tau`
## ------------------------------------------------

A<-matrix(c(238051,7,132,0,0,24,9,2,189,1,4086,188,0,4,16,45,1,0,939,5082,
51817,0,34,500,1867,325,17,0,0,5,11148,1618,78,0,0,0,0,48,4,834,2853,340,
32,0,197,5,151,119,135,726,6774,75,1,553,0,105,601,110,174,155,8257,8,0,
29,36,280,0,0,6,5,2993,0,115,2,0,4,124,595,0,0,4374),nrow=9,ncol=9)
p<-ConfMatrix$new(A,Source="Muñoz 2016")
p$Tau()


## ------------------------------------------------
## Method `ConfMatrix$GroundTruth`
## ------------------------------------------------

A<-matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,39,7,1,1,0,
6,25,1,1,0,0,1,6),nrow=5,ncol=5)
p<-ConfMatrix$new(A,Source="Türk 1979")
p$GroundTruth()


## ------------------------------------------------
## Method `ConfMatrix$UserProdAcc`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$UserProdAcc()


## ------------------------------------------------
## Method `ConfMatrix$DetailedKappa`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$DetailedKappa()


## ------------------------------------------------
## Method `ConfMatrix$DetailedCondKappa`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$DetailedCondKappa ()


## ------------------------------------------------
## Method `ConfMatrix$QES`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$QES(TI=1, SF=6)


## ------------------------------------------------
## Method `ConfMatrix$MTypify`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A, Source="Congalton and Green 2008")
p$MTypify(RaR=5)

## ------------------------------------------------
## Method `ConfMatrix$AllParameters`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AllParameters()


## ------------------------------------------------
## Method `ConfMatrix$MBootStrap`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A, Source="Congalton and Green 2008")
p$MBootStrap(2)


## ------------------------------------------------
## Method `ConfMatrix$MNormalize`
## ------------------------------------------------

A<-matrix(c(238051,7,132,0,0,24,9,2,189,1,4086,188,0,4,16,45,1,0,939,5082,
51817,0,34,500,1867,325,17,0,0,5,11148,1618,78,0,0,0,0,48,4,834,2853,340,
32,0,197,5,151,119,135,726,6774,75,1,553,0,105,601,110,174,155,8257,8,0,
29,36,280,0,0,6,5,2993,0,115,2,0,4,124,595,0,0,4374),nrow=9,ncol=9)
p<-ConfMatrix$new(A,Source="Muñoz 2016")
p$MNormalize()$values


## ------------------------------------------------
## Method `ConfMatrix$MPseudoZeroes`
## ------------------------------------------------

A<-matrix(c(238051,7,132,0,0,24,9,2,189,1,4086,188,0,4,16,45,1,0,939,5082,
51817,0,34,500,1867,325,17,0,0,5,11148,1618,78,0,0,0,0,48,4,834,2853,340,
32,0,197,5,151,119,135,726,6774,75,1,553,0,105,601,110,174,155,8257,8,0,
29,36,280,0,0,6,5,2993,0,115,2,0,4,124,595,0,0,4374),nrow=9,ncol=9)
p<-ConfMatrix$new(A,Source="Muñoz 2016")
p$MPseudoZeroes()


## ------------------------------------------------
## Method `ConfMatrix$DetailedWTau`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
WV <-matrix(c(0.4, 0.1, 0.4, 0.1), ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$DetailedWTau(WV)


## ------------------------------------------------
## Method `ConfMatrix$DetailedWKappa`
## ------------------------------------------------

A <- A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
WM<- t(matrix(c(1,0,0.67,1,0,1,0,0,1,0,1,1,0.91,0,0.61,1),
nrow = 4, ncol=4))
p<-ConfMatrix$new(A)
p$DetailedWKappa(WM)


## ------------------------------------------------
## Method `ConfMatrix$UserProdAcc_W`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
WM<- t(matrix(c(1,0,0.67,1,0,1,0,0,1,0,1,1,0.91,0,0.61,1),
nrow = 4, ncol=4))
p$UserProdAcc_W(WM)


## ------------------------------------------------
## Method `ConfMatrix$StHell`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
r<-ConfMatrix$new(A,Source="Congalton and Green 2008")
B<-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),
nrow=4,ncol=4)
f<-ConfMatrix$new(B,Source="Congalton and Green 2008")
p$StHell(f)


## ------------------------------------------------
## Method `ConfMatrix$Kappa.test`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
B<-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),nrow=4,ncol=4)
f<-ConfMatrix$new(B,Source="Congalton and Green 2008")
p$Kappa.test(f)


## ------------------------------------------------
## Method `ConfMatrix$OverallAcc.test`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
B<-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),nrow=4,ncol=4)
f<-ConfMatrix$new(B,Source="Congalton and Green 2008")
p$OverallAcc.test(f)


## ------------------------------------------------
## Method `ConfMatrix$Tau.test`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
B<-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),
nrow=4,ncol=4)
f<-ConfMatrix$new(B,Source="Congalton and Green 2008")
p$Tau.test(f)


## ------------------------------------------------
## Method `ConfMatrix$TSCM.test`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
B<-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),
nrow=4,ncol=4)
f<-ConfMatrix$new(B,Source="Congalton and Green 2008")
p$TSCM.test(f)


## ------------------------------------------------
## Method `ConfMatrix$QIndep.test`
## ------------------------------------------------

A<-matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,39,
7,1,1,0,6,25,1,1,0,0,1,6),nrow=5,ncol=5)
p<-ConfMatrix$new(A,Source= "Türk 1979")
p$QIndep.test()


## ------------------------------------------------
## Method `ConfMatrix$plot.global`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$plot.global()


## ------------------------------------------------
## Method `ConfMatrix$plot.class`
## ------------------------------------------------

A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$plot.class()

}
\references{
\insertRef{congalton2008}{ConfMatrix}

\insertRef{liu2007}{ConfMatrix}

\insertRef{koukoulas2001}{ConfMatrix}

\insertRef{turk2002}{ConfMatrix}

\insertRef{hellden1980}{ConfMatrix}

\insertRef{rosenfield1986}{ConfMatrix}

\insertRef{short1982}{ConfMatrix}

\insertRef{finn1993}{ConfMatrix}

\insertRef{tung1988}{ConfMatrix}

\insertRef{cohen1960}{ConfMatrix}

\insertRef{strehl2002}{ConfMatrix}

\insertRef{ghosh2002}{ConfMatrix}

\insertRef{strehl2002relationship}{ConfMatrix}

\insertRef{book}{ConfMatrix}

\insertRef{pontius2014}{ConfMatrix}

\insertRef{ariza2011}{ConfMatrix}

\insertRef{fienberg1970}{ConfMatrix}

\insertRef{munoz2016}{ConfMatrix}

\insertRef{foody1992}{ConfMatrix}

\insertRef{garcia2018}{ConfMatrix}

\insertRef{ma1995Tau}{ConfMatrix}

\insertRef{alba2020}{ConfMatrix}

\insertRef{turk1979gt}{ConfMatrix}goodman1968analysis

\insertRef{goodman1968analysis}{ConfMatrix}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-ConfMatrix-new}{\code{ConfMatrix$new()}}
\item \href{#method-ConfMatrix-OverallAcc}{\code{ConfMatrix$OverallAcc()}}
\item \href{#method-ConfMatrix-UserAcc}{\code{ConfMatrix$UserAcc()}}
\item \href{#method-ConfMatrix-UserAcc_i}{\code{ConfMatrix$UserAcc_i()}}
\item \href{#method-ConfMatrix-ProdAcc}{\code{ConfMatrix$ProdAcc()}}
\item \href{#method-ConfMatrix-ProdAcc_i}{\code{ConfMatrix$ProdAcc_i()}}
\item \href{#method-ConfMatrix-AvUserProdAcc_i}{\code{ConfMatrix$AvUserProdAcc_i()}}
\item \href{#method-ConfMatrix-Sucess}{\code{ConfMatrix$Sucess()}}
\item \href{#method-ConfMatrix-Sucess_i}{\code{ConfMatrix$Sucess_i()}}
\item \href{#method-ConfMatrix-AvHelldenAcc_i}{\code{ConfMatrix$AvHelldenAcc_i()}}
\item \href{#method-ConfMatrix-ShortAcc_i}{\code{ConfMatrix$ShortAcc_i()}}
\item \href{#method-ConfMatrix-UserKappa_i}{\code{ConfMatrix$UserKappa_i()}}
\item \href{#method-ConfMatrix-ProdKappa_i}{\code{ConfMatrix$ProdKappa_i()}}
\item \href{#method-ConfMatrix-ModKappa}{\code{ConfMatrix$ModKappa()}}
\item \href{#method-ConfMatrix-ModKappaUser_i}{\code{ConfMatrix$ModKappaUser_i()}}
\item \href{#method-ConfMatrix-ModKappaProd_i}{\code{ConfMatrix$ModKappaProd_i()}}
\item \href{#method-ConfMatrix-EntropUser_i}{\code{ConfMatrix$EntropUser_i()}}
\item \href{#method-ConfMatrix-EntropProd_i}{\code{ConfMatrix$EntropProd_i()}}
\item \href{#method-ConfMatrix-AvUserAcc}{\code{ConfMatrix$AvUserAcc()}}
\item \href{#method-ConfMatrix-AvProdAcc}{\code{ConfMatrix$AvProdAcc()}}
\item \href{#method-ConfMatrix-AvUserProdAcc}{\code{ConfMatrix$AvUserProdAcc()}}
\item \href{#method-ConfMatrix-AvHelldenAcc}{\code{ConfMatrix$AvHelldenAcc()}}
\item \href{#method-ConfMatrix-AvShortAcc}{\code{ConfMatrix$AvShortAcc()}}
\item \href{#method-ConfMatrix-CombUserAcc}{\code{ConfMatrix$CombUserAcc()}}
\item \href{#method-ConfMatrix-CombProdAcc}{\code{ConfMatrix$CombProdAcc()}}
\item \href{#method-ConfMatrix-CombUserProdAcc}{\code{ConfMatrix$CombUserProdAcc()}}
\item \href{#method-ConfMatrix-Kappa}{\code{ConfMatrix$Kappa()}}
\item \href{#method-ConfMatrix-Entrop}{\code{ConfMatrix$Entrop()}}
\item \href{#method-ConfMatrix-NormEntropUser}{\code{ConfMatrix$NormEntropUser()}}
\item \href{#method-ConfMatrix-NormEntropProd}{\code{ConfMatrix$NormEntropProd()}}
\item \href{#method-ConfMatrix-AvNormEntrop}{\code{ConfMatrix$AvNormEntrop()}}
\item \href{#method-ConfMatrix-GeomAvNormEntrop}{\code{ConfMatrix$GeomAvNormEntrop()}}
\item \href{#method-ConfMatrix-AvMaxNormEntrop}{\code{ConfMatrix$AvMaxNormEntrop()}}
\item \href{#method-ConfMatrix-Tau}{\code{ConfMatrix$Tau()}}
\item \href{#method-ConfMatrix-GroundTruth}{\code{ConfMatrix$GroundTruth()}}
\item \href{#method-ConfMatrix-UserProdAcc}{\code{ConfMatrix$UserProdAcc()}}
\item \href{#method-ConfMatrix-DetailedKappa}{\code{ConfMatrix$DetailedKappa()}}
\item \href{#method-ConfMatrix-DetailedCondKappa}{\code{ConfMatrix$DetailedCondKappa()}}
\item \href{#method-ConfMatrix-QES}{\code{ConfMatrix$QES()}}
\item \href{#method-ConfMatrix-MTypify}{\code{ConfMatrix$MTypify()}}
\item \href{#method-ConfMatrix-AllParameters}{\code{ConfMatrix$AllParameters()}}
\item \href{#method-ConfMatrix-MBootStrap}{\code{ConfMatrix$MBootStrap()}}
\item \href{#method-ConfMatrix-MNormalize}{\code{ConfMatrix$MNormalize()}}
\item \href{#method-ConfMatrix-MPseudoZeroes}{\code{ConfMatrix$MPseudoZeroes()}}
\item \href{#method-ConfMatrix-DetailedWTau}{\code{ConfMatrix$DetailedWTau()}}
\item \href{#method-ConfMatrix-DetailedWKappa}{\code{ConfMatrix$DetailedWKappa()}}
\item \href{#method-ConfMatrix-UserProdAcc_W}{\code{ConfMatrix$UserProdAcc_W()}}
\item \href{#method-ConfMatrix-StHell}{\code{ConfMatrix$StHell()}}
\item \href{#method-ConfMatrix-Kappa.test}{\code{ConfMatrix$Kappa.test()}}
\item \href{#method-ConfMatrix-OverallAcc.test}{\code{ConfMatrix$OverallAcc.test()}}
\item \href{#method-ConfMatrix-Tau.test}{\code{ConfMatrix$Tau.test()}}
\item \href{#method-ConfMatrix-TSCM.test}{\code{ConfMatrix$TSCM.test()}}
\item \href{#method-ConfMatrix-QIndep.test}{\code{ConfMatrix$QIndep.test()}}
\item \href{#method-ConfMatrix-plot.global}{\code{ConfMatrix$plot.global()}}
\item \href{#method-ConfMatrix-plot.class}{\code{ConfMatrix$plot.class()}}
\item \href{#method-ConfMatrix-clone}{\code{ConfMatrix$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-new"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-new}{}}}
\subsection{Method \code{new()}}{
Public method to create an instance of the ConfMatrix class.
When creating it, values must be given to the matrix. The optional
possibility of adding metadata to the matrix is offered.
The creation includes a series of checks on the data that, if not met,
give coded error messages. The values of the matrix must be organized in
such a way that the columns represent the categories in the reference
and the rows represent the categories in the product being evaluated.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$new(values, ID = NULL, Date = NULL, Source = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{values}}{Confusion matrix}

\item{\code{ID}}{Identifier. By default, the date in YYYYMMDD format will be
taken as the ID.}

\item{\code{Date}}{Date provided by the user. By default the date provided by
the system will be taken.}

\item{\code{Source}}{Indicates where the matrix comes from (article, project,
etc.). By default is NULL.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Object of class ConfMatrix or an error if a matrix isn't entered.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
cm<-ConfMatrix$new (A,ID=5,Date="27-10-2023",
Source="Congalton and Green, 2008")

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-OverallAcc"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-OverallAcc}{}}}
\subsection{Method \code{OverallAcc()}}{
Public method to calculate the global index called
Overall accuracy. The Overall accuracy for a particular classified
image/map is then calculated by dividing the sum of the entries that
form the major diagonal (i.e., the number of correct classifications)
by the total number of samples taken. The method also offers the
variance. The reference \insertCite{congalton2008}{ConfMatrix}
is followed for the computations.


The mathematical expression is:

\deqn{
OverallAcc = \dfrac{\sum_{i=1}^{n} x_{ii}}{\sum_{i, j=1}^{n} x_{ij}}
}

\deqn{
\sigma^2_{OverallAcc}=\dfrac{OverallAcc \cdot (1-OverallAcc)}{N}
}
Where:
\enumerate{
  \item \eqn{OverallAcc}: overall accuracy.
  \item \eqn{x_{ii}}: diagonal element of the matrix.
  \item \eqn{x_{ij}}: element of the matrix.
  \item \eqn{N}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$OverallAcc(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of the overall accuracy, its variance, and its
confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A)
p$OverallAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-UserAcc"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-UserAcc}{}}}
\subsection{Method \code{UserAcc()}}{
Public method for deriving a class index called
user's accuracy. The user's accuracy for the class i of thematic
map is calculated by dividing the value in the diagonal of class i
by the sum of all values in the row of the class i. The method also
offers the variance. The reference
\insertCite{congalton2008}{ConfMatrix} is followed
for the computations.


The mathematical expression is:
\deqn{
UserAcc=\dfrac{x_{ii}}{\sum_{j=1}^n x_{ij}}
}
 \deqn{
\sigma^2_{UserAcc}=\dfrac{UserAcc \cdot (1-UserAcc)}{N}
}
where:

\enumerate{
  \item \eqn{UserAcc}: user accuracy.
  \item \eqn{x_{ii}}: diagonal element of the matrix.
  \item \eqn{x_{ij}}: element of the matrix.
  \item \eqn{N}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$UserAcc(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with a vector of values for the user's accuracy
rate for all classes, another vector with their variances and
confidence intervals for each class.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$UserAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-UserAcc_i"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-UserAcc_i}{}}}
\subsection{Method \code{UserAcc_i()}}{
Public method where the user's accuracy index is
defined for a specific class i. The user precision for class i
of the thematic map is calculated by dividing the value on the
diagonal of class i by the sum of all values in the row of class i.
The method also offers variance. The reference
\insertCite{congalton2008}{ConfMatrix} is followed for
the calculations.


\deqn{
UserAcc_{i}=\dfrac{x_{ii}}{\sum_{j=1}^n x_{ij}}
}
\deqn{
\sigma^2_{UserAcc_i}=\dfrac{UserAcc_i \cdot (1-UserAcc_i)}{N}
}


where:

\enumerate{
  \item \eqn{UserAcc_i}: user accuracy index for class i.
  \item \eqn{x_{ii}}: diagonal element of the matrix.
  \item \eqn{x_{ij}}: element of the matrix.
  \item \eqn{N}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$UserAcc_i(i, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{User class to evaluate.}

\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of the user's accuracy index values for class i,
its variance and its confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$UserAcc_i(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-ProdAcc"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-ProdAcc}{}}}
\subsection{Method \code{ProdAcc()}}{
Public method for deriving a class index called
producer's accuracy. The producer's accuracy for the class i of
thematic map is calculated by dividing the value in the diagonal
of class i by the sum of all values in the column of the class i.
The method also offers the variance. The reference
\insertCite{congalton2008}{ConfMatrix} if followed for the
computations.


\deqn{
ProdAcc=\dfrac{x_{jj}}{\sum_{j=1}^n x_{ij}}
}
\deqn{
\sigma^2_{ProdAcc}=\dfrac{ProdAcc \cdot (1-ProdAcc)}{N}
}
where:

\enumerate{
  \item \eqn{ProdAcc}: producer accuracy.
  \item \eqn{x_{jj}}: diagonal element of the matrix.
  \item \eqn{x_{ij}}: element of the matrix.
  \item \eqn{N}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$ProdAcc(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with a vector of values for the producer's
accuracy index of all classes, another vector with their variances
and confidence intervals for each class.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$ProdAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-ProdAcc_i"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-ProdAcc_i}{}}}
\subsection{Method \code{ProdAcc_i()}}{
Public method where the producer's accuracy index is
defined for a specific class i. The user precision for class i of
the thematic map is calculated by dividing the value on the diagonal
of class i by the sum of all values in the column of class i. The
method also offers variance. The reference
\insertCite{congalton2008}{ConfMatrix} is followed for the
calculations.


\deqn{
ProdAcc_{i}=\dfrac{x_{jj}}{\sum_{j=1}^n x_{ij}}
}
\deqn{
\sigma^2_{ProdAcc_i}=\dfrac{ProdAcc_i \cdot (1-ProdAcc_i)}{N}
}

where:

\enumerate{
  \item \eqn{ProdAcc_i}: producer accuracy index for class i.
  \item \eqn{x_{jj}}: diagonal element of the matrix.
  \item \eqn{x_{ij}}: element of the matrix.
  \item \eqn{N}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$ProdAcc_i(i, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Producer class to evaluate.}

\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of the producer's accuracy index values for class i,
its variance and its confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$ProdAcc_i(1)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-AvUserProdAcc_i"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-AvUserProdAcc_i}{}}}
\subsection{Method \code{AvUserProdAcc_i()}}{
Public method that provides the average of the
accuracy rates of the user and producer of a specific class.
The method also offers variance. The reference
\insertCite{liu2007}{ConfMatrix} is followed for the calculations.


The mathematical expression is:
 \deqn{
AvUserProdAcc_i=\dfrac{UserAcc_i+ProdAcc_i}{2}
}
\deqn{
\sigma^2_{AvUserProdAcc_i}=\dfrac{AvUserProdAcc_i
\cdot (1-AvUserProdAcc_i)}{N}
}
where:

\enumerate{
  \item \eqn{AvUserProdAcc_i}: average of user's and producer's
  accuracy.
  \item \eqn{UserAcc_i}: user accuracy index for class i.
  \item \eqn{ProdAcc_i}: producer accuracy index for class i.
  \item \eqn{N}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$AvUserProdAcc_i(i, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}

\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with average of user's and producer's accuracy,
its variance for class i and its confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AvUserProdAcc_i(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-Sucess"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-Sucess}{}}}
\subsection{Method \code{Sucess()}}{
Public method that provides the Classification
Success Index (CSI) applies to all class and gives an overall
estimation of classification effectiveness. The references
\insertCite{koukoulas2001,turk2002}{ConfMatrix} is followed
for the calculations.


The mathematical expression is:
 \deqn{
Sucess=1-(1-AvUserAcc+1-AvProdAcc)=AvUserAcc+AvProdAcc-1
}
 \deqn{
VarSucess=\dfrac{Sucess \cdot (1-Sucess)}{N}
}

where:

\enumerate{
  \item \eqn{Sucess}: classification succes index.
  \item \eqn{AvUserAcc}: average accuracy from user's perspective.
  \item \eqn{AvProdAcc}: average accuracy from producer's perspective.
  \item \eqn{N}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$Sucess(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with the classification success index, its
variance and its confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(0.3,0.02,0.01,0.12,0.19,0.03,0.02,0.01,0.3),
nrow=3,ncol=3)
p<-ConfMatrix$new(A,Source="Labatut and Cherifi 2011")
p$Sucess()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-Sucess_i"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-Sucess_i}{}}}
\subsection{Method \code{Sucess_i()}}{
Public method that provides the Individual
Classification Success Index (ICSI) applies to the classification
effectiveness for one particular class of interest.
The references \insertCite{koukoulas2001,turk2002}{ConfMatrix}
is followed for the calculations.


The mathematical expression is:
 \deqn{
Sucess_i=1-(1-UserAcc_i+1-ProdAcc_i)=UserAcc_i+ProdAcc_i-1
}

\deqn{
\sigma^2_{Sucess_i}=\dfrac{Sucess_i \cdot (1-Sucess_i)}{N}
}

where:

\enumerate{
  \item \eqn{Sucess_i}: individual classification success index.
  \item \eqn{UserAcc_i}: user accuracy index for class i.
  \item \eqn{ProdAcc_i}: producer accuracy index for class i.
  \item \eqn{N}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$Sucess_i(i, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}

\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with the individual classification success index,
its variance and its confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(0.3,0.02,0.01,0.12,0.19,0.03,0.02,0.01,0.3),
nrow=3,ncol=3)
p<-ConfMatrix$new(A,Source="Labatut and Cherifi 2011")
p$Sucess_i(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-AvHelldenAcc_i"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-AvHelldenAcc_i}{}}}
\subsection{Method \code{AvHelldenAcc_i()}}{
Public method that provides the Hellden' average
accuracy, denotes for the probability that a randomly chosen point
of a specific class on the map has a correspondence of the same
class in the same position in the field and that a randomly chosen
point in the field of the same class has a correspondence of the
same class in the same position on the map.The method also offers
variance. The references
\insertCite{hellden1980,rosenfield1986}{ConfMatrix} is
followed for the calculations.


\deqn{
AvHelldenAcc_i=\dfrac{2}{\dfrac{1}{UserAcc_i}+\dfrac{1}{ProdAcc_i}}
}
\deqn{
\sigma^2_{AvHelldenAcc_i}=\dfrac{AvHelldenAcc_i \cdot (1-AvHelldenAcc_i)}{N}
}
where:

\enumerate{
  \item \eqn{AvHelldenAcc_i}: Hellden's mean accuracy.
  \item \eqn{UserAcc_i}: user accuracy index for class i.
  \item \eqn{ProdAcc_i}: producer accuracy index for class i.
  \item \eqn{N}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$AvHelldenAcc_i(i, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}

\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with Hellden's mean accuracy, its variance and
its confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A <- matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,39,
7,1,1,0,6,25,1,1,0,0,1,6), nrow=5,ncol=5)
p<-ConfMatrix$new(A,Source="Rosenfield and Fitzpatrick 1986")
p$AvHelldenAcc_i(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-ShortAcc_i"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-ShortAcc_i}{}}}
\subsection{Method \code{ShortAcc_i()}}{
Public method that provides Short's mapping accuracy
for each class is stated as the number of correctly classified
pixels (equal to the total in the correctly classified area) in
terms of all pixels affected by its classification (equal to this
total in the displayed area as well as the pixels involved in errors
of commission and omission). The method also offers variance.
The references \insertCite{rosenfield1986,short1982}{ConfMatrix}
is followed for the calculations.


\deqn{
ShortAcc_i=\dfrac{x_{ii}}{\sum^n_{j=1} x_{+ j}+
\sum^n_{i=1} x_{i +}-x_{ii}}
}
\deqn{
\sigma^2_{ShortAcc_i}=\dfrac{ShortAcc_i \cdot (1-ShortAcc_i)}{N}
}
where:

\enumerate{
  \item \eqn{ShortAcc_i}: Short's mapping accuracy
  \item \eqn{x_{ii}}: diagonal element of the matrix.
  \item \eqn{x_{j+}}: sum of all elements in rows j.
  \item \eqn{x_{+j}}: sum of all elements in column j.
  \item \eqn{N}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$ShortAcc_i(i, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}

\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with Short's mapping accuracy, its variance
and its confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A <- matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,
39,7,1,1,0,6,25,1,1,0,0,1,6), nrow=5,ncol=5)
p<-ConfMatrix$new(A,Source="Rosenfield and Fitzpatrick-Lins 1986")
p$ShortAcc_i(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-UserKappa_i"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-UserKappa_i}{}}}
\subsection{Method \code{UserKappa_i()}}{
Public method that evaluates the kappa coefficient
from the user's perspective, for a specific class i. The method
also offers variance. The reference
\insertCite{rosenfield1986}{ConfMatrix} is followed
for the calculations.


\deqn{
UserKappa_i=\dfrac{UserAcc_i-\dfrac{\sum^n_{i=1} x_{i + }}
{\sum^n_{i=1}\sum^n_{j=1} x_{ij}}}{1-\dfrac{\sum^n_{i=1} x_{i + }}
{\sum^n_{i=1}\sum^n_{j=1} x_{ij}}}
}
 \deqn{
\sigma^2_{UserKappa_i}=\dfrac{UserKappa_i \cdot (1-UserKappa_i)}{N}
}
where:

\enumerate{
  \item \eqn{UserKappa_i}: coefficient kappa (user's).
  \item \eqn{UserAcc_i}: user accuracy index for class i.
  \item \eqn{x_{ii}}: diagonal element of the matrix.
  \item \eqn{x_{j+}}: sum of all elements in rows j.
  \item \eqn{x_{+j}}: sum of all elements in column j.
  \item \eqn{N}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$UserKappa_i(i, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}

\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with coefficient kappa (user's), its variance
and its confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(73,13,5,1,0,21,32,13,3,0,16,39,35,
29,13,3,5,7,28,48,1,0,2,3,17), nrow=5,ncol=5)
p<-ConfMatrix$new(A,Source="Næsset 1996")
p$UserKappa_i(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-ProdKappa_i"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-ProdKappa_i}{}}}
\subsection{Method \code{ProdKappa_i()}}{
Public method that evaluates the kappa coefficient from
the producer's perspective, for a specific class i. The method also
offers variance. The reference
\insertCite{rosenfield1986}{ConfMatrix} is followed
for the calculations.


\deqn{
ProdKappa_i=\dfrac{ProdAcc_i-\dfrac{\sum^n_{j=1} x_{ + j }}
{\sum^n_{i=1}\sum^n_{j=1} x_{ij}}}{1-\dfrac{\sum^n_{j=1} x_{+ j }}
{\sum^n_{i=1}\sum^n_{j=1} x_{ij}}}
}
 \deqn{
\sigma^2_{ProdKappa_i}=\dfrac{ProdKappa_i \cdot (1- ProdKappa_i)}{N}
}
where:

\enumerate{
  \item \eqn{ProdKappa_i}: coefficient kappa (producer's).
  \item \eqn{ProdAcc_i}: producer accuracy index for class i.
  \item \eqn{x_{ii}}: diagonal element of the matrix.
  \item \eqn{x_{j+}}: sum of all elements in rows j.
  \item \eqn{x_{+j}}: sum of all elements in column j.
  \item \eqn{N}: number of cases involved in the calculation of the
  index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$ProdKappa_i(i, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}

\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with coefficient kappa (producer's), its variance
and its confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(73,13,5,1,0,21,32,13,3,0,16,39,35,
29,13,3,5,7,28,48,1,0,2,3,17), nrow=5,ncol=5)
p<-ConfMatrix$new(A,Source="Næsset 1996")
p$ProdKappa_i(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-ModKappa"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-ModKappa}{}}}
\subsection{Method \code{ModKappa()}}{
Public method that provides the overall modified
kappa coefficient. The method also offers variance. The references
\insertCite{stehman1997,foody1992}{ConfMatrix} is followed for
the calculations.


\deqn{
ModKappa=\dfrac{OverallAcc-\dfrac{1}{\sqrt{M}}}{1-\dfrac{1}{\sqrt{M}}}
}
\deqn{
\sigma^2_{ModKappa}=\dfrac{ModKappa \cdot (1- ModKappa)}{N}
}
where:

\enumerate{
  \item \eqn{ModKappa}: modified coefficient kappa.
  \item \eqn{OverallAcc}: overall accuracy.
  \item \eqn{M}: number of classes.
  \item \eqn{N}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$ModKappa(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with modified coefficient kappa, its variance
and its confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(317,61,2,35,23,120,4,29,0,0,60,0,0,0,0,8),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Foody 1992")
p$ModKappa()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-ModKappaUser_i"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-ModKappaUser_i}{}}}
\subsection{Method \code{ModKappaUser_i()}}{
Public method, derived from the general modified
kappa coefficient, which provides the modified coefficient kappa
for the user. The method also offers variance. The references
\insertCite{stehman1997,foody1992}{ConfMatrix} is followed
for the calculations.


\deqn{
ModKappaUser_i=\dfrac{UserAcc_i-\dfrac{1}{\sqrt{M}}}
{1-\dfrac{1}{\sqrt{M}}}
}
\deqn{
\sigma^2_{ModKappaUser_i}=\dfrac{ModKappaUser_i
\cdot (1- ModKappaUser_i)}{N}
}
where:

\enumerate{
  \item \eqn{ModKappaUser_i}: modified coefficient kappa (user's).
  \item \eqn{UserAcc_i}: user accuracy index for class i.
  \item \eqn{M}: number of classes.
  \item \eqn{N}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$ModKappaUser_i(i, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}

\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with modified coefficient kappa (user's),
its variance and confidence interval
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Liu et al. 2007")
p$ModKappaUser_i(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-ModKappaProd_i"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-ModKappaProd_i}{}}}
\subsection{Method \code{ModKappaProd_i()}}{
Public method, derived from the general modified
kappa coefficient, which provides the modified coefficient kappa
for the producer. The method also offers variance.
The references \insertCite{stehman1997,foody1992}{ConfMatrix} is
followed for the calculations.


\deqn{
ModKappaProd_i=\dfrac{ProdAcc_i-\dfrac{1}{\sqrt{M}}}
{1-\dfrac{1}{\sqrt{M}}}
}
\deqn{
\sigma^2_{ModKappaProd_i}=\dfrac{ModKappaProd_i
\cdot (1- ModKappaProd_i)}{N}
}
where:

\enumerate{
  \item \eqn{ModKappaUser_i}: modified coefficient kappa (producer's).
  \item \eqn{ProdAcc_i}: producer accuracy index for class i.
  \item \eqn{M}: number of classes.
  \item \eqn{N}: number of cases involved in the calculation
  of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$ModKappaProd_i(i, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate.}

\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with modified coefficient kappa (producer's),
its variance and confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(317,61,2,35,23,120,4,29,0,0,60,0,0,0,0,8),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Liu et al. 2007")
p$ModKappaProd_i(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-EntropUser_i"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-EntropUser_i}{}}}
\subsection{Method \code{EntropUser_i()}}{
Public method that calculates relative change of
entropy given a category on map. That is, the degree of
uncertainty of the category. The method also offers variance.
The reference \insertCite{finn1993}{ConfMatrix} is followed for
the calculations.


\deqn{
Entrop_i(A)=-\sum^n_{j=1}( (\dfrac{\sum^n_{i=1} x_{i +}}
{\sum^n_{i,j=1} x_{ij} }) \cdot \log(\dfrac{\sum^n_{i=1} x_{i +}}
{\sum^n_{i,j=1} x_{ij} }) )
}
\deqn{
Entrop_i(A|b_i)=-\sum^n_{j=1}( (\dfrac{ x_{ij}}
{\sum^n_{j=1} x_{+ j} }) \cdot \log (\dfrac{x_{ij}}
{\sum^n_{j=1} x_{+ j}}) )
}
\deqn{
EntropUser_i= \dfrac{Entrop_i(A)-Entrop_i(A|b_i)}{Entrop_i(A)}
}
\deqn{
\sigma^2_{EntropUser_i}= \dfrac{EntropUser_i \cdot (1-EntropUser_i)}{N}
}

where:

\enumerate{
  \item \eqn{EntropUser_i}: relative change of entropy given a
  category on map.
  \item \eqn{Entrop_i(A)}: Entropy of the map with respect to
  the category of the map.
  \item \eqn{x_{j+}}: sum of all elements in rows j.
  \item \eqn{x_{+j}}: sum of all elements in column j.
  \item \eqn{Entrop_i(A|b_i)}: Entropy of map A knowing that the
  location corresponding to map B is in class b_i.
  \item \eqn{N}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$EntropUser_i(i, v = NULL, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate (row).}

\item{\code{v}}{Base of the logarithm. By default v=10.
This value is used for the entropy units, v=10(Hartleys), v=2(bits),
v=e(nats).}

\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with the relative change of entropy given a
category on map, its variance, its confidence interval, map entropy,
and entropy of map A knowing that the location corresponding to map
B is in class b_i.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Liu et al. 2007")
p$EntropUser_i(1)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-EntropProd_i"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-EntropProd_i}{}}}
\subsection{Method \code{EntropProd_i()}}{
Public method that calculates relative change of
entropy given a category on ground truthing. That is, the degree
of uncertainty of the category. The method also offers variance.
The reference \insertCite{stehman1997}{ConfMatrix} is followed for
the calculations.


\deqn{
Entrop_i(B)=-\sum^n_{i=1}( (\dfrac{\sum^n_{j=1} x_{+ j}}
{\sum^n_{i,j=1} x_{ij} }) \cdot \log (\dfrac{\sum^n_{j=1} x_{+ j}}
{\sum^n_{i,j=1} x_{ij} }) )
}
\deqn{
Entrop_i(B|a_j)=-\sum^n_{j=1}( (\dfrac{ x_{ij}}
{\sum^n_{i=1} x_{i +} }) \cdot \log (\dfrac{x_{ij}}
{\sum^n_{i=1} x_{i +}}) )
}
\deqn{
EntropProd_i= \dfrac{EntropMap(B)-EntropMap(B|a_j)}{EntropMap(B)}
}
\deqn{
\sigma^2_{EntropProd_i}= \dfrac{EntropProd_i \cdot (1-EntropProd_i)}{N}
}
where:

\enumerate{
  \item \eqn{EntropProd_i}: relative change of entropy given a
  category on ground truthing.
  \item \eqn{Entrop_i(B)}: Entropy of the map with respect to
  the category on ground truthing.
  \item \eqn{x_{j+}}: sum of all elements in rows j.
  \item \eqn{x_{+j}}: sum of all elements in column j.
  \item \eqn{Entrop_i(B|a_j)}: Entropy of map B knowing that the
  location corresponding to map A is in class a_j.
  \item \eqn{N}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$EntropProd_i(i, v = NULL, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{Class to evaluate}

\item{\code{v}}{Base of the logarithm. By default v=10.
This value is used for the entropy units, v=10(Hartleys), v=2(bits),
v=e(nats).}

\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of the relative change of entropy given a category
on ground truthing, its variance,its confidence interval,
map entropy, and entropy of map B knowing that the location
corresponding to map A is in class a_j.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Liu et al. 2007")
p$EntropProd_i(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-AvUserAcc"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-AvUserAcc}{}}}
\subsection{Method \code{AvUserAcc()}}{
Public method that provides the user's average
accuracy, which is an average of the accuracy of individual
categories, in this case the categories will be taken from
the user's perspective. The method also offers variance. The
reference \insertCite{tung1988}{ConfMatrix} is followed for the
calculations.


\deqn{
AvUserAcc=\dfrac{1}{\sqrt{M}} \sum^n_{i=1} \dfrac{x_{ii}}
{\sum_{j=1}^n x_{j+}}
}
\deqn{
\sigma^2_{AvUserAcc}=\dfrac{AvUserAcc \cdot (1-AvUserAcc)}{N}
}
where:

\enumerate{
  \item \eqn{AvUserAcc}: average accuracy from user's perspective.
  \item \eqn{x_{j+}}: sum of all elements in rows j.
  \item \eqn{x_{ii}}: diagonal element of the matrix.
  \item \eqn{M}: number of classes.
  \item \eqn{N}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$AvUserAcc(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with the average accuracy from user's perspective,
its variance and its confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(352,43,89,203),nrow=2,ncol=2)
p<-ConfMatrix$new(A,Source="Tung and LeDrew 1988")
p$AvUserAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-AvProdAcc"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-AvProdAcc}{}}}
\subsection{Method \code{AvProdAcc()}}{
Public method that provides the producer's average
accuracy, which is an average of the accuracy of individual
categories, in this case the categories will be taken from the
producer's perspective. The method also offers variance.
The reference \insertCite{tung1988}{ConfMatrix} is followed for
the calculations.


\deqn{
AvProdAcc=\dfrac{1}{\sqrt{N}} \sum^n_{i=1} \dfrac{x_{ii}}
{\sum_{j=1}^n x_{+j}}
}
\deqn{
\sigma^2_{AvProdAcc}=\dfrac{AvProdAcc \cdot (1-AvProdAcc)}{N}
}
where:

\enumerate{
  \item \eqn{AvProdAcc}: average accuracy from producer's perspective.
  \item \eqn{x_{+j}}: sum of all elements in column j.
  \item \eqn{x_{ii}}: diagonal element of the matrix.
  \item \eqn{M}: number of classes.
  \item \eqn{N}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$AvProdAcc(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with the average accuracy from producer's
perspective, its variance and its confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(352,43,89,203),nrow=2,ncol=2)
p<-ConfMatrix$new(A,Source="Tung and LeDrew 1988")
p$AvProdAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-AvUserProdAcc"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-AvUserProdAcc}{}}}
\subsection{Method \code{AvUserProdAcc()}}{
Public method that offers the average of the average
precision from the perspective of the user and the producer. The
method also offers variance. The reference
\insertCite{liu2007}{ConfMatrix} is followed for the calculations.


\deqn{
AvUserProdAcc=\dfrac{AvUserAcc+AvProdAcc}{2}
}
 \deqn{
\sigma^2_{AvUserProdAcc}=\dfrac{AvUserProdAcc \cdot (1-AvUserProdAcc)}{N}
}

where:

\enumerate{
  \item \eqn{AvUserProdAcc}: average of average of user's and
  producer's perspective.
  \item \eqn{AvUserAcc}: average accuracy from user's perspective.
  \item \eqn{AvProdAcc}: average accuracy from producer's perspective.
  \item \eqn{N}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$AvUserProdAcc(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of the average mean precision values from the user
and producer perspective, their variance and confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AvUserProdAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-AvHelldenAcc"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-AvHelldenAcc}{}}}
\subsection{Method \code{AvHelldenAcc()}}{
Public method that provides the average value of the
Hellden mean precision index. The method also offers variance.
The reference \insertCite{liu2007}{ConfMatrix} is followed for
the calculations.


\deqn{
AvHelldenAcc=\dfrac{1}{\sqrt{M}}\sum^n_{i=1} \dfrac{2 x_{ii}}
{ x_{+i} + x_{i+}}
}
 \deqn{
\sigma^2_{AvHelldenAcc}=\dfrac{AvHelldenAcc \cdot (1-AvHelldenAcc)}{N}
}

where:

\enumerate{
  \item \eqn{AvHelldenAcc}: average of Hellden's mean accuracy index.
  \item \eqn{x_{+i}}: sum of all elements in column i.
  \item \eqn{x_{i+}}: sum of all elements in row i.
  \item \eqn{x_{ii}}: diagonal element of the matrix.
  \item \eqn{M}: number of classes.
  \item \eqn{N}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$AvHelldenAcc(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with average of Hellden's mean accuracy index,
its variance and confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AvHelldenAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-AvShortAcc"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-AvShortAcc}{}}}
\subsection{Method \code{AvShortAcc()}}{
Public method that provides the average of Short's
mapping accuracy index. The method also offers variance. The
reference \insertCite{liu2007}{ConfMatrix} is followed for
the calculations.


\deqn{
AvShortAcc=\dfrac{1}{\sqrt{M}}\dfrac{\dfrac{\sum^n_{i=1} x_{ii}}
{\sum^n_{i,j=1}x_{ij}}}{\sum^n_{j=1} x_{+ j}+\sum^n_{i=1} x_{i +}
-x_{ii}}
}
\deqn{
\sigma^2_{AvShortAcc}=\dfrac{AvShortAcc \cdot (1-AvShortAcc)}{N}
}
where:

\enumerate{
  \item \eqn{x_{+i}}: sum of all elements in column i.
  \item \eqn{x_{i+}}: sum of all elements in row i.
  \item \eqn{x_{ii}}: diagonal element of the matrix.
  \item \eqn{M}: number of classes.
  \item \eqn{N}: number of cases involved in the calculation of the index.
   }
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$AvShortAcc(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with average of Short's mapping accuracy index, its variance and confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AvShortAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-CombUserAcc"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-CombUserAcc}{}}}
\subsection{Method \code{CombUserAcc()}}{
Public method that provides the combined user accuracy
that is the average of the overall accuracy and the average user
accuracy. The method also offers variance. The reference
\insertCite{tung1988}{ConfMatrix} is followed for the calculations.


\deqn{
CombUserAcc=\dfrac{OverallAcc+AvUserAcc}{2}
}
\deqn{
\sigma^2_{CombUserAcc}=\dfrac{CombUserAcc \cdot (1-CombUserAcc)}{N}
}

where:

\enumerate{
  \item \eqn{CombUserAcc}: combined accuracy from user's perspective.
  \item \eqn{OverallAcc}: overall accuracy.
  \item \eqn{AvUserAcc}: average accuracy from user's perspective.
  \item \eqn{N}: number of cases involved in the calculation of
  the index.
  }
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$CombUserAcc(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of the combined accuracy from the user's perspective,
its variation and confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(352,43,89,203),nrow=2,ncol=2)
p<-ConfMatrix$new(A,Source="Tung and LeDrew 1988")
p$CombUserAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-CombProdAcc"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-CombProdAcc}{}}}
\subsection{Method \code{CombProdAcc()}}{
Public method that provides the combined producer
accuracy that is the average of the overall accuracy and the average
producer accuracy. The method also offers variance. The reference
\insertCite{tung1988}{ConfMatrix} is followed for the calculations.


\deqn{
CombProdAcc=\dfrac{OverallAcc+AvProdAcc}{2}
}
\deqn{
\sigma^2_{CombProdAcc}=\dfrac{CombProdAcc \cdot (1-CombProdAcc)}{N}
}
where:

\enumerate{
  \item \eqn{CombProdAcc}: combined accuracy from producer's
  perspective.
  \item \eqn{OverallAcc}: overall accuracy.
  \item \eqn{AvProdAcc}: average accuracy from producer's perspective.
  \item \eqn{N}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$CombProdAcc(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of the combined accuracy from producer's perspective,
its variance and confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(352,43,89,203),nrow=2,ncol=2)
p<-ConfMatrix$new(A,Source="Tung and LeDrew 1988")
p$CombProdAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-CombUserProdAcc"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-CombUserProdAcc}{}}}
\subsection{Method \code{CombUserProdAcc()}}{
Public method that provides the combined accuracy
which is the average of the overall accuracy and the Hellden
average accuracy, which refers to the average user and producer
accuracies. The method also offers variation. The reference
\insertCite{liu2007}{ConfMatrix} is followed for the calculations.


\deqn{
CombUserProdAcc=\dfrac{OverallAcc+AvHelldenAcc}{2}
}
 \deqn{
\sigma^2_{CombUserProdAcc}=\dfrac{CombUserProdAcc \cdot
(1-CombUserProdAcc)}{N}
}
where:

\enumerate{
  \item \eqn{CombUserProdAcc}: combined accuracy from both user's
  and producer's perspectives.
  \item \eqn{OverallAcc}: overall accuracy.
  \item \eqn{AvHelldenAcc}: average of Hellden's mean accuracy index.
  \item \eqn{N}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$CombUserProdAcc(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of the combined accuracy from both user's and
producer's perspectives, its variance and confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$CombUserProdAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-Kappa"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-Kappa}{}}}
\subsection{Method \code{Kappa()}}{
Public method that provides kappa coefficient,
which measures the relationship between agreement beyond chance
and expected disagreement. The method also offers variation.
The reference \insertCite{cohen1960}{ConfMatrix} is followed
for the calculations.


\deqn{
ExpAcc=\sum^n_{i=1} (\dfrac{x _{+ i}}{\sum_{j=1}^n x_{ij}}
\cdot \dfrac{x _{i +}}{\sum_{j=1}^n x_{ij}})
}
\deqn{
Kappa=\dfrac{OverallAcc-ExpAcc}{1-ExpAcc}
}
 \deqn{
\sigma^2_{Kappa}=\dfrac{OverallAcc-ExpAcc}{(1-ExpAcc) \cdot N}
}



where:

\enumerate{
  \item \eqn{Kappa}: Kappa coefficient.
  \item \eqn{OverallAcc}: overall accuracy.
  \item \eqn{ExpAcc}: expected accuracy of agreement if agreement
  were purely random.
  \item \eqn{x_{+i}}: sum of all elements in column i.
  \item \eqn{x_{i+}}: sum of all elements in row i.
  \item \eqn{N}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$Kappa(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with kappa coefficient, its variance and confidence
interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$Kappa()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-Entrop"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-Entrop}{}}}
\subsection{Method \code{Entrop()}}{
Public method for calculating map entropy.
Which refers to the degree of uncertainty that the map presents.
The method also offers variation. The reference
\insertCite{finn1993}{ConfMatrix} is followed for the calculations.


\deqn{
Entrop=\sum^n_{i,j=1} (\dfrac{x_{ij}}{\sum^n_{i,j=1} x_{ij}}
 \cdot \log (\dfrac{x_{ij}}{\dfrac{\sum^n_{i=1} x_{i +}
 \cdot \sum^n_{j=1} x_{+ j}}{\sum^n_{i,j=1} x_{ij}}}))
}
\deqn{
\sigma^2_{Entrop}=\dfrac{Entrop \cdot (1-Entrop)}{N}
}
where:

\enumerate{
  \item \eqn{Entrop}: map entropy.
  \item \eqn{x_{+i}}: sum of all elements in column i.
  \item \eqn{x_{i+}}: sum of all elements in row i.
  \item \eqn{N}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$Entrop(v = NULL, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{v}}{Base of the logarithm. By default v=10. This value is used
for the entropy units, v=10(Hartleys), v=2(bits), v=e(nats).}

\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with map entropy, its variance and confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Liu et al. 2007")
p$Entrop()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-NormEntropUser"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-NormEntropUser}{}}}
\subsection{Method \code{NormEntropUser()}}{
Public method that calculates normalized entropy
using the map. The method also offers variation. The reference
\insertCite{finn1993}{ConfMatrix} is followed for the calculations.


\deqn{
Entrop_i(B)=-\sum^n_{i=1}( (\dfrac{\sum^n_{j=1} x_{+ j}}
{\sum^n_{i,j=1} x_{ij} }) \cdot \log (\dfrac{\sum^n_{j=1} x_{+ j}}
{\sum^n_{i,j=1} x_{ij} }) )
}
\deqn{
NormEntropUser=\dfrac{Entrop}{Entrop_i(B)}
}
\deqn{
\sigma^2_{NormEntropUser}=\dfrac{NormEntropUser \cdot (1-NormEntropUser)}{N}
}
where:

\enumerate{
  \item \eqn{NormEntropUser}: normalized entropy using map.
  \item \eqn{Entrop_i(B)}: entropy of the map with respect to
  the category on ground truthing.
  \item \eqn{Entrop}: map entropy.
  \item \eqn{x_{+i}}: sum of all elements in column i.
  \item \eqn{x_{i+}}: sum of all elements in row i.
  \item \eqn{N}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$NormEntropUser(v = NULL, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{v}}{Base of the logarithm. By default v=10. This value is used
for the entropy units, v=10(Hartleys), v=2(bits), v=e(nats).}

\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with normalized entropy using map, its variance and
confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Liu et al. 2007")
p$NormEntropUser()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-NormEntropProd"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-NormEntropProd}{}}}
\subsection{Method \code{NormEntropProd()}}{
Public method that calculates normalized entropy using
on ground truthing. The method also offers variation. The reference
\insertCite{finn1993}{ConfMatrix} is followed for the calculations.


\deqn{
Entrop_i(A)=-\sum^n_{j=1}( (\dfrac{\sum^n_{i=1} x_{i +}}
{\sum^n_{i,j=1} x_{ij} }) \cdot \log(\dfrac{\sum^n_{i=1} x_{i +}}
{\sum^n_{i,j=1} x_{ij} }) )
}
\deqn{
NormEntropProd=\dfrac{Entrop}{Entrop_i(A)}
}
\deqn{
\sigma^2_{NormEntropProd}=\dfrac{NormEntropProd \cdot (1-NormEntropProd)}{N}
}
where:

\enumerate{
  \item \eqn{NormEntropProd}: normalized mutual information using
  the entropy on ground truthing.
  \item \eqn{Entrop_i(A)}: Entropy of the map with respect to
  the category of the map.
  \item \eqn{Entrop}: map entropy.
  \item \eqn{x_{+i}}: sum of all elements in column i.
  \item \eqn{x_{i+}}: sum of all elements in row i.
  \item \eqn{N}: number of cases involved in the calculation of
  the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$NormEntropProd(v = NULL, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{v}}{Base of the logarithm. By default v=10. This value is
used for the entropy units, v=10(Hartleys), v=2(bits), v=e(nats).}

\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with normalized entropy using on ground truthing,
its variance and confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Liu et al. 2007")
p$NormEntropProd()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-AvNormEntrop"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-AvNormEntrop}{}}}
\subsection{Method \code{AvNormEntrop()}}{
Public method that calculates normalized entropy using
the arithmetic mean of the entropies on the map and on ground
truthing. The method also offers variation. The reference
\insertCite{strehl2002}{ConfMatrix} is followed for the calculations.


\deqn{
Entrop_i(A)=-\sum^n_{j=1}( (\dfrac{\sum^n_{i=1} x_{i +}}
{\sum^n_{i,j=1} x_{ij} }) \cdot \log(\dfrac{\sum^n_{i=1} x_{i +}}
{\sum^n_{i,j=1} x_{ij} }) )
}
\deqn{
Entrop_i(B)=-\sum^n_{i=1}( (\dfrac{\sum^n_{j=1} x_{+ j}}
{\sum^n_{i,j=1} x_{ij} }) \cdot \log (\dfrac{\sum^n_{j=1} x_{+ j}}
{\sum^n_{i,j=1} x_{ij} }) )
}
\deqn{
AvNormEntrop=\dfrac{2Entrop}{Entrop_i(A)+Entrop_i(B)}
}
\deqn{
\sigma^2_{AvNormEntrop}=\dfrac{AvNormEntrop \cdot (1-AvNormEntrop)}{N}
}

where:

\enumerate{
  \item \eqn{AvNormEntrop}: normalized entropy using the arithmetic
  mean of the entropies on the map and on ground truthing.
  \item \eqn{Entrop_i(B)}: entropy of the map with respect to
  the category on ground truthing.
  \item \eqn{Entrop_i(A)}: Entropy of the map with respect to
  the category of the map.
  \item \eqn{Entrop}: map entropy.
  \item \eqn{x_{+i}}: sum of all elements in column i.
  \item \eqn{x_{i+}}: sum of all elements in row i.
  \item \eqn{N}: number of cases involved in the calculation of the
  index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$AvNormEntrop(v = NULL, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{v}}{Base of the logarithm. By default v=10.
This value is used for the entropy units, v=10(Hartleys), v=2(bits),
v=e(nats).}

\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
normalized entropy using the arithmetic mean of the entropies
 on the map and on ground truthing, its variance and confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AvNormEntrop()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-GeomAvNormEntrop"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-GeomAvNormEntrop}{}}}
\subsection{Method \code{GeomAvNormEntrop()}}{
Public method that calculates normalized entropy using
the geometric mean of the entropies on the map and on ground truthing.
The method also offers variation. The reference
\insertCite{ghosh2002}{ConfMatrix} is followed for the calculations.


\deqn{
Entrop_i(A)=-\sum^n_{j=1}( (\dfrac{\sum^n_{i=1} x_{i +}}
{\sum^n_{i,j=1} x_{ij} }) \cdot \log(\dfrac{\sum^n_{i=1} x_{i +}}
{\sum^n_{i,j=1} x_{ij} }) )
}
\deqn{
Entrop_i(B)=-\sum^n_{i=1}( (\dfrac{\sum^n_{j=1} x_{+ j}}
{\sum^n_{i,j=1} x_{ij} }) \cdot \log (\dfrac{\sum^n_{j=1} x_{+ j}}
{\sum^n_{i,j=1} x_{ij} }) )
}
\deqn{
GeomAvNormEntrop=\dfrac{Entrop}{\sqrt{Entrop_i(A) \cdot Entrop_i(B)}}
}
\deqn{
\sigma^2_{GeomAvNormEntrop}=
\dfrac{GeomAvNormEntrop \cdot (1-GeomAvNormEntrop)}{N}
}
where:

\enumerate{
  \item \eqn{GeomAvNormEntrop}: normalized entropy using the
  geometric mean of the entropies on map and on ground truthing.
  \item \eqn{Entrop_i(B)}: entropy of the map with respect to the
  category on ground truthing.
  \item \eqn{Entrop_i(A)}: Entropy of the map with respect to the
  category of the map.
  \item \eqn{Entrop}: map entropy.
  \item \eqn{x_{+i}}: sum of all elements in column i.
  \item \eqn{x_{i+}}: sum of all elements in row i.
  \item \eqn{N}: number of cases involved in the calculation of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$GeomAvNormEntrop(v = NULL, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{v}}{Base of the logarithm. By default v=10.
This value is used for the entropy units, v=10(Hartleys), v=2(bits),
v=e(nats).}

\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with normalized entropy using the geometric mean of
the entropies on map and on ground truthing, its variance and
confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$GeomAvNormEntrop()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-AvMaxNormEntrop"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-AvMaxNormEntrop}{}}}
\subsection{Method \code{AvMaxNormEntrop()}}{
Public mathod that provides normalized entropy using
the arithmetic mean of the maximum entropies on map and on ground
truthing.The method also offers variation.
The reference \insertCite{strehl2002relationship}{ConfMatrix} is
followed for the calculations.


\deqn{
Entrop_i(A)=-\sum^n_{j=1}( (\dfrac{\sum^n_{i=1} x_{i +}}
{\sum^n_{i,j=1} x_{ij} }) \cdot \log(\dfrac{\sum^n_{i=1} x_{i +}}
{\sum^n_{i,j=1} x_{ij} }) )
}
\deqn{
Entrop_i(B)=-\sum^n_{i=1}( (\dfrac{\sum^n_{j=1} x_{+ j}}
{\sum^n_{i,j=1} x_{ij} }) \cdot \log (\dfrac{\sum^n_{j=1} x_{+ j}}
{\sum^n_{i,j=1} x_{ij} }) )
}
\deqn{
AvMaxNormEntrop=\dfrac{2 Entrop}{max(Entrop_i(A))+max(Entrop_i(B))}=
\dfrac{Entrop}{\log \sqrt{M}}
}
\deqn{
\sigma^2_{AvMaxNormEntrop}=
\dfrac{AvMaxNormEntrop \cdot (1-AvMaxNormEntrop)}{N}
}
where:

\enumerate{
  \item \eqn{AvMaxNormEntrop}: normalized entropy using the arithmetic
  mean of the maximum entropies on map and on ground truthing.
  \item \eqn{Entrop_i(B)}: entropy of the map with respect to the
  category on ground truthing.
  \item \eqn{Entrop_i(A)}: Entropy of the map with respect to the
  category of the map.
  \item \eqn{Entrop}: map entropy.
  \item \eqn{x_{+i}}: sum of all elements in column i.
  \item \eqn{x_{i+}}: sum of all elements in row i.
  \item \eqn{M}: number of elements of the matrix.
  \item \eqn{N}: number of cases involved in the calculation
  of the index.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$AvMaxNormEntrop(v = NULL, a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{v}}{Base of the logarithm. By default v=10. This value is
used for the entropy units, v=10(Hartleys), v=2(bits), v=e(nats).}

\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with normalized entropy using the arithmetic mean of
the maximum entropies on map and on ground truthing, its variance
and confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AvMaxNormEntrop()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-Tau"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-Tau}{}}}
\subsection{Method \code{Tau()}}{
Public method that calculates the tau index and
its variance. Its value indicates how much the classification has
improved compared to a random classification of the N elements into
M groups. The method also offers the variance.
The reference \insertCite{book}{ConfMatrix} is followed
for the computations.


The mathematical expression is:

\deqn{
PrAgCoef=\dfrac{1}{M}
}
\deqn{
Tau = \dfrac{OverallAcc-CoefAccPr}{1-PrAgCoef}
}

\deqn{
\sigma^2_{Tau}=\dfrac{OverallAcc \cdot (1-OverallAcc)}
{N \cdot (1-CoefAccPr)^2}
}

Where:
\enumerate{
  \item \eqn{OverallAcc}: overall accuracy.
  \item \eqn{PrAgCoef}: a priori random agreement coefficient.
  \item \eqn{M}: number of classes.
  \item \eqn{N}: number of elements of the matrix, cardinal of
  the matrix.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$Tau(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with Tau index, its variance and confidence interval.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(238051,7,132,0,0,24,9,2,189,1,4086,188,0,4,16,45,1,0,939,5082,
51817,0,34,500,1867,325,17,0,0,5,11148,1618,78,0,0,0,0,48,4,834,2853,340,
32,0,197,5,151,119,135,726,6774,75,1,553,0,105,601,110,174,155,8257,8,0,
29,36,280,0,0,6,5,2993,0,115,2,0,4,124,595,0,0,4374),nrow=9,ncol=9)
p<-ConfMatrix$new(A,Source="Muñoz 2016")
p$Tau()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-GroundTruth"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-GroundTruth}{}}}
\subsection{Method \code{GroundTruth()}}{
Public method that calculates the Ground Truth index
and its variance.The reference \insertCite{turk1979gt}{ConfMatrix}
is followed for the computations.


The mathematical expression is:

\deqn{
A_i=\dfrac{x_{ii}}{\sum_{j=1}^n x_{+j}}
}
\deqn{
GroundTruth = \dfrac{ProdAcc-R_i}{1-R_i}
}

\deqn{
\sigma^2_{GroundTruth}=\dfrac{GroundTruth \cdot (1-GroundTruth)}
{N}
}

Where:
\enumerate{
  \item \eqn{GroundTruth}: index ground truth.
  \item \eqn{R_i}: casual lucky guess.
  (See \insertCite{turk1979gt}{ConfMatrix})
  \item \eqn{ProdAcc}: producer accuracy.
  \item \eqn{N}: number of elements of the matrix, cardinal of
  the matrix.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$GroundTruth(a = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{Significance level. By default 0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with Ground Truth index, its variance, confidence
interval and the matrix with the expected frequencies.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,39,7,1,1,0,
6,25,1,1,0,0,1,6),nrow=5,ncol=5)
p<-ConfMatrix$new(A,Source="Türk 1979")
p$GroundTruth()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-UserProdAcc"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-UserProdAcc}{}}}
\subsection{Method \code{UserProdAcc()}}{
Public method that calculates the pressures of the
user and the producer jointly. The method also offers the standard
desviations. The reference \insertCite{congalton2008}{ConfMatrix}
is followed for the computations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$UserProdAcc()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list containing the producer's and user's accuracies and
their standard deviations, respectively.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$UserProdAcc()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-DetailedKappa"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-DetailedKappa}{}}}
\subsection{Method \code{DetailedKappa()}}{
Public method that calculates the general Kappa
agreement index, its standard deviation and the test statistic
to test its significance. The reference
\insertCite{congalton2008}{ConfMatrix} is followed for the computations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$DetailedKappa()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list of the kappa coefficient, its standard deviation,
and the value of its test statistic.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$DetailedKappa()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-DetailedCondKappa"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-DetailedCondKappa}{}}}
\subsection{Method \code{DetailedCondKappa()}}{
Public method that calculates the Kappa class agreement
index (conditional Kappa) from the perspective of user (i) and
producer (j) and its standard desviations. The reference
\insertCite{congalton2008}{ConfMatrix} is followed for the computations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$DetailedCondKappa()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list with conditional Kappa index of the user and the
producer, and its corresponding standard deviation.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$DetailedCondKappa ()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-QES"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-QES}{}}}
\subsection{Method \code{QES()}}{
Public method that calculates the values of quantity,
change and shift. The reference \insertCite{pontius2014}{ConfMatrix}
is followed for the computations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$QES(TI = NULL, SF = 1)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{TI}}{Time interval (default value = 1)}

\item{\code{SF}}{Scale factor for results (default value = 1)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of general values for the interval t of difference,
quantity, shift, and shift.In addition to the differences for
categories, number of components, change of categories and turn of
the components.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$QES(TI=1, SF=6)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-MTypify"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-MTypify}{}}}
\subsection{Method \code{MTypify()}}{
Public method that types the values of each cell.
 The total sum of the original matrix is used for typing.
 The resulting values can be presented as real (parameter RaR=1) or
 as a percentage (parameter RaR !=1)


\deqn{
MTypify=\dfrac{x_{ij}}{\sum^n_{i,j=1} x_{ij}}
}

where:

\enumerate{
  \item MTyipify: typified matrix.
  \item \eqn{x_{ij}}: matrix element.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$MTypify(RaR = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{RaR}}{"1" indicates result as real, other values mean percentage
as integer. By default RaR=1.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with original matrix and typified matrix
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A, Source="Congalton and Green 2008")
p$MTypify(RaR=5)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-AllParameters"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-AllParameters}{}}}
\subsection{Method \code{AllParameters()}}{
Public method in which multiple parameters are
calculated for the given confusion matrix. The references
\insertCite{congalton2008,cohen1960,munoz2016}{ConfMatrix} is
followed for the computations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$AllParameters()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list containing confusion matrix, dimension, total sum of
cell values, overall precision, overall variance precision,
global precision kappa index, global kappa simplified variance,
producer precision by class, user precision by class, pseudoceros matrix.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AllParameters()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-MBootStrap"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-MBootStrap}{}}}
\subsection{Method \code{MBootStrap()}}{
Public method that provides N resamples of the confusion
matrix from a ConfMatrix object. The reference
\insertCite{ariza2011}{ConfMatrix} is followed for the computations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$MBootStrap(n, pr = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n}}{Number of resamples.}

\item{\code{pr}}{Probability for resampling. By default, the probability of
success for each cell will be taken.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list formed by the original confusion matrix and simulated
matrices, from the confusion matrix. The multinomial distribution is
applied.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A, Source="Congalton and Green 2008")
p$MBootStrap(2)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-MNormalize"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-MNormalize}{}}}
\subsection{Method \code{MNormalize()}}{
Public method that carries out an iterative process
is carried out where each element is divided by the total of the
sum of its row, thus obtaining new values. In the next iteration,
all the elements are added by columns and each element is divided
by the total of its column and they obtain new values, and so on.
The references \insertCite{fienberg1970,munoz2016}{ConfMatrix}
is followed for the computations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$MNormalize(n = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n}}{Number of iteration. By default n=100.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list formed by the original confusion matrix and the
normalized matrix.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(238051,7,132,0,0,24,9,2,189,1,4086,188,0,4,16,45,1,0,939,5082,
51817,0,34,500,1867,325,17,0,0,5,11148,1618,78,0,0,0,0,48,4,834,2853,340,
32,0,197,5,151,119,135,726,6774,75,1,553,0,105,601,110,174,155,8257,8,0,
29,36,280,0,0,6,5,2993,0,115,2,0,4,124,595,0,0,4374),nrow=9,ncol=9)
p<-ConfMatrix$new(A,Source="Muñoz 2016")
p$MNormalize()$values

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-MPseudoZeroes"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-MPseudoZeroes}{}}}
\subsection{Method \code{MPseudoZeroes()}}{
Public method that small values are calculated for empty
cells of the matrix. All non-empty cells of the matrix change their
values. This function will not be applied if all the elements of the
matrix are different from 0.
The reference \insertCite{munoz2016}{ConfMatrix} is followed
for the computations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$MPseudoZeroes()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list formed by the original confusion matrix and the
Pseudozeroes matrix.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(238051,7,132,0,0,24,9,2,189,1,4086,188,0,4,16,45,1,0,939,5082,
51817,0,34,500,1867,325,17,0,0,5,11148,1618,78,0,0,0,0,48,4,834,2853,340,
32,0,197,5,151,119,135,726,6774,75,1,553,0,105,601,110,174,155,8257,8,0,
29,36,280,0,0,6,5,2993,0,115,2,0,4,124,595,0,0,4374),nrow=9,ncol=9)
p<-ConfMatrix$new(A,Source="Muñoz 2016")
p$MPseudoZeroes()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-DetailedWTau"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-DetailedWTau}{}}}
\subsection{Method \code{DetailedWTau()}}{
Public method that calculates the general Tau
concordance index and its standard deviation.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$DetailedWTau(WV)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{WV}}{Weights vector (as matrix)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with the weight matrix, the Tau index, its standard
deviation and its statistics.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
WV <-matrix(c(0.4, 0.1, 0.4, 0.1), ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$DetailedWTau(WV)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-DetailedWKappa"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-DetailedWKappa}{}}}
\subsection{Method \code{DetailedWKappa()}}{
Public method that calculates the general Kappa agreement
index (weighted) and its standard deviation. The reference
\insertCite{congalton2008}{ConfMatrix} is followed for the
computations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$DetailedWKappa(WM)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{WM}}{Weight matrix}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with the weight matrix, kappa index obtained from
the original matrix and the weight matrix, its standard desviations
and the value of its test statistic.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A <- A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
WM<- t(matrix(c(1,0,0.67,1,0,1,0,0,1,0,1,1,0.91,0,0.61,1),
nrow = 4, ncol=4))
p<-ConfMatrix$new(A)
p$DetailedWKappa(WM)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-UserProdAcc_W"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-UserProdAcc_W}{}}}
\subsection{Method \code{UserProdAcc_W()}}{
Public method that calculates the weighted accuracies
and standard deviations of the user and the producer.
The reference \insertCite{congalton2008}{ConfMatrix} is followed
for the computations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$UserProdAcc_W(WM)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{WM}}{Weight matrix}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with weight matrix, Matrix formed with its original
elements and their corresponding weights, general accuracy of the
weight matrix obtained, accuracy of the producer and user and their
standard deviations,
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
WM<- t(matrix(c(1,0,0.67,1,0,1,0,0,1,0,1,1,0.91,0,0.61,1),
nrow = 4, ncol=4))
p$UserProdAcc_W(WM)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-StHell"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-StHell}{}}}
\subsection{Method \code{StHell()}}{
Public method that provides the Hellinger distance
between two elements of the ConfMatrix class.
The reference \insertCite{garcia2018}{ConfMatrix} is followed
for the computations.
The mathematical expression is:

\deqn{
HD = \dfrac{4nm}{n+m} \sum^{M}_{i=1} (\sqrt{p_i}-\sqrt{q_i})^2
}

Where:
\enumerate{
  \item \eqn{HD}: Hellinger Distance
  \item \eqn{n}: number of elements in the matrix A.
  \item \eqn{p_i}: element i of the probability vector of matrix A.
  \item \eqn{q_i}: element i of the probability vector of matrix B.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$StHell(f, p = NULL, q = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{f}}{f Element of the ConfMatrix.}

\item{\code{p}}{matrix probability vector. By default, the probability of
success for each cell is taken.}

\item{\code{q}}{matrix probability vector. By default, the probability of
success for each cell is taken.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The statistic value of the statistical test based on the
Hellinger distance.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
r<-ConfMatrix$new(A,Source="Congalton and Green 2008")
B<-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),
nrow=4,ncol=4)
f<-ConfMatrix$new(B,Source="Congalton and Green 2008")
p$StHell(f)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-Kappa.test"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-Kappa.test}{}}}
\subsection{Method \code{Kappa.test()}}{
Public method that tests whether two independent
confusion matrices of the ConfMatrix class are significantly different
using their kappa index.
The reference \insertCite{congalton2008}{ConfMatrix} is followed
for the computations.
The mathematical expression to calculate its statistic is:

\deqn{
Z = \dfrac{|k1-k2|}{\sqrt{(var(K1)+var(K2))}}
}

Where:
\enumerate{
  \item \eqn{k1}: kappa index of matrix A
  \item \eqn{k2}: kappa index of matrix B
  \item \eqn{var(k1)}: variance of k1.
  \item \eqn{var(k2)}: variance of k2.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$Kappa.test(f, alpha = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{f}}{Element of the ConfMatrix class.}

\item{\code{alpha}}{significance level. By default alpha=0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with the value of the statistic between kappa values
and its z score for a given alpha significance level.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
B<-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),nrow=4,ncol=4)
f<-ConfMatrix$new(B,Source="Congalton and Green 2008")
p$Kappa.test(f)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-OverallAcc.test"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-OverallAcc.test}{}}}
\subsection{Method \code{OverallAcc.test()}}{
Public method that tests whether two independent
confusion matrices of the ConfMatrix class are significantly different
using their overall accuracy index.
The reference \insertCite{book,ma1995Tau}{ConfMatrix} is followed
for the computations.
The mathematical expression to calculate its statistic is:

\deqn{
Z = \dfrac{|k1-k2|}{\sqrt{var(k1)+var(k2)}}
}

Where:
\enumerate{
  \item \eqn{k1}: overall index of matrix A
  \item \eqn{k2}: overall index of matrix B
  \item \eqn{var(K1)}: variance of k1.
  \item \eqn{var(K2)}: variance of k2.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$OverallAcc.test(f, alpha = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{f}}{Element of the ConfMatrix class.}

\item{\code{alpha}}{significance level. By default alpha=0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of the statistic's value between the overall
accuracies and its z-score for a given alpha significance level.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
B<-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),nrow=4,ncol=4)
f<-ConfMatrix$new(B,Source="Congalton and Green 2008")
p$OverallAcc.test(f)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-Tau.test"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-Tau.test}{}}}
\subsection{Method \code{Tau.test()}}{
Public method that tests whether two independent
confusion matrices of the ConfMatrix class are significantly different
using their Tau index.
The reference \insertCite{book,ma1995Tau}{ConfMatrix} is followed
for the computations.
The mathematical expression to calculate its statistic is:

\deqn{
Z = \dfrac{|k1-k2|}{\sqrt{var(k1)+var(k2)}}
}

Where:
\enumerate{
  \item \eqn{k1}: Tau index of matrix A
  \item \eqn{k2}: Tau index of matrix B
  \item \eqn{var(k1)}: variance of k1.
  \item \eqn{var(k2)}: variance of k2.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$Tau.test(f, alpha = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{f}}{Element of the ConfMatrix class.}

\item{\code{alpha}}{significance level. By default alpha=0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of the statistic's value between the Tau index and
its z-score for a given alpha significance level.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
B<-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),
nrow=4,ncol=4)
f<-ConfMatrix$new(B,Source="Congalton and Green 2008")
p$Tau.test(f)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-TSCM.test"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-TSCM.test}{}}}
\subsection{Method \code{TSCM.test()}}{
Public method that performs a homogeneity test between
two matrices of the ConfMatrix class based on the Hellinger distance.
The test considers the individual cell values in the matrices.
The reference \insertCite{garcia2018}{ConfMatrix} is followed for
the computations.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$TSCM.test(f, n1 = NULL, alpha = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{f}}{Element of the ConfMatrix class.}

\item{\code{n1}}{Number of bootstraps that you want to generate.
By default n=10000.}

\item{\code{alpha}}{significance level. By default alpha=0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
p value, alpha and decision to make.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
B<-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),
nrow=4,ncol=4)
f<-ConfMatrix$new(B,Source="Congalton and Green 2008")
p$TSCM.test(f)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-QIndep.test"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-QIndep.test}{}}}
\subsection{Method \code{QIndep.test()}}{
Public method that performs the
 quasi-independence test. The reference
\insertCite{turk1979gt,goodman1968analysis}{ConfMatrix} is followed for the computations.
The mathematical expression to calculate its statistic is:

\deqn{
G^2 = 2 \cdot \sum \log \dfrac{x_{ij}}{E_{ij}}
}

Where:
\enumerate{
  \item \eqn{G^2}: statistic.
  \item \eqn{x_{ij}}: observed frequency.
  \item \eqn{E_{ij}}: expected frequency.
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$QIndep.test(alpha = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{alpha}}{significance level. By default alpha=0.05.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of the statistic's value and its z-score for a given
alpha significance level.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,39,
7,1,1,0,6,25,1,1,0,0,1,6),nrow=5,ncol=5)
p<-ConfMatrix$new(A,Source= "Türk 1979")
p$QIndep.test()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-plot.global"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-plot.global}{}}}
\subsection{Method \code{plot.global()}}{
Public method that provides the graph of the indices of
the functions OverallAcc, Kappa, Tau, AvHelldenAcc,
AvShortAcc with their corresponding standard desviation.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$plot.global()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
the graph of the indices of the functions OverallAcc, Kappa,
Tau, AvHelldenAcc, AvShortAcc with their corresponding
standard desviation.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),
nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$plot.global()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-plot.class"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-plot.class}{}}}
\subsection{Method \code{plot.class()}}{
Public method that provides the graph of the accuracy
index of users and producers with their corresponding standard desviation.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$plot.class()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The graph of the accuracy index of users and producers
with their corresponding standard desviation.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{A<-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p<-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$plot.class()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ConfMatrix-clone"></a>}}
\if{latex}{\out{\hypertarget{method-ConfMatrix-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ConfMatrix$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
